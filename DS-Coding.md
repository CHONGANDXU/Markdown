- [ç¬¬ä¸€ç« â€”â€”ç»ªè®º](#ç¬¬ä¸€ç« ç»ªè®º)
- [ç¬¬äºŒç« â€”â€”çº¿æ€§è¡¨](#ç¬¬äºŒç« çº¿æ€§è¡¨)
  - [2.1 çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ](#21-çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ)
  - [2.2 çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º](#22-çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º)
  - [2.3 çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º](#23-çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º)
    - [2.3.1 å•é“¾è¡¨](#231-å•é“¾è¡¨)
    - [2.3.2 åŒé“¾è¡¨](#232-åŒé“¾è¡¨)
    - [2.3.3 å¾ªç¯é“¾è¡¨\&\&é™æ€é“¾è¡¨](#233-å¾ªç¯é“¾è¡¨é™æ€é“¾è¡¨)
- [ç¬¬ä¸‰ç« â€”â€”æ ˆã€é˜Ÿåˆ—å’Œæ•°ç»„](#ç¬¬ä¸‰ç« æ ˆé˜Ÿåˆ—å’Œæ•°ç»„)
  - [3.1 æ ˆ](#31-æ ˆ)
    - [3.1.1 æ ˆçš„åŸºæœ¬æ¦‚å¿µ](#311-æ ˆçš„åŸºæœ¬æ¦‚å¿µ)
    - [3.1.2 æ ˆçš„é¡ºåºå­˜å‚¨ï¼ˆé¡ºåºæ ˆï¼‰](#312-æ ˆçš„é¡ºåºå­˜å‚¨é¡ºåºæ ˆ)
      - [å…±äº«æ ˆ](#å…±äº«æ ˆ)
    - [3.1.3 æ ˆçš„é“¾å¼å­˜å‚¨ï¼ˆé“¾å¼æ ˆï¼‰](#313-æ ˆçš„é“¾å¼å­˜å‚¨é“¾å¼æ ˆ)
    - [3.1.4 æ ˆçš„åº”ç”¨](#314-æ ˆçš„åº”ç”¨)
  - [3.2 é˜Ÿåˆ—](#32-é˜Ÿåˆ—)
    - [3.2.1 é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„](#321-é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„)
    - [3.2.2 é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨](#322-é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨)
    - [3.2.3 é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨](#323-é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨)
    - [3.2.4 åŒç«¯é˜Ÿåˆ—ï¼ˆä¸å—é™å’Œå—é™ï¼‰](#324-åŒç«¯é˜Ÿåˆ—ä¸å—é™å’Œå—é™)
    - [3.2.5 é˜Ÿåˆ—çš„åº”ç”¨](#325-é˜Ÿåˆ—çš„åº”ç”¨)
  - [3.3 æ•°ç»„å’Œç‰¹æ®ŠçŸ©é˜µ](#33-æ•°ç»„å’Œç‰¹æ®ŠçŸ©é˜µ)
- [ç¬¬å››ç« â€”â€”ä¸²(ä¸è€ƒï¼Œå¯ç•¥è¿‡)](#ç¬¬å››ç« ä¸²ä¸è€ƒå¯ç•¥è¿‡)
  - [4.1 ä¸²çš„å®šä¹‰å’Œå®ç°](#41-ä¸²çš„å®šä¹‰å’Œå®ç°)
    - [ä¸²çš„é¡ºåºå­˜å‚¨](#ä¸²çš„é¡ºåºå­˜å‚¨)
    - [ä¸²çš„é“¾å¼å­˜å‚¨](#ä¸²çš„é“¾å¼å­˜å‚¨)
  - [4.2 ä¸²çš„æ¨¡å¼åŒ¹é…](#42-ä¸²çš„æ¨¡å¼åŒ¹é…)
    - [4.2.1 æœ´ç´ æ¨¡å¼åŒ¹é…ï¼ˆå®šä½æ“ä½œï¼‰](#421-æœ´ç´ æ¨¡å¼åŒ¹é…å®šä½æ“ä½œ)
    - [4.2.2 KMP](#422-kmp)
    - [4.2.3 KMPç®—æ³•ä¼˜åŒ–â€”â€”nextvalæ•°ç»„](#423-kmpç®—æ³•ä¼˜åŒ–nextvalæ•°ç»„)
- [ç¬¬äº”ç« â€”â€”æ ‘ä¸äºŒå‰æ ‘](#ç¬¬äº”ç« æ ‘ä¸äºŒå‰æ ‘)
  - [5.1 æ ‘çš„åŸºæœ¬æ¦‚å¿µ](#51-æ ‘çš„åŸºæœ¬æ¦‚å¿µ)
  - [5.2 äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ](#52-äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ)
    - [5.2.1 äºŒå‰æ ‘çš„å®šä¹‰åŠå…¶ä¸»è¦ç‰¹å¾](#521-äºŒå‰æ ‘çš„å®šä¹‰åŠå…¶ä¸»è¦ç‰¹å¾)
    - [5.2.2 äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„ã€éå†](#522-äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„éå†)
  - [5.3 çº¿ç´¢äºŒå‰æ ‘](#53-çº¿ç´¢äºŒå‰æ ‘)
    - [5.3.1 çº¿ç´¢åŒ–äºŒå‰æ ‘](#531-çº¿ç´¢åŒ–äºŒå‰æ ‘)
    - [5.3.2 çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±(åç»§)â€”â€”æ²¡æ•´ç†å®Œæ•´](#532-çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±åç»§æ²¡æ•´ç†å®Œæ•´)
  - [5.4 æ ‘ã€æ£®æ—](#54-æ ‘æ£®æ—)
    - [5.4.1 æ ‘çš„å­˜å‚¨ç»“æ„](#541-æ ‘çš„å­˜å‚¨ç»“æ„)
    - [5.4.2 æ ‘ã€æ£®æ—ä¸äºŒå‰æ ‘çš„è½¬æ¢](#542-æ ‘æ£®æ—ä¸äºŒå‰æ ‘çš„è½¬æ¢)
    - [5.4.3 æ ‘å’Œæ£®æ—çš„éå†](#543-æ ‘å’Œæ£®æ—çš„éå†)
  - [5.5 æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨](#55-æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨)
    - [5.5.1 å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç ](#551-å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç )
    - [5.5.2 å¹¶æŸ¥é›†](#552-å¹¶æŸ¥é›†)
- [ç¬¬å…­ç« â€”â€”å›¾](#ç¬¬å…­ç« å›¾)
  - [6.1 å›¾çš„åŸºæœ¬æ¦‚å¿µ](#61-å›¾çš„åŸºæœ¬æ¦‚å¿µ)
  - [6.2 å›¾çš„å­˜å‚¨åŠåŸºæœ¬æ“ä½œ](#62-å›¾çš„å­˜å‚¨åŠåŸºæœ¬æ“ä½œ)
    - [6.2.1 é‚»æ¥çŸ©é˜µæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰](#621-é‚»æ¥çŸ©é˜µæ³•é¡ºåºå­˜å‚¨)
    - [6.2.2 é‚»æ¥è¡¨æ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰](#622-é‚»æ¥è¡¨æ³•é¡ºåºé“¾å¼å­˜å‚¨)
  - [6.3 å›¾çš„éå†](#63-å›¾çš„éå†)
    - [6.3.1 BFS å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•](#631-bfs-å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•)
    - [6.3.2 DFS æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•](#632-dfs-æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•)
  - [6.4 åº”ç”¨](#64-åº”ç”¨)
    - [6.4.1 æœ€å°ç”Ÿæˆæ ‘](#641-æœ€å°ç”Ÿæˆæ ‘)
  - [é€‚åˆç”¨äºè¾¹ç¨ å¯†å›¾](#é€‚åˆç”¨äºè¾¹ç¨ å¯†å›¾)
    - [6.4.2 æœ€çŸ­è·¯å¾„](#642-æœ€çŸ­è·¯å¾„)
    - [6.4.3 æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰æè¿°è¡¨è¾¾å¼](#643-æœ‰å‘æ— ç¯å›¾dagæè¿°è¡¨è¾¾å¼)
    - [6.4.4 æ‹“æ‰‘æ’åº(é€†æ‹“æ‰‘æ’åº)](#644-æ‹“æ‰‘æ’åºé€†æ‹“æ‰‘æ’åº)
    - [6.4.5 å…³é”®è·¯å¾„](#645-å…³é”®è·¯å¾„)
- [ç¬¬ä¸ƒç« â€”â€”æŸ¥æ‰¾](#ç¬¬ä¸ƒç« æŸ¥æ‰¾)
  - [7.1 æŸ¥æ‰¾çš„åŸºæœ¬æ¦‚å¿µ](#71-æŸ¥æ‰¾çš„åŸºæœ¬æ¦‚å¿µ)
  - [7.2 é¡ºåºã€æŠ˜åŠã€åˆ†å—](#72-é¡ºåºæŠ˜åŠåˆ†å—)
    - [7.2.1 é¡ºåºæŸ¥æ‰¾](#721-é¡ºåºæŸ¥æ‰¾)
    - [7.2.2 æŠ˜åŠæŸ¥æ‰¾](#722-æŠ˜åŠæŸ¥æ‰¾)
    - [7.2.3 åˆ†å—æŸ¥æ‰¾â€”â€”(æ‰‹ç®—)](#723-åˆ†å—æŸ¥æ‰¾æ‰‹ç®—)
  - [7.3 æ ‘å‹æŸ¥æ‰¾](#73-æ ‘å‹æŸ¥æ‰¾)
    - [7.3.1 äºŒå‰æ’åºæ ‘ï¼ˆäºŒå‰æœç´¢æ ‘BSTï¼‰](#731-äºŒå‰æ’åºæ ‘äºŒå‰æœç´¢æ ‘bst)
    - [7.3.2 å¹³è¡¡äºŒå‰æ ‘](#732-å¹³è¡¡äºŒå‰æ ‘)
    - [7.3.3 çº¢é»‘æ ‘](#733-çº¢é»‘æ ‘)
  - [7.4 Bæ ‘å’ŒB+æ ‘](#74-bæ ‘å’Œbæ ‘)
    - [7.4.1 Bæ ‘](#741-bæ ‘)
    - [7.4.2 B+æ ‘](#742-bæ ‘)
  - [7.5 æ•£åˆ—è¡¨ï¼ˆå“ˆå¸Œè¡¨ï¼‰](#75-æ•£åˆ—è¡¨å“ˆå¸Œè¡¨)
- [ç¬¬å…«ç« â€”â€”æ’åº](#ç¬¬å…«ç« æ’åº)
  - [8.1 æ’å…¥æ’åº](#81-æ’å…¥æ’åº)
  - [8.2 äº¤æ¢æ’åº](#82-äº¤æ¢æ’åº)
  - [8.3 é€‰æ‹©æ’åº](#83-é€‰æ‹©æ’åº)
  - [8.4 å½’å¹¶æ’åºå’ŒåŸºæ•°æ’åº](#84-å½’å¹¶æ’åºå’ŒåŸºæ•°æ’åº)
    - [8.4.1 å½’å¹¶æ’åºâ€”â€”ç¨³å®š](#841-å½’å¹¶æ’åºç¨³å®š)
    - [8.4.2 åŸºæ•°æ’åºâ€”â€”ç¨³å®š](#842-åŸºæ•°æ’åºç¨³å®š)
- [ç¬¬ä¹ç« â€”â€”ç®—æ³•](#ç¬¬ä¹ç« ç®—æ³•)
  - [9.1 åˆ†æ²»æ³•](#91-åˆ†æ²»æ³•)
  - [9.2 åŠ¨æ€è§„åˆ’](#92-åŠ¨æ€è§„åˆ’)
  - [9.3 è´ªå¿ƒ](#93-è´ªå¿ƒ)

# ç¬¬ä¸€ç« â€”â€”ç»ªè®º

# ç¬¬äºŒç« â€”â€”çº¿æ€§è¡¨

## 2.1 çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ

## 2.2 çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º
- é™æ€åˆ†é…
  - ```data[MaxSize]```
  - åŸºæœ¬æ“ä½œï¼šæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾

```c++
// é™æ€æ•°ç»„æ’å…¥
bool ListInsert(SqList &L, int i, int ele) {
  if (i < 1 || i > L.length + 1)
    return false;
  if (L.length >= MaxSize)
    return false;
  for (int j = L.length; j >= i; j--) {
    L.data[j] = L.data[j - 1];
  }                  // å°†ç¬¬iä¸ªå…ƒç´ åŠä¹‹åçš„å…ƒç´ åç§»
  L.data[i - 1] = ele; // åœ¨ä½ç½®iå¤„æ”¾å…¥ele
  L.length++;
  return true;
}

//é™æ€æ•°æ®åˆ é™¤
bool ListDelete(SqList &L, int i, int &deletedData) {
  if (i < 1 || i > L.length) // åˆ¤æ–­içš„èŒƒå›´æ˜¯å¦æœ‰æ•ˆ
    return false;
  deletedData = L.data[i - 1]; // å°†è¢«åˆ é™¤çš„å…ƒç´ èµ‹å€¼ç»™e
  for (int j = i; j < L.length; j++)
    L.data[j - 1] = L.data[j]; // å°†ç¬¬iä¸ªä½ç½®åçš„å…ƒç´ å‰ç§»
  L.length--;
  return true;
}

// æŒ‰ä½æŸ¥æ‰¾
int GetElem(SqList L, int i) { return L.data[i - 1]; }

// æŒ‰å€¼æŸ¥æ‰¾
int LocateElem(SqList L, int ele) {
  for (int i = 0; i < L.length; i++) {
    if (L.data[i] == ele)
      return i + 1;
  }
  return 0;
}
```

æ’å…¥æ“ä½œå¹³å‡æƒ…å†µï¼š

> å‡è®¾æ–°å…ƒç´ æ’å…¥åˆ°ä»»ä½•ä¸€ä¸ªä½ç½®çš„æ¦‚ç‡ç›¸åŒï¼Œå³ $i=1,2,3,\cdots,length,length+1$ çš„æ¦‚ç‡éƒ½æ˜¯ $p=\frac{1}{n+1}$
>
> - i=1, ç§»åŠ¨nä¸ªæ•°, å¾ªç¯næ¬¡ã€æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦ $O(n)$ ã€‘
> - i=2, ç§»åŠ¨n-1ä¸ªæ•°, å¾ªç¯n-1æ¬¡
> - i=3, ç§»åŠ¨n-2ä¸ªæ•°, å¾ªç¯n-2æ¬¡
> - â€¦â€¦
> - i=n, ç§»åŠ¨1ä¸ªæ•°, å¾ªç¯1æ¬¡
> - i=n+1, æ— éœ€ç§»åŠ¨æ•°ç»„, å¾ªç¯0æ¬¡ã€æœ€å¥½æƒ…å†µæ—¶é—´å¤æ‚åº¦ $O(1)$ ã€‘
>
> å¹³å‡å¾ªç¯æ¬¡æ•° = $[n+(n-1)+(n-2)+\cdots+1+0]*\frac{1}{n+1}=\frac{(1+n)n}{2}\frac{1}{n+1}=\frac{n}{2}$
>
> å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$

åˆ é™¤æ“ä½œå¹³å‡æƒ…å†µï¼š

> å‡è®¾åˆ é™¤ä»»ä½•ä¸€ä¸ªä½ç½®å…ƒç´ çš„æ¦‚ç‡ç›¸åŒï¼Œå³ $i=1,2,3,\cdots,length$ çš„æ¦‚ç‡éƒ½æ˜¯ $p=\frac{1}{n}$
>
> - i=1, ç§»åŠ¨n-1ä¸ªæ•°, å¾ªç¯n-1æ¬¡ã€æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦ $O(n)$ ã€‘
> - i=2, ç§»åŠ¨n-2ä¸ªæ•°, å¾ªç¯n-2æ¬¡
> - i=3, ç§»åŠ¨n-3ä¸ªæ•°, å¾ªç¯n-3æ¬¡
> - â€¦â€¦
> - i=n-1, ç§»åŠ¨1ä¸ªæ•°, å¾ªç¯1æ¬¡
> - i=n, ç§»åŠ¨0ä¸ªæ•°, å¾ªç¯0æ¬¡ã€æœ€å¥½æƒ…å†µæ—¶é—´å¤æ‚åº¦ $O(1)$ ã€‘
>
> å¹³å‡å¾ªç¯æ¬¡æ•° = $[(n-1)+(n-2)+\cdots+1+0]*\frac{1}{n}=\frac{(n-1)n}{2}\frac{1}{n}=\frac{n-1}{2}$
>
> å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$

- åŠ¨æ€åˆ†é…

```c++
#define InitSize 10 // é¡ºåºè¡¨çš„åˆå§‹é•¿åº¦
typedef struct {
  int *data;   // æŒ‡ç¤ºåŠ¨æ€åˆ†é…æ•°ç»„çš„æŒ‡é’ˆ
  int MaxSize; // é¡ºåºè¡¨çš„æœ€å¤§å®¹é‡
  int length;  // é¡ºåºè¡¨çš„å½“å‰é•¿åº¦
} SeqList;     // é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰(åŠ¨æ€åˆ†é…æ–¹å¼)

void InitList(SeqList &L) {
  // ç”¨ malloc å‡½æ•°ç”³è¯·ä¸€ç‰‡è¿ç»­çš„å­˜å‚¨ç©ºé—´
  L.data = (int *)malloc(InitSize * sizeof(int));
  L.length = 0;
  L.MaxSize = InitSize;
}

// å¢åŠ åŠ¨æ€æ•°ç»„çš„é•¿åº¦
void IncreaseSize(SeqList &L, int len) {
  L.data = (int *)realloc(L.data, (L.MaxSize + len) * sizeof(int));
  L.MaxSize = L.MaxSize + len;
}
```

## 2.3 çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º

### 2.3.1 å•é“¾è¡¨
```c++
#include <iostream>
using namespace std;

typedef int Elemtype;

typedef struct LNode { // å®šä¹‰å•é“¾è¡¨ç»“ç‚¹ç±»å‹
  Elemtype data;       // æ•°æ®åŸŸï¼ŒElemTypeä¸ºå¯ä¿®æ”¹çš„dataå±æ€§å€¼
  struct LNode *next;  // æŒ‡é’ˆåŸŸ
} LNode, *LinkList;

// åˆå§‹åŒ–ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨
bool initLinkList(LinkList &L) {
  L = (LNode *)malloc(sizeof(LNode));
  if (L == NULL) // å¦‚æœåˆå§‹å¤´ç»“ç‚¹å†…å­˜åˆ†é…å¤±è´¥,åˆ™è¿”å›false
    return false;
  L->next = NULL;
  return true;
}

// ä½¿ç”¨å¤´æ’æ³•å»ºç«‹å•é“¾è¡¨(å¸¦å¤´ç»“ç‚¹)
LinkList createList_Head(LinkList &L) {
  LNode *s;
  int x;
  L = (LinkList)malloc(sizeof(LNode)); // åˆ›å»ºå¤´ç»“ç‚¹
  L->next = NULL;                      // åˆå§‹ä¸ºç©ºé“¾è¡¨
  while (cin >> x) {
    s = (LNode *)malloc(sizeof(LNode));
    s->data = x;
    s->next = L->next;
    L->next = s;
  }
  // è¾“å…¥çš„å€¼ä¸æ˜¯æ•°å€¼å‹æ•°æ®ï¼Œè·³å‡ºç¨‹åº
  if (cin.fail()) {
    cout << "éæ³•è¾“å…¥ï¼Œåˆ›å»ºå•é“¾è¡¨ç»“æŸ" << std::endl;
  }
  return L;
}

// ä½¿ç”¨å°¾æ’æ³•å»ºç«‹å•é“¾è¡¨(å¸¦å¤´ç»“ç‚¹)
LinkList createList_Tail(LinkList &L) {
  L = (LinkList)malloc(sizeof(LNode));
  LNode *s, *r = L;
  int x;
  while (cin >> x) {
    s = (LNode *)malloc(sizeof(LNode));
    s->data = x;
    r->next = s;
    r = s; // r æŒ‡å‘æ–°çš„è¡¨å°¾ç»“ç‚¹
  }
  r->next = NULL; // å°¾æŒ‡é’ˆæŒ‡å‘ç©º
  // è¾“å…¥çš„å€¼ä¸æ˜¯æ•°å€¼å‹æ•°æ®ï¼Œè·³å‡ºç¨‹åº
  if (cin.fail()) {
    cout << "éæ³•è¾“å…¥ï¼Œåˆ›å»ºå•é“¾è¡¨ç»“æŸ" << std::endl;
  }
  return L;
}

// æŒ‰ä½æŸ¥æ‰¾ï¼Œä½¿ç”¨ ä¸‹æ ‡ è¿”å› è¯¥å•é“¾è¡¨ç»“ç‚¹(å¸¦å¤´ç»“ç‚¹)
LNode *GetElem(LinkList L, int i) {
  if (i < 0)
    return NULL;
  int j = 0;    // jè¡¨ç¤ºæŒ‡å‘çš„ç¬¬å‡ ä¸ªç»“ç‚¹
  LNode *p = L; // p æŒ‡å‘ L çš„å¤´ç»“ç‚¹(ä¸å¸¦æ•°æ®)
  while (p && j < i) {
    p = p->next;
    j++;
  }
  return p;
}

// æŒ‰å€¼æŸ¥æ‰¾ï¼Œä½¿ç”¨ å€¼data è¿”å› è¯¥ç‚¹é“¾è¡¨ç»“ç‚¹
LNode *LocateElem(LinkList L, int e) {
  LNode *p = L->next;
  while (p != NULL && p->data != e) {
    p = p->next;
  }
  return p;
}

// æŒ‰ä½ç½®é¡ºåºæ’å…¥(å¸¦å¤´ç»“ç‚¹),å·²çŸ¥è¦æ’å…¥çš„ä½ç½®nä¸æ–°æ’å…¥çš„ç»“ç‚¹æ•°æ®e
bool InsertElem(LinkList &L, Elemtype e, int n) {
  LNode *p = GetElem(L, n - 1);
  if (p == NULL)
    return false;
  LNode *s = (LNode *)malloc(sizeof(LNode));
  if (s == NULL)
    return false; // æ–°ç»“ç‚¹ s å†…å­˜åˆ†é…å¤±è´¥
  s->data = e;  
  s->next = p->next;
  p->next = s;
  return true;
}

// æŒ‰ä½åºåˆ é™¤ç»“ç‚¹(å¸¦å¤´ç»“ç‚¹),åˆ é™¤è¡¨Lä¸­ç¬¬nä¸ªä½ç½®çš„å…ƒç´ ï¼Œå¹¶ç”¨eè¿”å›åˆ é™¤å…ƒç´ çš„å€¼
bool DeleteElem(LinkList &L, Elemtype &e, int n) {
  LNode *p = GetElem(L, n - 1);
  if (p == NULL || p->next == NULL)
    return false;
  LNode *q = p->next;
  e = q->data;
  p->next = q->next;
  free(q);
  return true;
}

// åæ’æ“ä½œï¼Œåœ¨ p ç»“ç‚¹ä¹‹åæ’å…¥å…ƒç´  e
bool InsertNextNode(LNode *p, int e) {
  if (p == NULL)
    return false;
  LNode *s = (LNode *)malloc(sizeof(LNode));
  if (s == NULL)
    return false; // æ–°ç»“ç‚¹ s å†…å­˜åˆ†é…å¤±è´¥
  s->data = e;
  s->next = p->next;
  p->next = s;
  return true;
}

// å‰æ’æ“ä½œï¼šåœ¨ p ç»“ç‚¹ä¹‹å‰æ’å…¥å…ƒç´  e
bool InsertPriorNode(LNode *p, int e) {
  if (p == NULL)
    return false;
  LNode *s = (LNode *)malloc(sizeof(LNode));
  if (s == NULL)
    return false; // æ–°ç»“ç‚¹ s å†…å­˜åˆ†é…å¤±è´¥
  s->next = p->next;
  p->next = s;
  s->data = p->data;
  p->data = e;
  return true;
}

// åˆ é™¤æŒ‡å®š p ç»“ç‚¹
bool DeleteNode(LNode *p) {
  if (p == NULL)
    return false;
  LNode *q = p->next; // q æŒ‡å‘ p çš„åç»§ç»“ç‚¹
  p->data = q->data;
  p->next = q->next;
  free(q);
  return true;
}

// æ±‚è¡¨çš„é•¿åº¦
int Length(LinkList L) {
  int len = 0;
  LNode *p = L->next;
  while (p != NULL) {
    p = p->next;
    len++;
  }
  return len;
}

int main() {
  LinkList L;
  initLinkList(L);
  createList_Head(L);
  cout << L;
  return 0;
}
```

### 2.3.2 åŒé“¾è¡¨

```c++
#include <iostream>
using namespace std;

typedef struct DNode {        // å®šä¹‰åŒé“¾è¡¨ç»“ç‚¹ç±»å‹
  int data;                   // æ•°æ®åŸŸ
  struct DNode *prior, *next; // å‰é©±å’Œåé©±æŒ‡é’ˆ
} DNode, *DLinkList;

// åˆå§‹åŒ–åŒé“¾è¡¨
bool initDLinkList(DLinkList &L) {
  L = (DNode *)malloc(sizeof(DNode)); // åˆ†é…ä¸€ä¸ªå¤´ç»“ç‚¹
  if (L == NULL)
    return false;
  L->prior = NULL; // å¤´ç»“ç‚¹çš„prioræ°¸è¿œæŒ‡å‘NULL
  L->next = NULL;  // å¤´ç»“ç‚¹ä¹‹åæš‚æ—¶æ²¡æœ‰ç»“ç‚¹
  return true;
}

// åœ¨ p ç»“ç‚¹åæ’å…¥ s ç»“ç‚¹
bool insertNextDNode(DNode *p, DNode *s) {
  if (p == NULL || s == NULL)
    return false;
  s->next = p->next;
  if (p->next != NULL) // å¦‚æœpæœ‰åç»§ç»“ç‚¹
    p->next->prior = s;
  s->prior = p;
  p->next = s;
  return true;
}

// åˆ é™¤ p ç»“ç‚¹çš„åç»§ç»“ç‚¹
bool deleteNextDNode(DNode *p) {
  if (p == NULL)
    return false;
  DNode *q = p->next; // æ‰¾åˆ°pç»“ç‚¹çš„åç»§ç»“ç‚¹q
  if (q == NULL)
    return false; // pæ²¡æœ‰åç»§ç»“ç‚¹ï¼Œqä¸ºç©º
  p->next = q->next;
  if (q->next != NULL) // qä¸æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹
    q->next->prior = p;
  free(q); // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
  return true;
}

// Destroy a doubly linked list by freeing each node in a loop.
void DestroyDLinkList(DLinkList &L) {
  while (L->next != NULL)
    deleteNextDNode(L);
  free(L);  // é‡Šæ”¾å¤´ç»“ç‚¹
  L = NULL; // æŒ‡é’ˆç½®ç©º
}

void checkAllDNode(DLinkList &L) {
  DNode *p = L->next;
  while (p != NULL) { // åå‘éå†
    p = p->next;
    cout << p->data << " ";
  }
  while (p != NULL) { // å‰å‘éå†
    p = p->prior;
    cout << p->data << " ";
  }
  while (p->prior != NULL) { // å‰å‘éå†(è·³è¿‡å¤´ç»“ç‚¹)
    p = p->prior;
    cout << p->data << " ";
  }
}

// check the DLinkList is empty or not
bool isEmptyDLinkList(DLinkList &L) { return L->next == NULL; }

void testDLinkList() {
  DLinkList L;
  initDLinkList(L);
  insertNextDNode(L, (DNode *)malloc(sizeof(DNode)));
  insertNextDNode(L->next, (DNode *)malloc(sizeof(DNode)));
  DestroyDLinkList(L);
}
```

### 2.3.3 å¾ªç¯é“¾è¡¨&&é™æ€é“¾è¡¨

- å¾ªç¯å•é“¾è¡¨:å¾ªç¯å•é“¾è¡¨å’Œå•é“¾è¡¨çš„åŒºåˆ«åœ¨äºï¼Œè¡¨ä¸­æœ€åä¸€ä¸ªç»“ç‚¹çš„æŒ‡é’ˆä¸æ˜¯NULLï¼Œè€Œæ”¹ä¸ºæŒ‡å‘å¤´ç»“ç‚¹ï¼Œä»è€Œæ•´ä¸ªé“¾è¡¨å½¢æˆä¸€ä¸ªç¯
- å¾ªç¯åŒé“¾è¡¨:é¦–å°¾ç»“ç‚¹æ„æˆç¯
- é™æ€é“¾è¡¨:æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸å­˜å‚¨æ•°æ®ï¼Œå®ƒçš„æŒ‡é’ˆåŸŸå­˜å‚¨ç¬¬ä¸€ä¸ªå…ƒç´ æ‰€åœ¨çš„æ•°ç»„ä¸‹æ ‡ã€‚é“¾è¡¨æœ€åä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆåŸŸå€¼ä¸º-1

```c++
#define MaxSize 100;
typedef int Elemtype;
typedef struct { // é™æ€é“¾è¡¨å…ƒç´ ç»“æ„
  Elemtype data; // æ•°æ®åŸŸ
  int next;      // æŒ‡é’ˆåŸŸ
} *SLinkList;
```

# ç¬¬ä¸‰ç« â€”â€”æ ˆã€é˜Ÿåˆ—å’Œæ•°ç»„

## 3.1 æ ˆ

### 3.1.1 æ ˆçš„åŸºæœ¬æ¦‚å¿µ

### 3.1.2 æ ˆçš„é¡ºåºå­˜å‚¨ï¼ˆé¡ºåºæ ˆï¼‰

> nä¸ªä¸åŒå…ƒç´ è¿›æ ˆï¼Œå‡ºæ ˆå…ƒç´ ä¸åŒæ’åˆ—çš„ä¸ªæ•°ä¸º $\frac{1}{n+1}C^n_{2n}$ï¼Œä¸Šè¿°å…¬å¼æˆä¸ºå¡ç‰¹å…°æ•°

```c++
#include <iostream>
using namespace std;

#define MaxSize 10 // å®šä¹‰æ ˆä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct {
  int data[MaxSize]; // é™æ€æ•°æ®å­˜æ”¾æ ˆä¸­å…ƒç´ 
  int top;           // æ ˆé¡¶æŒ‡é’ˆ
} SqStack;

// åˆå§‹åŒ–æ ˆ
void InitStack(SqStack &S) {
  S.top = -1; // åˆå§‹åŒ–æ ˆé¡¶æŒ‡é’ˆ
}

// åˆ¤æ–­æ ˆç©ºä¸å¦
bool StackEmpty(SqStack S) {
  if (S.top == -1)
    return true; // æ ˆç©º
  else
    return false; // ä¸ç©º
}

// è¿›æ ˆ
bool Push(SqStack &S, int x) {
  if (S.top == MaxSize - 1) // æ ˆæ»¡
    return false;
  S.top = S.top + 1; // æŒ‡é’ˆ+1
  S.data[S.top] = x; // æ–°å…ƒç´ è¿›æ ˆ
  return true;
}

// å‡ºæ ˆ
bool Pop(SqStack &S, int &x) {
  if (S.top == -1)
    return false;    // æ ˆç©ºï¼ŒæŠ¥é”™
  x = S.data[S.top]; // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
  S.top = S.top - 1; // æŒ‡é’ˆ-1
  return true;
}

// è¯»æ ˆé¡¶æŒ‡é’ˆ
bool GetTop(SqStack S, int &x) {
  if (S.top == -1)
    return false;
  x = S.data[S.top]; // x è®°å½•æ ˆé¡¶å…ƒç´ 
  return true;
}
```

#### å…±äº«æ ˆ

```c++
#include <iostream>
using namespace std;

#define MaxSize 100 // å®šä¹‰æ ˆä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct {
  int data[MaxSize]; // é™æ€æ•°æ®å­˜æ”¾æ ˆä¸­å…ƒç´ 
  int top1;          // æ ˆé¡¶æŒ‡é’ˆ1
  int top2;          // æ ˆé¡¶æŒ‡é’ˆ2
} SqDouStack;

// åˆå§‹åŒ–æ ˆ
void InitStack(SqDouStack &S) {
  S.top1 = -1; // åˆå§‹åŒ–æ ˆé¡¶æŒ‡é’ˆ
  S.top2 = MaxSize;
}

// åˆ¤æ–­æ ˆç©º
bool StackEmpty(SqDouStack S) {
  if (S.top1 == -1 && S.top2 == MaxSize)
    return true; // æ ˆç©º
  else
    return false; // ä¸ç©º
}

// è¿›æ ˆ
bool Push(SqDouStack &S, int x, int StackNum) {
  if (S.top1 + 1 == S.top2) // æ ˆæ»¡
    return false;
  if (StackNum == 1) {
    S.top1 = S.top1 + 1; // 1æŒ‡é’ˆ+1
    S.data[S.top1] = x;  // æ–°å…ƒç´ è¿›æ ˆ1
  } else {
    S.top2 = S.top2 - 1; // 2æŒ‡é’ˆ-1
    S.data[S.top1] = x;  // æ–°å…ƒç´ è¿›æ ˆ2
  }
  return true;
}

// å‡ºæ ˆ
bool Pop(SqDouStack &S, int x, int StackNum) {
  if (StackNum == 1) {
    if (S.top1 == -1)
      return false;      // æ ˆç©ºï¼ŒæŠ¥é”™
    x = S.data[S.top1];  // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
    S.top1 = S.top1 - 1; // æŒ‡é’ˆ-1
    return true;
  } else {
    if (S.top2 == MaxSize)
      return false;      // æ ˆç©ºï¼ŒæŠ¥é”™
    x = S.data[S.top2];  // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
    S.top2 = S.top2 + 1; // æŒ‡é’ˆ-1
    return true;
  }
}

// è¯»æ ˆé¡¶æŒ‡é’ˆ
bool GetTop(SqDouStack S, int &x, int StackNum) {
  if (StackNum == 1) {
    if (S.top1 == -1)
      return false;
    x = S.data[S.top1]; // x è®°å½•æ ˆé¡¶å…ƒç´ 
    return true;
  } else {
    if (S.top2 == MaxSize)
      return false;
    x = S.data[S.top2]; // x è®°å½•æ ˆé¡¶å…ƒç´ 
    return true;
  }
}
```

### 3.1.3 æ ˆçš„é“¾å¼å­˜å‚¨ï¼ˆé“¾å¼æ ˆï¼‰

```c++
#include <iostream>
using namespace std;

typedef struct LinkNode {
  int data;
  struct LinkNode *next;
} *LiStack;

typedef struct LinkStack {
  LiStack top;
  int count;
} LinkStack;

bool Push(LinkStack &s, int x) {
  LiStack p = (LiStack)malloc(sizeof(LinkNode));
  p->data = x;
  p->next = s.top;
  s.top = p;
  s.count++;
  return true;
}

bool Pop(LinkStack &s, int &x) {
  if (s.top == NULL)
    return false;
  x = s.top->data;
  LinkNode *p = s.top;
  s.top = s.top->next;
  free(p);
  s.count--;
  return true;
}
```

### 3.1.4 æ ˆçš„åº”ç”¨

1. æ‹¬å·åŒ¹é…é—®é¢˜
```c++
#include <iostream>
using namespace std;

#define MaxSize 10
typedef struct {
  char data[MaxSize];
  int top;
} SqStack;

// åˆå§‹åŒ–æ ˆ
void InitStack(SqStack &S) { S.top = -1; }

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
bool StackEmpty(SqStack S) {
  if (S.top == -1)
    return true;
  else
    return false;
}

// æ–°å…ƒç´ å…¥æ ˆ
bool Push(SqStack &S, char x) {
  if (S.top == MaxSize - 1)
    return false;
  else {
    S.top++;
    S.data[S.top] = x;
    return true;
  }
}

// æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œç”¨xè¿”å›
bool Pop(SqStack &S, char &x) {
  if (S.top == -1)
    return false;
  else {
    x = S.data[S.top];
    S.top--;
    return true;
  }
}

bool bracketCheck(char str[], int length) {
  SqStack S;
  InitStack(S); // åˆå§‹åŒ–ä¸€ä¸ªæ ˆ
  for (int i = 0; i < length; i++) {
    if (str[i] == '(' || str[i] == '{' || str[i] == '[') {
      Push(S, str[i]); // æ‰«æåˆ°å·¦æ‹¬å·ï¼Œå…¥æ ˆæ“ä½œ
    } else {
      if (StackEmpty(S)) { // æ‰«æåˆ°å³æ‹¬å·ï¼Œç„¶è€Œæ ˆç©ºï¼ŒåŒ¹é…é”™è¯¯
        return false;
      }
      char topElem;
      Pop(S, topElem); // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
      if (str[i] == ')' && topElem != '(')
        return false;
      if (str[i] == ']' && topElem != '[')
        return false;
      if (str[i] == '}' && topElem != '{')
        return false;
    }
  }
  return StackEmpty(S); // æ£€ç´¢å®Œå…¨éƒ¨æ‹¬å·åï¼Œæ ˆç©ºè¯´æ˜åŒ¹é…æˆåŠŸ
}
```

2. ä¸‰ç§ç®—æœ¯è¡¨è¾¾å¼ï¼ˆè½¬æ¢åŠæ±‚å€¼ï¼‰
  - ä¸­ç¼€è¡¨è¾¾å¼
  - åç¼€è¡¨è¾¾å¼ = é€†æ³¢å…°è¡¨è¾¾å¼ã€**é‡è¦**ã€‘
  - å‰ç¼€è¡¨è¾¾å¼ = æ³¢å…°è¡¨è¾¾å¼

> åç¼€è¡¨è¾¾å¼ï¼ˆæ‰‹ç®—ï¼‰
> ã€ä¸­ç¼€è½¬åç¼€ã€‘
> â€œå·¦ä¼˜å…ˆâ€åŸåˆ™ï¼šåªè¦å·¦è¾¹çš„è¿ç®—ç¬¦èƒ½å…ˆè®¡ç®—ï¼Œå°±ä¼˜å…ˆç®—å·¦è¾¹çš„


> åç¼€è¡¨è¾¾å¼ï¼ˆæœºç®—ï¼‰
> > â‘ ä»å·¦å¾€å³æ‰«æä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œç›´åˆ°å¤„ç†å®Œæ‰€æœ‰å…ƒç´ 
> > â‘¡è‹¥æ‰«æåˆ°æ“ä½œæ•°åˆ™å‹å…¥æ ˆï¼Œå¹¶å›åˆ°â‘ ï¼šå¦åˆ™æ‰§è¡Œâ‘¢
> > â‘¢è‹¥æ‰«æåˆ°è¿ç®—ç¬¦ï¼Œåˆ™å¼¹å‡ºä¸¤ä¸ªæ ˆé¡¶å…ƒç´ (<font color='red'>æ³¨æ„ï¼šå…ˆå‡ºæ ˆçš„æ˜¯â€œå³æ“ä½œæ•°â€</font>)ï¼Œæ‰§è¡Œç›¸åº”è¿ç®—ï¼Œè¿ç®—ç»“æœå‹å›æ ˆé¡¶ï¼Œå›åˆ°â‘ 

---
> å‰ç¼€è¡¨è¾¾å¼ï¼ˆæ‰‹ç®—ï¼‰
> ã€ä¸­ç¼€è½¬å‰ç¼€ã€‘
> â€œå³ä¼˜å…ˆâ€åŸåˆ™ï¼šåªè¦å³è¾¹çš„è¿ç®—ç¬¦èƒ½å…ˆè®¡ç®—ï¼Œå°±ä¼˜å…ˆç®—å³è¾¹çš„


> å‰ç¼€è¡¨è¾¾å¼ï¼ˆæœºç®—ï¼‰
> > â‘ ä»å³å¾€å·¦æ‰«æä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œç›´åˆ°å¤„ç†å®Œæ‰€æœ‰å…ƒç´ 
> > â‘¡è‹¥æ‰«æåˆ°æ“ä½œæ•°åˆ™å‹å…¥æ ˆï¼Œå¹¶å›åˆ°â‘ ï¼šå¦åˆ™æ‰§è¡Œâ‘¢
> > â‘¢è‹¥æ‰«æåˆ°è¿ç®—ç¬¦ï¼Œåˆ™å¼¹å‡ºä¸¤ä¸ªæ ˆé¡¶å…ƒç´ (<font color='red'>æ³¨æ„ï¼šå…ˆå‡ºæ ˆçš„æ˜¯â€œå·¦æ“ä½œæ•°â€</font>)ï¼Œæ‰§è¡Œç›¸åº”è¿ç®—ï¼Œè¿ç®—ç»“æœå‹å›æ ˆé¡¶ï¼Œå›åˆ°â‘ 

---
> **ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼´è¡¨è¾¾å¼**ï¼ˆæœºç®—ï¼‰
> ä»å·¦åˆ°å³å¤„ç†å„ä¸ªå…ƒç´ ï¼Œç›´åˆ°æœ«å°¾ã€‚å¯èƒ½é‡åˆ°ä¸‰ç§æƒ…å†µï¼š
>
> â‘  é‡åˆ°æ“ä½œæ•°ã€‚ç›´æ¥åŠ å…¥åç¼€è¡¨è¾¾å¼ã€‚
> â‘¡ é‡åˆ°ç•Œé™ç¬¦ã€‚é‡åˆ° `(` ç›´æ¥å…¥æ ˆï¼›é‡åˆ° `)` åˆ™ä¾æ¬¡å¼¹å‡ºæ ˆå†…è¿ç®—ç¬¦å¹¶åŠ å…¥åç¼€è¡¨è¾¾å¼ï¼Œç›´åˆ°å¼¹å‡º  `(`  ä¸ºæ­¢ã€‚æ³¨æ„:  `(`  ä¸åŠ å…¥åç¼€è¡¨è¾¾å¼ã€‚
> â‘¢ é‡åˆ°è¿ç®—ç¬¦ã€‚ä¾æ¬¡å¼¹å‡ºæ ˆä¸­ä¼˜å…ˆçº§é«˜äºæˆ–ç­‰äºå½“å‰è¿ç®—ç¬¦çš„æ‰€æœ‰è¿ç®—ç¬¦ï¼Œå¹¶åŠ å…¥åç¼€è¡¨è¾¾å¼ï¼Œ è‹¥ç¢°åˆ°  `(`  æˆ–æ ˆç©ºåˆ™åœæ­¢ã€‚ä¹‹åå†å°†å½“å‰è¿ç®—ç¬¦å…¥æ ˆã€‚
>
> æŒ‰ä¸Šè¿°æ–¹æ³•å¤„ç†å®Œæ‰€æœ‰å­—ç¬¦åï¼Œå°†æ ˆä¸­å‰©ä½™è¿ç®—ç¬¦ä¾æ¬¡å¼¹å‡ºï¼Œå¹¶åŠ å…¥åç¼€è¡¨è¾¾å¼ã€‚

3. é€’å½’

```c++
#include <iostream>
#include <unordered_map>
using namespace std;

int Fib(int n) {
  static std::unordered_map<int, int> memo;

  if (n == 0)
    return 0;
  else if (n == 1)
    return 1;

  auto it = memo.find(n);
  if (it != memo.end())
    return it->second;

  int result = Fib(n - 1) + Fib(n - 2);
  memo.insert({n, result});

  for (const auto &pair : memo) {
    std::cout << "Key: " << pair.first << ", Value: " << pair.second
              << std::endl;
  }
  return result;
}

int main() {
  int x = Fib(10);
  cout << x << "  å¥¥é‡Œç»™ï¼ï¼ï¼" << endl;
  return 0;
}
```

## 3.2 é˜Ÿåˆ—

### 3.2.1 é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„

### 3.2.2 é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨

ä»¥ä¸‹Codeé‡‡ç”¨é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨ï¼Œä¸”ä½¿ç”¨å¾ªç¯é˜Ÿåˆ—å­˜å‚¨  
ä¸ºäº†åŒºåˆ†é˜Ÿç©ºå’Œé˜Ÿæ»¡ï¼Œé‡‡å–å…¥é˜Ÿæ—¶**å°‘ç”¨ä¸€ä¸ªé˜Ÿåˆ—å•å…ƒ**  

1. é˜Ÿåˆ—ç©ºçš„æ¡ä»¶ä¸º `Q.front == Q.rear`
2. é˜Ÿåˆ—æ»¡çš„æ¡ä»¶ä¸º `(Q.rear+1) % MaxSize == Q.front`
3. é˜Ÿåˆ—ä¸­å…ƒç´ çš„ä¸ªæ•° `(rear + MaxSize - front)%MaxSize`

```c++
#include <iostream>
using namespace std;

#define MaxSize 10
typedef struct SqQueue {
  int data[MaxSize];
  int front, rear;
} SqQueue;

// åˆå§‹åŒ–é˜Ÿåˆ—
void InitQueue(SqQueue &Q) { Q.front = Q.rear = 0; }

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
bool QueueEmpty(SqQueue Q) {
  if (Q.front == Q.rear)
    return true;
  else
    return false;
}

// å…¥é˜Ÿï¼ˆé˜Ÿå°¾å…¥é˜Ÿï¼‰
bool EnQueue(SqQueue &Q, int x) {
  if ((Q.rear + 1) % MaxSize == Q.front) // åˆ¤æ–­é˜Ÿæ»¡
    return false;
  Q.data[Q.rear] = x;              // æ–°å…ƒç´ æ’å…¥é˜Ÿå°¾
  Q.rear = (Q.rear + 1) % MaxSize; // é˜Ÿå°¾æŒ‡é’ˆåŠ 1å–æ¨¡
  return true;
}

// å‡ºé˜Ÿï¼ˆé˜Ÿå¤´å‡ºé˜Ÿï¼‰
bool DeQueue(SqQueue &Q, int &x) {
  if (Q.front == Q.rear) // é˜Ÿç©ºåˆ™æŠ¥é”™
    return false;
  x = Q.data[Q.front];
  Q.front = (Q.front + 1) % MaxSize;
  return true;
}

// è·å¾—é˜Ÿå¤´å…ƒç´ çš„å€¼,ç”¨xè¿”å›
int GetHead(SqQueue Q, int &x) {
  if (Q.front == Q.rear)
    return false; // é˜Ÿç©ºåˆ™æŠ¥é”™
  x = Q.data[Q.front];
  return x;
}
```



### 3.2.3 é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨

é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨ç»“æ„ï¼Œå…¶å®å°±æ˜¯çº¿æ€§è¡¨çš„å•é“¾è¡¨+é™åˆ¶ï¼Œè¡¨å¤´åˆ é™¤å…ƒç´ ï¼Œè¡¨å°¾æ’å…¥å…ƒç´ 

åŸºæœ¬æ“ä½œï¼šé˜Ÿå¤´å‡ºé˜Ÿï¼Œé˜Ÿå°¾å…¥é˜Ÿ

```c++
#include <iostream>
using namespace std;

typedef struct LinkNode { // é˜Ÿåˆ—ç»“ç‚¹
  int data;
  struct LinkNode *next;
} LinkNode;

typedef struct {          // é“¾å¼é˜Ÿåˆ—
  LinkNode *front, *rear; // é˜Ÿå¤´å’Œé˜Ÿå°¾æŒ‡é’ˆ
} LinkQueue;

// åˆå§‹åŒ–é˜Ÿåˆ—(å¸¦å¤´ç»“ç‚¹)
void InitQueue(LinkQueue &Q) {
  // åˆå§‹åŒ–,front rear éƒ½æŒ‡å‘å¤´ç»“ç‚¹
  Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode));
  Q.front->next = NULL;
}

// åˆå§‹åŒ–é˜Ÿåˆ—ï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
void InitQueue_NoHead(LinkQueue &Q) {
  // åˆå§‹åŒ–,front rear éƒ½æŒ‡å‘NULL
  Q.front = Q.rear = NULL;
}

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º(å¸¦å¤´ç»“ç‚¹)
bool IsEmpty(LinkQueue Q) {
  if (Q.front == Q.rear)
    return true;
  else
    return false;
}

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
bool IsEmpty_NoHead(LinkQueue Q) {
  if (Q.front == NULL)
    return true;
  else
    return false;
}

// æ–°å…ƒç´ å…¥é˜Ÿï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
void EnQueue(LinkQueue &Q, int x) {
  LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));
  s->data = x;
  s->next = NULL;
  Q.rear->next = s; // æ–°ç»“ç‚¹æ’å…¥åˆ°rearä¹‹å
  Q.rear = s;       // ä¿®æ”¹é˜Ÿå°¾æŒ‡é’ˆ
}

// æ–°å…ƒç´ å…¥é˜Ÿï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
void EnQueue_NoHead(LinkQueue &Q, int x) {
  LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));
  s->data = x;
  s->next = NULL;
  if (Q.front == NULL) { // åœ¨ç©ºé˜Ÿåˆ—ä¸­æ’å…¥ç¬¬ä¸€ä¸ªå…ƒç´ 
    Q.front = s;
    Q.rear = s;
  } else {
    Q.rear->next = s; // æ–°ç»“ç‚¹æ’å…¥åˆ°rearç»“ç‚¹ä¹‹å
    Q.rear = s;       // ä¿®æ”¹rearé˜Ÿå°¾æŒ‡é’ˆ
  }
}

// é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
bool DeQueue(LinkQueue &Q, int &x) {
  if (Q.front == Q.rear) // é˜Ÿç©º
    return false;
  LinkNode *p = Q.front->next; // pæŒ‡å‘æ­¤æ¬¡å‡ºé˜Ÿçš„é˜Ÿå¤´ç»“ç‚¹
  x = p->data;                 // ç”¨ x è¿”å›é˜Ÿå¤´çš„æ•°æ®
  Q.front->next = p->next;     // ä¿®æ”¹å¤´ç»“ç‚¹çš„nextæŒ‡é’ˆ

  if (Q.rear == p)    // å¦‚æœæ˜¯æœ€åä¸€ä¸ªç»“ç‚¹å‡ºé˜Ÿ
    Q.rear = Q.front; // ä¿®æ”¹ rear æŒ‡é’ˆ
  free(p);            // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
  return true;
}

// é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
bool DeQueue_NoHead(LinkQueue &Q, int &x) {
  if (Q.front == NULL)
    return false;        // é˜Ÿç©º
  LinkNode *p = Q.front; // pæŒ‡å‘æ­¤æ¬¡å‡ºé˜Ÿçš„é˜Ÿå¤´ç»“ç‚¹
  x = p->data;           // ç”¨å˜é‡ x è¿”å›é˜Ÿå¤´çš„æ•°æ®
  Q.front = p->next;     // ä¿®æ”¹ front æŒ‡é’ˆ
  if (Q.rear == p) {     // å€˜è‹¥æ˜¯é˜Ÿä¸­æœ€åä¸€ä¸ªç»“ç‚¹å‡ºé˜Ÿ
    Q.front = NULL;      // front æŒ‡å‘ NULL
    Q.rear = NULL;       // rear æŒ‡å‘ NULL
  }
  free(p); // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
  return true;
}
```

### 3.2.4 åŒç«¯é˜Ÿåˆ—ï¼ˆä¸å—é™å’Œå—é™ï¼‰

> 1. åŒç«¯é˜Ÿåˆ—ï¼ˆä¸å—é™åˆ¶ï¼‰
>> åŒç«¯é˜Ÿåˆ—æ˜¯æŒ‡å…è®¸ä¸¤ç«¯éƒ½å¯ä»¥è¿›è¡Œå…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œçš„é˜Ÿåˆ— 
>> é˜Ÿåˆ—çš„ä¸¤ç«¯åˆ†åˆ«ç§°ä¸ºå‰ç«¯å’Œåç«¯ï¼Œä¸¤ç«¯éƒ½å¯ä»¥å…¥é˜Ÿå’Œå‡ºé˜Ÿ
>
> 2. è¾“å‡ºå—é™çš„åŒç«¯é˜Ÿåˆ—
>> å…è®¸åœ¨ä¸€ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤ï¼Œä½†åœ¨å¦ä¸€ç«¯åªå…è®¸æ’å…¥çš„åŒç«¯é˜Ÿåˆ—  
>
> 3. è¾“å…¥å—é™çš„åŒç«¯é˜Ÿåˆ—
>> å…è®¸åœ¨ä¸€ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤ï¼Œä½†åœ¨å¦ä¸€ç«¯åªå…è®¸åˆ é™¤çš„åŒç«¯é˜Ÿåˆ— 

### 3.2.5 é˜Ÿåˆ—çš„åº”ç”¨
1. æ ‘çš„å±‚æ¬¡éå†
2. å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†
3. æ“ä½œç³»ç»Ÿ FCFS(å…ˆæ¥å…ˆæœåŠ¡) ç¼“å†²åŒº

## 3.3 æ•°ç»„å’Œç‰¹æ®ŠçŸ©é˜µ

1. å¯¹ç§°çŸ©é˜µ: ç­–ç•¥ï¼šåªå­˜å‚¨ä¸»å¯¹è§’çº¿+ä¸‹ä¸‰è§’åŒº
2. ä¸‰è§’çŸ©é˜µ:
   1. ä¸‹ä¸‰è§’çŸ©é˜µï¼šé™¤äº†ä¸»å¯¹è§’çº¿å’Œä¸‹ä¸‰è§’åŒºï¼Œå…¶ä½™çš„å…ƒç´ éƒ½ç›¸åŒ
   2. ä¸Šä¸‰è§’çŸ©é˜µï¼šé™¤äº†ä¸»å¯¹è§’çº¿å’Œä¸Šä¸‰è§’åŒºï¼Œå…¶ä½™çš„å…ƒç´ éƒ½ç›¸åŒ
   3. å­˜å‚¨ç­–ç•¥ï¼šæœ€åä¸€ä¸ªä½ç½®å­˜å‚¨å¸¸é‡ `C`
3. ä¸‰å¯¹è§’çŸ©é˜µã€å¸¦çŠ¶çŸ©é˜µã€‘ï¼š $å½“ |i-j|>1 æ—¶, a_{i,j}=0 (1 \leqslant i,j \leqslant n)$
4. ç¨€ç–çŸ©é˜µ
   1. é¡ºåºå­˜å‚¨ä½¿ç”¨ä¸‰å…ƒç»„ <è¡Œ, åˆ—, å€¼>
   2. é“¾å¼å­˜å‚¨ä½¿ç”¨åå­—é“¾è¡¨æ³•

# ç¬¬å››ç« â€”â€”ä¸²(ä¸è€ƒï¼Œå¯ç•¥è¿‡)

## 4.1 ä¸²çš„å®šä¹‰å’Œå®ç°

### ä¸²çš„é¡ºåºå­˜å‚¨
```c++
#include<iostream>
using namespace std;

#define MAXLEN 255
typedef struct SString{
    char ch[MAXLEN];
    int length;
};

typedef struct HString{
    char *ch;
    int length;
};

void initHString(HString &s){
    S.ch=(char *)malloc(MAXLEN*sizeof(char));
    S.length=0;
}

//èµ‹å€¼æ“ä½œï¼Œå°†ä¸²Tèµ‹å€¼ä¸ºchars
bool StrAssign(SString &T,chars){

}

//å¤åˆ¶æ“ä½œï¼Œå°†ä¸²Så¤åˆ¶å¾—åˆ°ä¸²T
bool StrCopy(){

}

//åˆ¤ç©ºæ“ä½œï¼ŒSç©ºä¸²è¿”å›TRUEï¼Œå¦åˆ™False
bool StrEmpty(){
    
}

//æ±‚ä¸²é•¿ï¼Œè¿”å›ä¸²çš„å…ƒç´ ä¸ªæ•°
bool StrLength(){
    
}

//æ±‚å­ä¸²ï¼Œç”¨Subè¿”å›ä¸²Sçš„ç¬¬posä¸ªå­—ç¬¦èµ·é•¿åº¦ä¸ºlençš„å­ä¸²
bool SubString(SString &Sub,SString S,int pos,int len){
    if(pos+len-1 > S.length)        //å­ä¸²
        return false;
    for(int i = pos;i<pos+len;i++)
        Sub.ch[i-pos+1] = S.ch[i];
    Sub.length = len;
    return true;
}

//æ¯”è¾ƒæ“ä½œ,è‹¥S>T,åˆ™è¿”å›å€¼>0;è‹¥S=T,åˆ™è¿”å›å€¼=0;è‹¥S<T,åˆ™è¿”å›å€¼<0
int StrCompare(SString S,SString T){
    for(int i=1; i<S.length && i<T.length; i++){
        if(S.ch[i]!=T.ch[i])
            return S.ch[i]-T.ch[i];
    }
    cout<<"å­—ç¬¦ä¸²é•¿åº¦ä¸ç›¸ç­‰,å…¶å·®å€¼ä¸º"<<S.length-T.length;
    return S.length-T.length;
}

//å®šä½æ“ä½œã€‚è‹¥ä¸»ä¸²Sä¸­å­˜åœ¨ä¸ä¸²Tå€¼ç›¸åŒçš„å­ä¸²ï¼Œåˆ™è¿”å›å®ƒåœ¨ä¸»ä¸²Sä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œå¦åˆ™å‡½æ•°å€¼ä¸º0
int Index(SString S,SString T){
    int i=1;
    SString sub;
    while(i<=S.length-T.length+1){
        SubString(sub,S,i,T.length);
        if(StrCompare(sub,T)!=0)
            ++i;
        else
            return i;
    }
    return 0;
}

//æ¸…ç©ºæ“ä½œï¼Œå°†Sæ¸…ç©ºä¸ºç©ºä¸²
bool ClearString(){
    
}

//é”€æ¯æ“ä½œï¼Œå›æ”¶å­˜å‚¨ç©ºé—´
bool DestoryString(){

}

//ä¸²è¿æ¥ï¼Œç”¨Tè¿”å›ç”±S1å’ŒS2è”ç»“è€Œæˆçš„æ–°ä¸²
bool Concat(){

}
```

### ä¸²çš„é“¾å¼å­˜å‚¨
```c++
#include<iostream>
using namespace std;

#define MAXLEN 255
typedef struct StringNode{
    char ch;        //æ¯ä¸ªç»“ç‚¹å­˜å‚¨1ä¸ªå­—ç¬¦ï¼Œå­˜å‚¨å¯†åº¦ä½ï¼Œæ¯ä¸ªå­—ç¬¦1Bï¼Œæ¯ä¸ªæŒ‡é’ˆ4B
    char ch[4];     //å­˜å‚¨å¯†åº¦æé«˜
    struct StringNode *next;
}StringNode,*String;

```

## 4.2 ä¸²çš„æ¨¡å¼åŒ¹é…

### 4.2.1 æœ´ç´ æ¨¡å¼åŒ¹é…ï¼ˆå®šä½æ“ä½œï¼‰

ä¸»ä¸²çš„æ‰«ææŒ‡é’ˆ i ç»å¸¸å›æº¯ï¼Œå¯¼è‡´æ—¶é—´å¼€é”€å¢åŠ ï¼Œ<font color='red'>æœ€åæ—¶é—´å¤æ‚åº¦ O ( n m ) </font>

```c++
int Index(SString S,SString T){
    int k=1;
    int i=k,j=1;
    while(i<=S.length&&j<=T.length){
        if(S.ch[i]==T.ch[j]){
            ++i;
            ++j;        //ç»§ç»­æ¯”è¾ƒåç»§å­—ç¬¦
        }else{
            k++;        //æ£€æŸ¥åä¸€ä¸ªå­—ç¬¦ä¸²
            i=k;
            j=1;
        }
        if(j>T.length)
            return k;
        else
            return 0;
    }
}
```

### 4.2.2 KMP

æ”¹è¿›æ€è·¯ï¼šå½“å­ä¸²å’Œæ¨¡å¼ä¸²ä¸åŒ¹é…æ—¶ï¼Œä¸»ä¸²æŒ‡é’ˆä¸å›æº¯ï¼Œåªæœ‰æ¨¡å¼ä¸²æŒ‡é’ˆå›æº¯ j = next [ j ]

<font color='red'>ç®—æ³•å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO ( n + m )</font>

```c++
int Index_KMP(SString S,SString T,int next[]){
    int i=1,j=1;
    while(i<=S.length&&j<=T.length){
        if(j==0 || S.ch[i]==T.ch[i]){
            ++i;
            ++j;
        }else{
            j=next[j];
        }
        if(j>T.length)
            return i-T.length;
        else
            return 0; 
    }
}
```
ğŸ’¡ nextæ•°ç»„ï¼šå½“æ¨¡å¼ä¸²çš„ç¬¬ j ä¸ªå­—ç¬¦åŒ¹é…å¤±è´¥æ—¶ï¼Œä»¤æ¨¡å¼ä¸²è·³åˆ° next [ j ] å†ç»§ç»­åŒ¹é…   
æ¨¡å¼ä¸²å‘å³ç§»åŠ¨çœ‹åŒ¹é…ç¨‹åº¦

> ä¸²çš„å‰ç¼€ï¼šåŒ…å«ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œä¸”ä¸åŒ…å«æœ€åä¸€ä¸ªå­—ç¬¦çš„å­ä¸²
ä¸²çš„åç¼€ï¼šåŒ…å«æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œä¸”ä¸åŒ…å«ç¬¬ä¸€ä¸ªå­—ç¬¦çš„å­ä¸²
> 

ğŸ’¡ å½“ç¬¬ j ä¸ªå­—ç¬¦åŒ¹é…å¤±è´¥ï¼Œç”±å‰ 1 ï½ j - 1 ä¸ªå­—ç¬¦ç»„æˆçš„ä¸²è®°ä¸º S ,åˆ™ï¼š  
next [ j ] = S çš„æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦ + 1  
>ç‰¹åˆ«çš„ï¼Œnext [ 1 ] = 0 ä¸” next [ 2 ] = 1


### 4.2.3 KMPç®—æ³•ä¼˜åŒ–â€”â€”nextvalæ•°ç»„

# ç¬¬äº”ç« â€”â€”æ ‘ä¸äºŒå‰æ ‘

## 5.1 æ ‘çš„åŸºæœ¬æ¦‚å¿µ

å¸¸è€ƒæ€§è´¨:
1. ç»“ç‚¹æ•° = æ€»åº¦æ•° + 1
2. 
![åº¦ä¸ºmçš„æ ‘ã€må‰æ ‘çš„åŒºåˆ«](pictures/må‰æ ‘ä¸åº¦æ ‘çš„åŒºåˆ«.png)
3. åº¦ä¸º $m$ çš„æ ‘( $m$ å‰æ ‘)ç¬¬ $i$ å±‚è‡³å¤šæœ‰ $m^{i-1}$ ä¸ªç»“ç‚¹ï¼ˆ $i>=1$ ï¼‰
4. é«˜åº¦ä¸º $h$ çš„ $m$ å‰æ ‘è‡³å¤šæœ‰ $\frac{m^h-1}{m-1}$ ä¸ªç»“ç‚¹
5. - é«˜åº¦ $h$ çš„ $m$ å‰æ ‘è‡³å°‘æœ‰ $h$ ä¸ªç»“ç‚¹
   - é«˜åº¦ä¸º $h$ ã€åº¦ä¸º $m$ çš„æ ‘è‡³å°‘æœ‰ $h+m-1$ ä¸ªç»“ç‚¹
6. å…·æœ‰ $n$ ä¸ªç»“ç‚¹çš„ $m$ å‰æ ‘çš„æœ€å°é«˜åº¦ä¸º $\lceil\log_m(n(m-1)+1)\rceil$

## 5.2 äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ

### 5.2.1 äºŒå‰æ ‘çš„å®šä¹‰åŠå…¶ä¸»è¦ç‰¹å¾

1. 

$$
\begin{aligned}
  â‘  \quad n &=n_0+n_1+n_2    \\
  â‘¡ \quad n &= n_1+2n_2+1    \\
  â‘¡-â‘  \quad n_0&=n_2+1   
\end{aligned}
$$

2. $éç©ºäºŒå‰æ ‘ä¸Šç¬¬ i å±‚ä¸Šè‡³å¤šæœ‰ 2^{iâˆ’1} ä¸ªç»“ç‚¹ï¼ˆi \geqslant 1ï¼‰\\[5px]$
   
3. $må‰æ ‘ç¬¬ i å±‚è‡³å¤šæœ‰ m^{i - 1}ä¸ªç»“ç‚¹\\[5px]$
   
4. $é«˜åº¦ä¸º h çš„ äºŒå‰æ ‘ è‡³å¤šæœ‰ 2^h - 1 ä¸ªç»“ç‚¹ï¼ˆæ»¡äºŒå‰æ ‘ï¼‰\\[5px]$
   
5. $é«˜åº¦ä¸º h çš„ må‰æ ‘ è‡³å¤šæœ‰ \frac{m^h - 1}{m -1}ä¸ªç»“ç‚¹ï¼ˆh \geqslant 1ï¼‰\\[5px]$
   
6. 

$$
é«˜åº¦ä¸º h çš„ m å‰æ ‘ è‡³å°‘æœ‰hä¸ªç»“ç‚¹ \\ é«˜åº¦ä¸ºh ã€åº¦ä¸ºm çš„æ ‘è‡³å°‘æœ‰h+m-1ä¸ªç»“ç‚¹ 
$$

7. $å…·æœ‰Nä¸ªï¼ˆN>0ï¼‰ç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„é«˜åº¦ä¸º \lceil log_{2}(N+1) \rceil æˆ– \lfloor log_{2}N \rfloor+1ã€‚\\[5px]$


### 5.2.2 äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„ã€éå†

1. é¡ºåºå­˜å‚¨(é€‚ç”¨äºå®Œå…¨äºŒå‰æ ‘)

```c++
#include <iostream>
#define MaxSize 100
struct TreeNode {
  int value;    // ç»“ç‚¹ä¸­çš„æ•°æ®å…ƒç´ 
  bool isEmpty; // ç»“ç‚¹æ˜¯å¦ä¸ºç©º
};

TreeNode t[MaxSize];

void initTree() { // åˆå§‹åŒ–
  for (int i = 0; i < MaxSize; i++) {
    t[i].isEmpty = true;
  }
};
```

2. é“¾å¼å­˜å‚¨ï¼ˆéå†ï¼‰
    - å…ˆåºéå†
    - ä¸­åºéå†
    - ååºéå†
    - é€’å½’ç®—æ³•å’Œéé€’å½’ç®—æ³•çš„è½¬æ¢
    - å±‚æ¬¡éå†
    - ç”±éå†åºåˆ—æ„é€ äºŒå‰æ ‘ï¼ˆå¿…é¡»ç”±ä¸­åºéå†åºåˆ—ï¼‰

$n$ ä¸ªç»“ç‚¹çš„äºŒå‰é“¾è¡¨å…±æœ‰ $n+1$ ä¸ªç©ºé“¾åŸŸ

> ä¸‰ç§éå†ï¼ˆå…ˆåºä¸­åºååºï¼‰

```c++
#include <iostream>

struct ElemType {
  int value;
};

typedef struct BiTNode {
  ElemType data;                   // æ•°æ®åŸŸ
  struct BiTNode *lchild, *rchild; // å·¦å³å­©å­æŒ‡é’ˆ
  struct BiTNode *parent; // çˆ¶ç»“ç‚¹æŒ‡é’ˆ(æ–¹ä¾¿æŸ¥æ‰¾å½“å‰ç»“ç‚¹çš„çˆ¶ç»“ç‚¹)
} BiTNode, *BiTree;

void visit(BiTree T) { std::cout << T->data.value << std::endl; }

// å…ˆåºéå†
void PreOrder(BiTree T) {
  if (T != NULL) {
    visit(T);            // è®¿é—®æ ¹ç»“ç‚¹
    PreOrder(T->lchild); // é€’å½’éå†å·¦å­æ ‘
    PreOrder(T->rchild); // é€’å½’éå†å³å­æ ‘
  }
}

// ä¸­åºéå†
void InOrder(BiTree T) {
  if (T != NULL) {
    InOrder(T->lchild); // é€’å½’éå†å·¦å­æ ‘
    visit(T);           // è®¿é—®æ ¹ç»“ç‚¹
    InOrder(T->rchild); // é€’å½’éå†å³å­æ ‘
  }
}

// ååºéå†
void PostOrder(BiTree T) {
  if (T != NULL) {
    PostOrder(T->lchild); // é€’å½’éå†å·¦å­æ ‘
    PostOrder(T->rchild); // é€’å½’éå†å³å­æ ‘
    visit(T);             // è®¿é—®æ ¹ç»“ç‚¹
  }
}

int main() {
  // å®šä¹‰ä¸€æ£µç©ºæ ‘
  BiTree root = NULL;

  // æ’å…¥æ ¹ç»“ç‚¹ root
  root = (BiTree)malloc(sizeof(BiTNode));
  root->data = {1};
  root->lchild = NULL;
  root->rchild = NULL;

  // æ’å…¥æ–°ç»“ç‚¹ p
  BiTNode *p = (BiTNode *)malloc(sizeof(BiTNode));
  p->data = {2};
  p->lchild = NULL;
  p->rchild = NULL;

  // ä½œä¸ºæ ¹èŠ‚ç‚¹çš„å·¦å­©å­æ’å…¥ç»“ç‚¹ p
  root->lchild = p;
}
```

> å±‚åºéå†

```c++
#include <iostream>

// äºŒå‰æ ‘çš„ç»“ç‚¹ï¼ˆé“¾å¼å­˜å‚¨ï¼‰
typedef struct BiTNode {
  char data;                       // æ•°æ®åŸŸ
  struct BiTNode *lchild, *rchild; // å·¦å³å­©å­æŒ‡é’ˆ
} BiTNode, *BiTree;

// é“¾å¼é˜Ÿåˆ—ç»“ç‚¹
typedef struct LinkNode {
  BiTNode *data; // å­˜æŒ‡é’ˆè€Œä¸æ˜¯ç»“ç‚¹
  struct LinkNode *next;
} LinkNode;

typedef struct {
  LinkNode *front, *rear; // é˜Ÿå¤´é˜Ÿå°¾
} LinkQueue;

// å±‚åºéå†
void LevelOrder(BiTree T) {
  LinkQueue Q;
  InitQueue(Q); // åˆå§‹åŒ–è¾…åŠ©é˜Ÿåˆ—
  BiTree p;
  EnQueue(Q, T);        // å°†æ ¹ç»“ç‚¹å…¥é˜Ÿ
  while (!isEmpty(Q)) { // é˜Ÿåˆ—ä¸ç©ºåˆ™å¾ªç¯
    DeQueue(Q, p);      // é˜Ÿå¤´ç»“ç‚¹å‡ºé˜Ÿï¼ŒTèµ‹å€¼p
    visit(p);           // è®¿é—®å‡ºé˜Ÿç»“ç‚¹
    if (p->lchild != NULL)
      EnQueue(Q, p->lchild); // å·¦å­©å­å…¥é˜Ÿ
    if (p->rchild != NULL)
      EnQueue(Q, p->rchild); // å³å­©å­å…¥é˜Ÿ
  }
}
```

> ç”¨åœŸåŠæ³•æ‰¾åˆ°ä¸­åºå‰é©±

æ€è·¯ï¼š

ä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œé‡æ–°è¿›è¡Œä¸€æ¬¡ä¸­åºéå†ï¼ŒæŒ‡é’ˆ q è®°å½•å½“å‰è®¿é—®çš„ç»“ç‚¹ï¼ŒæŒ‡é’ˆ pre è®°å½•ä¸Šä¸€ä¸ªè¢«è®¿é—®çš„ç»“ç‚¹  

â‘  å½“ $q==p$ æ—¶ï¼Œpre ä¸ºå‰é©±  

â‘¡ å½“ $pre=p$ æ—¶ï¼Œq ä¸ºåç»§  

```c++
#include <iostream>

// äºŒå‰æ ‘çš„ç»“ç‚¹ï¼ˆé“¾å¼å­˜å‚¨ï¼‰
typedef struct BiTNode {
  char data;                       // æ•°æ®åŸŸ
  struct BiTNode *lchild, *rchild; // å·¦å³å­©å­æŒ‡é’ˆ
} BiTNode, *BiTree;

// è¾…åŠ©çš„å…¨å±€å˜é‡ï¼Œç”¨äºæŸ¥æ‰¾ç»“ç‚¹pçš„å‰é©±
BiTNode *p;            // pæŒ‡å‘ç›®æ ‡ç»“ç‚¹
BiTNode *pre = NULL;   // æŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
BiTNode *final = NULL; // ç”¨äºè®°å½•æœ€ç»ˆç»“æœ

void visit(BiTNode *q) {
  if (q == p)    // å½“å‰è®¿é—®ç»“ç‚¹åˆšå¥½æ˜¯ç»“ç‚¹p
    final = pre; // æ‰¾åˆ°pçš„å‰é©±
  else
    pre = q; // preæŒ‡å‘å½“å‰è®¿é—®çš„ç»“ç‚¹
}

// ä¸­åºéå†
void InOrder(BiTree T) {
  if (T != NULL) {
    InOrder(T->lchild); // é€’å½’éå†å·¦å­æ ‘
    visit(T);           // è®¿é—®æ ¹ç»“ç‚¹
    InOrder(T->rchild); // é€’å½’éå†å³å­æ ‘
  }
}
```

## 5.3 çº¿ç´¢äºŒå‰æ ‘

### 5.3.1 çº¿ç´¢åŒ–äºŒå‰æ ‘

tag == 0 , è¡¨ç¤ºæŒ‡é’ˆæŒ‡å‘çš„æ˜¯å­©å­

tag == 1 , è¡¨ç¤ºæŒ‡é’ˆæŒ‡å‘çš„æ˜¯çº¿ç´¢  

- ä¸­åºçº¿ç´¢åŒ–
```c++
#include <iostream>

typedef struct ElemType {
  int data;
} ElemType;

// çº¿ç´¢äºŒå‰æ ‘ç»“ç‚¹
typedef struct ThreadNode {
  ElemType data;
  struct ThreadNode *lchild, *rchild;
  int ltag, rtag; // å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
} ThreadNode, *ThreadTree;

// å…¨å±€å˜é‡ pre ï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;

void visit(ThreadNode *q) {
  if (q->lchild == NULL) { // å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
    q->lchild = pre;
    q->ltag = 1;
  }
  if (pre != NULL && pre->rchild == NULL) {
    pre->rchild = q; // å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
    pre->rtag = 1;
  }
  pre = q;
}

// ä¸­åºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void InThread(ThreadTree T) {
  if (T != NULL) {
    InThread(T->lchild);
    visit(T);
    InThread(T->rchild);
  }
}

// ä¸­åºçº¿ç´¢åŒ–äºŒå‰æ ‘Tï¼Œä¸»å‡½æ•°
void CreateInThread(ThreadTree T) {
  pre = NULL;
  if (T != NULL) {
    InThread(T);
    // æœ€åæ£€æŸ¥ pre çš„ rchild æ˜¯å¦ä¸º NULL,å¦‚æœæ˜¯,åˆ™ä»¤ rtag=1
    if (pre->rchild == NULL)
      pre->rtag = 1;
  }
}
```

- å…ˆåºçº¿ç´¢åŒ–
> å…ˆåºçº¿ç´¢åŒ– **æœ‰ä¸ªå‘**ï¼Œåœ¨å¤„ç†æ ¹ç»“ç‚¹ä¹‹åï¼Œå¤„ç†å·¦å­©å­ä¹‹å‰ï¼Œéœ€è¦åˆ¤æ–­æ”¹å½“å‰éå†ç»“ç‚¹çš„ **ltag** æ ‡å¿—æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸º0ï¼Œåˆ™lchildä¸æ˜¯å‰é©±çº¿ç´¢
>> ã€ç»¼ä¸Šæ˜¯ä¸ºäº†é¿å…é™·å…¥éå†çš„ **æ­»å¾ªç¯**ã€‘

```c++
#include <iostream>

typedef struct ThreadNode {
  int data;
  struct ThreadNode *lchild, *rchild;
  int ltag, rtag; // å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
} ThreadNode, *ThreadTree;

// å…¨å±€å˜é‡ pre ï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;

void visit(ThreadNode *q) {
  if (q->lchild == NULL) { // å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
    q->lchild = pre;
    q->ltag = 1;
  }
  if (pre != NULL && pre->rchild == NULL) {
    pre->rchild = q; // å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
    pre->rtag = 1;
  }
  pre = q;
}

// å…ˆåºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void PreThread(ThreadTree T) {
  if (T != NULL) {
    visit(T); // å…ˆå¤„ç†æ ¹ç»“ç‚¹
    if (T->ltag == 0) {
      PreThread(T->lchild); // å¦‚æœlchildä¸æ˜¯å‰é©±çº¿ç´¢,ç»§ç»­éå†å·¦å­æ ‘
    }
    PreThread(T->rchild);
  }
}

// å…ˆåºçº¿ç´¢åŒ–äºŒå‰æ ‘T
void CreatePreThread(ThreadTree T) {
  pre = NULL;      // preåˆå§‹ä¸ºNULL
  if (T != NULL) { // éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
    PreThread(T);
    if (pre->rchild == NULL)
      pre->rtag = 1; // å¤„ç†éå†çš„æœ€åä¸€ä¸ªç»“ç‚¹
  }
}
```

- ååºçº¿ç´¢åŒ–
```c++
#include <iostream>

typedef struct ThreadNode {
  int data;
  struct ThreadNode *lchild, *rchild;
  int ltag, rtag; // å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
} ThreadNode, *ThreadTree;

// å…¨å±€å˜é‡preï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;

void visit(ThreadNode *q) {
  if (q->lchild == NULL) { // å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
    q->lchild = pre;
    q->ltag = 1;
  }
  if (pre != NULL && pre->rchild == NULL) {
    pre->rchild = q; // å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
    pre->rtag = 1;
  }
  pre = q;
}

// ååºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void PostThread(ThreadTree T) {
  if (T != NULL) {
    PostThread(T->lchild); // ååºéå†å·¦å­æ ‘
    PostThread(T->rchild); // ååºéå†å³å­æ ‘
    visit(T);              // è®¿é—®æ ¹ç»“ç‚¹
  }
}

// ååºçº¿ç´¢åŒ–äºŒå‰æ ‘T
void CreatePostThread(ThreadTree T) {
  pre = NULL;      // preåˆå§‹åŒ–ä¸ºNULL
  if (T != NULL) { // éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
    PostThread(T); // åç»­çº¿ç´¢åŒ–äºŒå‰æ ‘
    if (pre->lchild == NULL) {
      pre->rtag = 1; // å¤„ç†éå†çš„æœ€åä¸€ä¸ªç»“ç‚¹
    }
  }
}
```

### 5.3.2 <font color='red'>çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±(åç»§)â€”â€”æ²¡æ•´ç†å®Œæ•´</font>

> ä¸­åºçº¿ç´¢äºŒå‰æ ‘

- ä¸­åºçº¿ç´¢äºŒå‰æ ‘æ‰¾ä¸­åºåç»§
```c++
// æ‰¾åˆ°ä»¥Pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œç¬¬ä¸€ä¸ªè¢«ä¸­åºéå†çš„ç»“ç‚¹
ThreadNode *FirstNode(ThreadNode *p) {
  while (p->ltag == 0) // å¾ªç¯å¯»æ‰¾æœ€å·¦ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
    p = p->lchild;
  return p;
}

// åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„åç»§ç»“ç‚¹
ThreadNode *NextNode(ThreadNode *p) {
  if (p->rtag == 0) // å³å­æ ‘çš„æœ€å·¦ğŸ‘ˆä¸‹ç»“ç‚¹
    return FirstNode(p->rchild);
  else // rtag==1ï¼Œç›´æ¥è¿”å›åç»§çº¿ç´¢
    return p->rchild;
}

// å¯¹ä¸­åºçº¿ç´¢äºŒå‰æ ‘è¿›è¡Œä¸­åºéå†ï¼ˆåˆ©ç”¨çº¿ç´¢å®ç°çš„éé€’å½’ç®—æ³•ï¼‰
void InOrder(ThreadNode *T) {
  for (ThreadNode *p = FirstNode(T); p != NULL; p = NextNode(p))
    visit(p);
}
```

- ä¸­åºçº¿ç´¢äºŒå‰æ ‘æ‰¾ä¸­åºå‰é©±
```c++
// æ‰¾åˆ°ä»¥pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œæœ€åä¸€ä¸ªè¢«ä¸­åºéå†çš„ç»“ç‚¹
ThreadNode *LastNode(ThreadNode *p) {
  while (p->rtag == 0) // å¾ªç¯å¯»æ‰¾æœ€å³ğŸ‘‰ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
    p = p->rchild;
  return p;
}

// åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„å‰é©±ç»“ç‚¹
ThreadNode *PreNode(ThreadNode *p) {
  if (p->ltag == 0) // å·¦å­æ ‘çš„æœ€å³ä¸‹ç»“ç‚¹
    return LastNode(p->lchild);
  else // rtag==1ï¼Œç›´æ¥è¿”å›å‰é©±çº¿ç´¢
    return p->lchild;
}

// å¯¹ä¸­åºçº¿ç´¢äºŒå‰æ ‘è¿›è¡Œé€†å‘ä¸­åºéå†ï¼ˆåˆ©ç”¨çº¿ç´¢å®ç°çš„éé€’å½’ç®—æ³•ï¼‰
void RevInOrder(ThreadNode *T) {
  for (ThreadNode *p = LastNode(T); p != NULL; p = PreNode(p))
    visit(p);
}
```

---

> å…ˆåºçº¿ç´¢äºŒå‰æ ‘

- å…ˆåºçº¿ç´¢äºŒå‰æ ‘æ‰¾å…ˆåºå‰é©±
- å…ˆåºçº¿ç´¢äºŒå‰æ ‘æ‰¾å…ˆåºåç»§

---

> ååºçº¿ç´¢äºŒå‰æ ‘

- ååºçº¿ç´¢äºŒå‰æ ‘æ‰¾ååºå‰é©±
- ååºçº¿ç´¢äºŒå‰æ ‘ç€ååºåç»§

## 5.4 æ ‘ã€æ£®æ—

### 5.4.1 æ ‘çš„å­˜å‚¨ç»“æ„

- åŒäº²è¡¨ç¤ºæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰:æ¯ä¸ªç»“ç‚¹ä¸­ä¿å­˜æŒ‡å‘åŒäº²çš„â€œæŒ‡é’ˆâ€
```c++
#define MAX_TREE_SIZE 100           //æ ‘ä¸­æœ€å¤šç»“ç‚¹æ ‘

typedef struct{                     //æ ‘çš„ç»“ç‚¹å®šä¹‰
    ElemType data;                  //æ•°æ®å…ƒç´ 
    int parent;                     //åŒäº²ä½ç½®åŸŸ
}PTNode;

typedef struct{                     //æ ‘çš„ç»“æ„ç±»å‹
    PTNode nodes[MAX_TREE_SIZE];    //åŒäº²è¡¨ç¤º
    int n;                          //ç»“ç‚¹æ•°
}PTree;
```

- å­©å­è¡¨ç¤ºæ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰
```c++
struct CTNode{
    int child;                  //å­©å­ç»“ç‚¹åœ¨æ•°ç»„ä¸­çš„ä½ç½®
    struct CTNode *next;        //ä¸‹ä¸€ä¸ªå­©å­
};

typedef struct{
    ElemType data;
    struct CTNode *firstChild;  //ç¬¬ä¸€ä¸ªå­©å­
}CTBox;

typedef struct{
    CTBox nodes[MAX_TREE_SIZE];
    int n,r;
}CTree;
```

- å­©å­å…„å¼Ÿè¡¨ç¤ºæ³•ï¼ˆé“¾å¼å­˜å‚¨ï¼‰:æ ‘å’ŒäºŒå‰æ ‘çš„è½¬åŒ–
```c++
typedef struct CSNode{
    ElemType data;                          //æ•°æ®åŸŸ
    struct CSNode *firstChild,*nextSibling; //ç¬¬ä¸€ä¸ªå­©å­å’Œå³å…„å¼ŸæŒ‡é’ˆ
}CSNode,*CSTree;
```

### 5.4.2 æ ‘ã€æ£®æ—ä¸äºŒå‰æ ‘çš„è½¬æ¢
1. æ ‘ ä¸ äºŒå‰æ ‘ 
2. æ£®æ— -> äºŒå‰æ ‘  
3. äºŒå‰æ ‘ -> æ£®æ—

### 5.4.3 æ ‘å’Œæ£®æ—çš„éå†
| æ ‘                   | æ£®æ—                             | äºŒå‰æ ‘   |
| -------------------- | -------------------------------- | -------- |
| å…ˆæ ¹éå†ï¼ˆæ·±åº¦ä¼˜å…ˆï¼‰ | å…ˆåºéå†ï¼ˆä¾æ¬¡å¯¹æ¯æ£µæ ‘å…ˆæ ¹éå†ï¼‰ | å…ˆåºéå† |
| åæ ¹éå†ï¼ˆæ·±åº¦ä¼˜å…ˆï¼‰ | ä¸­åºéå†ï¼ˆä¾æ¬¡å¯¹æ¯æ£µæ ‘åæ ¹éå†ï¼‰ | ä¸­åºéå† |
| å±‚åºéå†ï¼ˆå¹¿åº¦ä¼˜å…ˆï¼‰ | æ—                                | æ—        |

## 5.5 æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨

### 5.5.1 å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç 

å¦‚ä½•æ„é€ å“ˆå¤«æ›¼æ ‘:æ¯æ¬¡é€‰ä¸¤ä¸ªæ ¹ç»“ç‚¹æƒå€¼æœ€å°çš„æ ‘åˆå¹¶ï¼Œå¹¶å°†äºŒè€…æƒå€¼ä¹‹å’Œä½œä¸ºæ–°çš„æ ¹ç»“ç‚¹çš„æƒå€¼

ç¼–ç ï¼šå›ºå®šé•¿åº¦ï¼Œå¯å˜é•¿åº¦ï¼Œå‰ç¼€

### 5.5.2 å¹¶æŸ¥é›†

å¹¶æŸ¥é›†ï¼ˆDisjoint Setï¼‰æ˜¯é€»è¾‘ç»“æ„â€”â€”é›†åˆçš„ä¸€ç§å…·ä½“å®ç°ï¼Œåªè¿›è¡Œ â€œå¹¶â€å’Œâ€œæŸ¥â€ä¸¤ç§åŸºæœ¬æ“ä½œ  

ä»¥ä¸‹æ“ä½œ :

â€œæŸ¥â€çš„æœ€åæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ 

â€œå¹¶â€çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(1)$  

```c++
#define SIZE 13
int UFSets[SIZE]; // é›†åˆå…ƒç´ æ•°ç»„

// åˆå§‹åŒ–å¹¶æŸ¥é›†
void Initial(int S[]) {
  for (int i = 0; i < SIZE; i++)
    S[i] = -1;
}

// Find "æŸ¥"æ“ä½œï¼Œæ‰¾xæ‰€å±é›†åˆï¼ˆè¿”å›xæ‰€å±æ ¹ç»“ç‚¹ï¼‰
int Find(int S[], int x) {
  while (S[x] >= 0) // å¾ªç¯å¯»æ‰¾xçš„æ ¹
    x = S[x];
  return x; // è¿”å›çš„æ ¹çš„S[]å°äº0
}

// Union "å¹¶"æ“ä½œ,å°†ä¸¤ä¸ªé›†åˆåˆå¹¶ä¸ºä¸€ä¸ª
void Union(int S[], int Root1, int Root2) {
  // è¦æ±‚Root1ä¸Root2æ˜¯ä¸åŒçš„é›†åˆ
  if (Root1 == Root2)
    return;
  // å°†æ ¹Root2è¿æ¥åˆ°å¦ä¸€æ ¹Root1ä¸‹é¢
  S[Root2] = Root1;
}
```

ä¼˜åŒ–æ“ä½œ  
â‘ ç”¨æ ¹èŠ‚ç‚¹çš„ç»å¯¹å€¼è¡¨ç¤ºæ ‘çš„ç»“ç‚¹æ€»æ•°  
â‘¡Unionæ“ä½œï¼Œè®©å°æ ‘åˆå¹¶åˆ°å¤§æ ‘ï¼Œä¿æŒæ ‘çš„é«˜åº¦  

è¯¥æ–¹æ³•æ„é€ çš„æ ‘é«˜ä¸è¶…è¿‡ $\lfloor \log_{2}{n} \rfloor+1$  
Unionæ“ä½œä¼˜åŒ–å,Findæ“ä½œæœ€åæ—¶é—´å¤æ‚åº¦: $\log_{2}{n}$  

```c++
// è¿›è¡Œå¹¶æ“ä½œï¼Œå°†å°æ ‘åˆå¹¶åˆ°å¤§æ ‘
void Union(int S[], int Root1, int Root2) {
  if (Root1 == Root2)
    return;
  // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹
  if (S[Root1] < S[Root2]) { // Root1çš„ç»“ç‚¹æ•°é‡æ›´å¤š
    S[Root1] += S[Root2];
    S[Root2] = Root1;
  } else { // Root2çš„ç»“ç‚¹æ•°é‡æ›´å¤š
    S[Root2] += S[Root1];
    S[Root1] = Root2;
  }
}
```

å‹ç¼©è·¯å¾„â€”â€”Find æ“ä½œï¼Œå…ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œ å†å°†æŸ¥æ‰¾è·¯å¾„ä¸Šæ‰€æœ‰ç»“ç‚¹éƒ½æŒ‚åˆ°æ ¹ç»“ç‚¹ä¸‹
```c++
// ä¼˜åŒ–â€œæŸ¥â€æ“ä½œ,å…ˆæ‰¾åˆ°æ ¹ç»“ç‚¹,å†é€’å½’å‹ç¼©è·¯å¾„
int Find_good(int S[], int x) {
  int root = x;
  while (S[root] > 0)
    root = S[root];   // å¾ªç¯æ‰¾åˆ°æ ¹ç»“ç‚¹
  while (x != root) { // å‹ç¼©è·¯å¾„
    int tmp = S[x];   // tmpæŒ‡å‘xçš„çˆ¶ç»“ç‚¹
    S[x] = root;      // å°†xçš„çˆ¶ç»“ç‚¹è®¾ä¸ºæ ¹ç»“ç‚¹
    x = tmp;          // ç»§ç»­å¾ªç¯
  }
  return root;
}
```

# ç¬¬å…­ç« â€”â€”å›¾

## 6.1 å›¾çš„åŸºæœ¬æ¦‚å¿µ 

> **ç®€å•è·¯å¾„**ã€**ç®€å•å›è·¯**
>> åœ¨è·¯å¾„åºåˆ—ä¸­ï¼Œé¡¶ç‚¹ä¸é‡å¤å‡ºç°çš„è·¯å¾„ç§°ä¸ºç®€å•è·¯å¾„ã€‚é™¤ç¬¬ä¸€ä¸ªé¡¶ç‚¹å’Œæœ€åä¸€ä¸ªé¡¶ç‚¹å¤–ï¼Œå…¶ä½™é¡¶ç‚¹ä¸é‡å¤å‡ºç°çš„å›è·¯ç§°ä¸ºç®€å•å›è·¯ã€‚

## 6.2 å›¾çš„å­˜å‚¨åŠåŸºæœ¬æ“ä½œ

### 6.2.1 é‚»æ¥çŸ©é˜µæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰

> å¯¹äº **ä¸å¸¦æƒ** çš„æ— å‘å›¾ã€æœ‰å‘å›¾
```c++
#define MaxVertexNum 100                    //é¡¶ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
typedef struct{
    char Vex[MaxVertexNum];                 //é¡¶ç‚¹è¡¨
    int Edge[MaxVertexNum][MaxVertexNum];   //é‚»æ¥çŸ©é˜µï¼Œè¾¹è¡¨
    int vexnum,arcnum;                      //å›¾çš„å½“å‰é¡¶ç‚¹æ•°å’Œè¾¹æ•°/å¼§æ•°
}MGraph;
```
- æ€§è´¨

$è®¾å›¾Gçš„é‚»æ¥çŸ©é˜µä¸ºAï¼ˆçŸ©é˜µå…ƒç´ ä¸º 0/1ï¼‰ï¼Œåˆ™  A^n çš„å…ƒç´  A^n[i][j] \\ ç­‰äº ç”±é¡¶ç‚¹ i åˆ°é¡¶ç‚¹ j çš„é•¿åº¦ä¸º n çš„è·¯å¾„çš„æ•°ç›®$

> å¯¹äºå¸¦æƒå›¾ï¼ˆç½‘ï¼‰
```c++
#define MaxVertexNum 100                        //é¡¶ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
#define INFINITY æœ€å¤§çš„intå€¼                     //å®å®šä¹‰ å¸¸é‡ â€œæ— ç©·â€
typedef char VertexType;                        //é¡¶ç‚¹çš„æ•°æ®ç±»å‹
typedef int EdgeType;                           //å¸¦æƒå›¾ä¸­è¾¹ä¸Šæƒå€¼çš„æ•°æ®ç±»å‹
typedef struct{
    VertexType Vex[MaxVertexNum];               //é¡¶ç‚¹è¡¨
    EdgeType Edge[MaxVertexNum][MaxVertexNum];  //é‚»æ¥çŸ©é˜µï¼Œè¾¹çš„æƒå€¼è¡¨
    int vexnum,arcnum;                          //å›¾çš„å½“å‰é¡¶ç‚¹æ•°å’Œè¾¹æ•°/å¼§æ•°
}MGraph;
```

### 6.2.2 é‚»æ¥è¡¨æ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰
```c++
#define MaxVertexNum 100

//ç”¨é‚»æ¥è¡¨å­˜å‚¨çš„å›¾
typedef struct{
    AdjList vertices;
    int vexnum,arcnum;
}ALGraph;

//é¡¶ç‚¹
typedef struct VNode{
    VertexType data;        //é¡¶ç‚¹ä¿¡æ¯
    ArcNode *first;         //ç¬¬ä¸€æ¡è¾¹/å¼§
}VNode,AdjList[MaxVertexNum];

//â€œè¾¹/å¼§â€
typedef struct ArcNode{
    int adjvex;             //è¾¹/å¼§æŒ‡å‘å“ªä¸ªç»“ç‚¹
    struct ArcNode *next;   //æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
    //InfoType info;        //è¾¹æƒå€¼
}ArcNode;
```

## 6.3 å›¾çš„éå†
### 6.3.1 BFS å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•
```c++
#include <iostream>

#define MaxVertexNum 100    // ç»“ç‚¹çš„æœ€å¤§ä¸ªæ•°
bool visited[MaxVertexNum]; // è®¿é—®æ ‡è®°æ•°ç»„

// å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•
void BFS(Graph G, int v) { // ä»é¡¶ç‚¹vå‡ºå‘ï¼Œå¹¿åº¦ä¼˜å…ˆéå†å›¾G
  visit(v);                // è®¿é—®åˆå§‹é¡¶ç‚¹v
  visited[v] = true;       // å¯¹é¡¶ç‚¹ v åšå·²è®¿é—®æ ‡è®°
  Enqueue(Q, v);           // é¡¶ç‚¹vå…¥é˜Ÿåˆ—Q
  while (!isEmpty(Q)) {
    Dequeue(v); // é¡¶ç‚¹vå‡ºé˜Ÿåˆ—Q
    for (int w = FirstNeighbor(G, v); w >= 0;
         w = NextNeighbor(G, v, w)) { // æ£€æµ‹vçš„æ‰€æœ‰é‚»æ¥ç‚¹
      if (!visited[w]) {              // wä¸ºvçš„æœªè®¿é—®çš„é‚»æ¥é¡¶ç‚¹
        visit(w);                     // è®¿é—®w
        visited[w] = true;            // å¯¹wåš å·²è®¿é—®æ ‡è®°
        Enqueue(Q, w);                // é¡¶ç‚¹wå…¥é˜Ÿåˆ—
      }
    }
  }
}

void BFSTraverse(Graph G) { // å¯¹å›¾Gè¿›è¡Œå¹¿åº¦ä¼˜å…ˆéå†
  for (int i = 0; i < G.vexnum; i++) {
    visited[i] = false; // è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
  }
  InitQueue(Q);                        // åˆå§‹åŒ–è¾…åŠ©é˜Ÿåˆ—Q
  for (int i = 0; i < G.vexnum; i++) { // ä»0å·é¡¶ç‚¹å¼€å§‹éå†
    if (!visited[i]) { // å¯¹æ¯ä¸ªè¿é€šåˆ†é‡è°ƒç”¨ä¸€æ¬¡BFSç®—æ³•
      BFS(G, i);       // è‹¥ç¬¬iä¸ªé¡¶ç‚¹æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ‰§è¡ŒBFS
    }
  }
}

```

æ—¶é—´å¤æ‚åº¦ï¼š
1. é‚»æ¥çŸ©é˜µå­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ¯ä¸ªé¡¶ç‚¹çš„é‚»æ¥ç‚¹éƒ½éœ€è¦ $O(|V|)$ çš„æ—¶é—´ï¼Œæ€»å…±æœ‰ $|V|$ ä¸ªé¡¶ç‚¹
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|^2)$
2. é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ‰€æœ‰é¡¶ç‚¹çš„é‚»æ¥ç‚¹æ€»å…±éœ€è¦ $O(|E|)$ çš„æ—¶é—´
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|+|E|)$

### 6.3.2 DFS æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•
```c++
#define MaxVertexNum 100    // ç»“ç‚¹çš„æœ€å¤§ä¸ªæ•°
bool visited[MaxVertexNum]; // è®¿é—®æ ‡è®°æ•°ç»„

// æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•
void DFS(Graph G, int v) { // ä»é¡¶ç‚¹vå‡ºå‘ï¼Œæ·±åº¦ä¼˜å…ˆéå†å›¾G
  visit(v);                // è®¿é—®åˆå§‹é¡¶ç‚¹v
  visited[v] = true;       // å¯¹é¡¶ç‚¹ v åšå·²è®¿é—®æ ‡è®°
  for (int w = FirstNeighbor(G, v); w >= 0;
       w = NextNeighbor(G, v, w)) { // æ£€æµ‹vçš„æ‰€æœ‰é‚»æ¥ç‚¹
    if (!visited[w]) {              // wä¸ºvçš„æœªè®¿é—®çš„é‚»æ¥é¡¶ç‚¹
      DFS(G, w);
    }
  }
}

void DFSTraverse(Graph G) { // å¯¹å›¾Gè¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†
  for (int i = 0; i < G.vexnum; i++) {
    visited[i] = false; // è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
  }
  for (int i = 0; i < G.vexnum; i++) { // ä»0å·é¡¶ç‚¹å¼€å§‹éå†
    if (!visited[i]) { // å¯¹æ¯ä¸ªè¿é€šåˆ†é‡è°ƒç”¨ä¸€æ¬¡DFSç®—æ³•
      DFS(G, i);       // è‹¥ç¬¬iä¸ªé¡¶ç‚¹æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ‰§è¡ŒDFS
    }
  }
}
```

æ—¶é—´å¤æ‚åº¦ï¼š
1. é‚»æ¥çŸ©é˜µå­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ¯ä¸ªé¡¶ç‚¹çš„é‚»æ¥ç‚¹éƒ½éœ€è¦ $O(|V|)$ çš„æ—¶é—´ï¼Œæ€»å…±æœ‰ $|V|$ ä¸ªé¡¶ç‚¹
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|^2)$
2. é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ‰€æœ‰é¡¶ç‚¹çš„é‚»æ¥ç‚¹æ€»å…±éœ€è¦ $O(|E|)$ çš„æ—¶é—´
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|+|E|)$

## 6.4 åº”ç”¨
### 6.4.1 æœ€å°ç”Ÿæˆæ ‘
1. Primç®—æ³•
   ä»æŸä¸€ä¸ªé¡¶ç‚¹å¼€å§‹æ„å»ºç”Ÿæˆæ ‘
   æ¯æ¬¡å°†ä»£ä»·æœ€å°çš„æ–°é¡¶ç‚¹çº³å…¥ç”Ÿæˆæ ‘ï¼Œç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½çº³å…¥ä¸ºæ­¢
   æ—¶é—´å¤æ‚åº¦ $O(|V|^2)$
   é€‚åˆç”¨äºè¾¹ç¨ å¯†å›¾
---
2. Kruskalç®—æ³•
   æ¯æ¬¡é€‰æ‹©ä¸€æ¡æƒå€¼æœ€å°çš„è¾¹ï¼Œä½¿è¿™æ¡è¾¹çš„ä¸¤å¤´è¿é€šï¼ˆåŸæœ¬å·²ç»è¿é€šçš„å°±ä¸é€‰ï¼‰
   ç›´åˆ°æ‰€æœ‰ç»“ç‚¹éƒ½è¿é€š
   æ—¶é—´å¤æ‚åº¦ $O(|E|\log_{2}{|E|})$
   é€‚åˆç”¨äºè¾¹ç¨€ç–å›¾

### 6.4.2 æœ€çŸ­è·¯å¾„

> å•æºæœ€çŸ­è·¯å¾„
1. BFS æ±‚å•æºæœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰
```c++
// æ±‚é¡¶ç‚¹ U åˆ°å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„
void BFS_MIN_Distance(Graph G, int u) {
  // d[i] è¡¨ç¤ºä» u åˆ° i ç»“ç‚¹çš„æœ€çŸ­è·¯å¾„
  for (int i = 0; i < G.vexnum; i++) {
    d[i] = âˆ;     // åˆå§‹åŒ–è·¯å¾„é•¿åº¦
    path[i] = -1; // æœ€çŸ­è·¯å¾„ä»å“ªä¸ªé¡¶ç‚¹è¿‡æ¥
  }
  d[u] = 0;
  visited[u] = true;
  EnQueue(Q, u);
  while (!isEmpty(Q)) { // BFSä¸»è¿‡ç¨‹
    DeQueue(Q, u);      // é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿ
    for (w = FirstNeighbor(G, u); w >= 0; w = NextNeighbor(G, u)) {
      if (!visited[w]) {   // w ä¸º u å°šæœªè®¿é—®çš„é‚»æ¥ç»“ç‚¹
        d[w] = d[u] + 1;   // è·¯å¾„é•¿åº¦+1
        path[w] = u;       // æœ€çŸ­è·¯å¾„åº”å½“ä» u åˆ° w
        visited[w] = true; // è®¾ç½®å·²è®¿é—®æ ‡è®°
        EnQueue(Q, w);     // é¡¶ç‚¹ w å…¥é˜Ÿ
      }
    }
  }
}
```

2. Dijkstraç®—æ³• ï¼ˆè¿ªæ°æ–¯ç‰¹æ‹‰â€”â€”å¸¦æƒå›¾ã€æ— æƒå›¾ï¼‰

**ä¸é€‚åˆå¸¦è´Ÿæƒå€¼çš„å›¾**

final[] ï¼šåˆå§‹åŒ–ä¸ºfalseï¼Œå¾ªç¯éå†æ‰€æœ‰ç»“ç‚¹ï¼Œæ‰¾åˆ°è¿˜æ²¡ç¡®å®šæœ€çŸ­è·¯å¾„ï¼Œä¸” dist æœ€å°çš„é¡¶ç‚¹ $V_i$ ,ä½¿å¾— final[i]=true
dist[] ï¼šè®°å½•äº†ä»æºç‚¹ $V_0$ åˆ°å…¶ä»–å„é¡¶ç‚¹å½“å‰çš„æœ€çŸ­è·¯å¾„é•¿åº¦
path[] ï¼špath[i]è¡¨ç¤ºä»æºç‚¹åˆ°é¡¶ç‚¹iä¹‹é—´çš„æœ€çŸ­è·¯å¾„çš„å‰é©±ç»“ç‚¹ï¼Œåˆå§‹åŒ–ä¸º -1


> å„ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·ç¦»

Floydç®—æ³• 

åˆå§‹åŒ–çŸ©é˜µ
![](pictures/Floyd-V0.png)
![](pictures/Floyd-V1.png)

$$
\begin{aligned}
& è‹¥ A^{(k-1)}[i][j] > A^{(k-1)}[i][k] + A^{(k-1)}[k][j] \\
& åˆ™ A^{(k)}[i][j] = A^{(k-1)}[i][k] + A^{(k-1)}[k][j]  \\
& path^{(k)}[i][j]=k  \\
& å¦åˆ™ A^{(k)} å’Œ path^{(k)} ä¿æŒåŸå€¼
\end{aligned}
$$

```c++
// å‡†å¤‡å·¥ä½œï¼Œæ ¹æ®å›¾çš„ä¿¡æ¯åˆå§‹åŒ–çŸ©é˜µ A å’Œ pathï¼ˆå¦‚ä¸Šå›¾ï¼‰
for(int k=0;k<n;k++){                   //è€ƒè™‘ä»¥ Vk ä½œä¸ºä¸­è½¬ç‚¹
    for(int i=0;i<n;i++){               //éå†æ•´ä¸ªçŸ©é˜µï¼Œiä¸ºè¡Œå·ï¼Œjä¸ºåˆ—å·
        for(int j=0;j<n;j++){
            if(A[i][j]>A[i][k]+A[k][j]){//ä»¥ Vk ä¸ºä¸­è½¬ç‚¹çš„è·¯å¾„æ›´çŸ­
                A[i][j]=A[i][k]+A[k][j];//æ›´æ–°æœ€çŸ­è·¯å¾„é•¿åº¦
                path[i][j]=k;           //ä¸­è½¬ç‚¹
            }
        }
    }
}
```

$ æ—¶é—´å¤æ‚åº¦ O(|V|^3) $  
$ ç©ºé—´å¤æ‚åº¦ O(|V|^2) $

### 6.4.3 æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰æè¿°è¡¨è¾¾å¼
**é¡¶ç‚¹ä¸­ä¸å¯èƒ½å‡ºç°é‡å¤çš„æ“ä½œæ•°**

![](pictures/DAGè¡¨è¾¾å¼.png)

Step 1ï¼šæŠŠå„ä¸ªæ“ä½œæ•°ä¸é‡å¤åœ°æ’æˆä¸€æ’  
Step 2ï¼šæ ‡å‡ºå„ä¸ªè¿ç®—ç¬¦çš„ç”Ÿæ•ˆé¡ºåºï¼ˆå…ˆåé¡ºåºæœ‰ç‚¹å‡ºå…¥æ— æ‰€è°“ï¼‰  
Step 3ï¼šæŒ‰é¡ºåºåŠ å…¥è¿ç®—ç¬¦ï¼Œæ³¨æ„â€œåˆ†å±‚â€  
Step 4ï¼šä»åº•å‘ä¸Šé€å±‚æ£€ç« åŒå±‚çš„è¿ç®—ç¬¦æ˜¯å¦å¯ä»¥åˆä½“  

### 6.4.4 æ‹“æ‰‘æ’åº(é€†æ‹“æ‰‘æ’åº)

AOVç½‘ï¼šç”¨DAGå›¾è¡¨ç¤ºä¸€ä¸ªå·¥ç¨‹ï¼Œå…¶é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨ï¼Œç”¨æœ‰å‘è¾¹ $ < V_i,V_j > $ è¡¨ç¤ºæ´»åŠ¨ $V_i$ å¿…é¡»å…ˆäºæ´»åŠ¨ $V_j$ çš„è¿™æ ·ä¸€ç§å…³ç³»ï¼Œåˆ™å°†è¿™ç§æœ‰å‘å›¾ç§°ä¸ºé¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨çš„ç½‘ç»œï¼Œè®°ä¸ºAOVç½‘ã€‚

---

æ‹“æ‰‘æ’åºç®—æ³•ï¼š
1. ä»AOVç½‘ä¸­é€‰æ‹©ä¸€ä¸ªå…¥åº¦ä¸º0çš„é¡¶ç‚¹è¾“å‡º
2. åˆ å»æ­¤é¡¶ç‚¹ï¼Œå¹¶åˆ é™¤ä»¥æ­¤é¡¶ç‚¹ä¸ºå¼§å°¾çš„å¼§
3. é‡å¤æ­¥éª¤ç›´åˆ°è¾“å‡ºå›¾ä¸­å…¨éƒ¨é¡¶ç‚¹ï¼Œæˆ–è€…æ‰¾ä¸åˆ°å…¥åº¦ä¸º0çš„é¡¶ç‚¹ä¸ºæ­¢ã€åè€…è¡¨ç¤ºè¯¥å›¾ä¸æ˜¯DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ã€‘

```c++
#include <iostream>
#include <stack>
#define MaxVertexNum 100 // å›¾ä¸­é¡¶ç‚¹çš„æœ€å¤§æ•°ç›®

struct VertexType {
  int data;
};

typedef struct ArcNode {   // è¾¹è¡¨ç»“ç‚¹
  int adjvex;              // è¯¥å¼§æ‰€æŒ‡å‘çš„é¡¶ç‚¹çš„ä½ç½®
  struct ArcNode *nextArc; // æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
  // InfoType info;       //ç½‘çš„è¾¹æƒå€¼
} ArcNode;

typedef struct VNode { // é¡¶ç‚¹è¡¨ç»“ç‚¹
  VertexType data;     // é¡¶ç‚¹ä¿¡æ¯
  ArcNode *firstArc;   // æŒ‡å‘ç¬¬ä¸€æ¡ä¾é™„äºè¯¥é¡¶ç‚¹çš„å¼§çš„æŒ‡é’ˆ
} VNode, AdjList[MaxVertexNum];

typedef struct {
  AdjList vertices;   // é‚»æ¥è¡¨
  int vexnum, arcnum; // å›¾çš„é¡¶ç‚¹æ•°å’Œå¼§æ•°
} Graph;              // Graph æ˜¯ä»¥é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ç±»å‹

std::stack<int> S; // ç”¨æ ˆæ¥å®ç°æ‹“æ‰‘æ’åº

int indegree[MaxVertexNum]; // è®°å½•æ¯ä¸ªé¡¶ç‚¹çš„å…¥åº¦

int print[MaxVertexNum]; // è®°å½•æ‹“æ‰‘åºåˆ—

bool TopologicalSort(Graph G) {
  for (int i = 0; i < G.vexnum; i++) {
    if (indegree[i] == 0) // degreeæ•°ç»„è®°å½•å½“å‰é¡¶ç‚¹çš„å…¥åº¦
      S.push(i);          // å°†æ‰€æœ‰å…¥åº¦ä¸º0çš„é¡¶ç‚¹å…¥æ ˆ
  }
  int count = 0; // è®¡æ•°ï¼Œè®°å½•å½“å‰å·²ç»è¾“å‡ºçš„é¡¶ç‚¹æ•°
  while (!S.empty()) {
    int i = S.top(); // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
    S.pop();
    print[count++] = i; // printæ•°ç»„è®°å½•æ‹“æ‰‘åºåˆ—ï¼Œè¾“å‡ºé¡¶ç‚¹i
    for (
        ArcNode *p = G.vertices[i].firstArc; p;
        p = p->nextArc) { // å°†æ‰€æœ‰iæŒ‡å‘çš„é¡¶ç‚¹çš„å…¥åº¦å‡1ï¼Œå¹¶ä¸”å°†å…¥åº¦ä¸º0çš„é¡¶ç‚¹å‹å…¥æ ˆS
      int v = p->adjvex;
      if (!(--indegree[v]))
        S.push(v); // å…¥åº¦ä¸º0ï¼Œåˆ™å…¥æ ˆ
    }
  }

  if (count < G.vexnum)
    return false; // æ’åºå¤±è´¥ï¼Œæœ‰å‘å›¾ä¸­æœ‰å›è·¯
  else
    return true; // æ‹“æ‰‘æ’åºæˆåŠŸ
}
```

---

é€†æ‹“æ‰‘æ’åºç®—æ³•ï¼š
1. ä»AOVç½‘ä¸­é€‰æ‹©ä¸€ä¸ªå‡ºåº¦ä¸º0çš„é¡¶ç‚¹è¾“å‡º
2. åˆ å»æ­¤é¡¶ç‚¹ï¼Œå¹¶åˆ é™¤ä»¥æ­¤é¡¶ç‚¹ä¸ºå¼§å¤´çš„å¼§
3. é‡å¤æ­¥éª¤ç›´åˆ°è¾“å‡ºå›¾ä¸­å…¨éƒ¨é¡¶ç‚¹ï¼Œæˆ–è€…æ‰¾ä¸åˆ°å‡ºåº¦ä¸º0çš„é¡¶ç‚¹ä¸ºæ­¢ã€åè€…è¡¨ç¤ºè¯¥å›¾ä¸æ˜¯DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ã€‘

- å®ç°é€†æ‹“æ‰‘æ’åºç®—æ³•ï¼šï¼ˆä¸¤ä¸ªï¼‰

  1. é€†é‚»æ¥è¡¨

  2. DFSç®—æ³•
```c++
#define MaxVertexNum 100    // ç»“ç‚¹çš„æœ€å¤§ä¸ªæ•°
bool visited[MaxVertexNum]; // è®¿é—®æ ‡è®°æ•°ç»„

void DFSTraverse(Graph G) { // å¯¹å›¾Gè¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†
  for (int i = 0; i < G.vexnum; i++) {
    visited[i] = false; // è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
  }
  for (int i = 0; i < G.vexnum; i++) { // ä»0å·é¡¶ç‚¹å¼€å§‹éå†
    if (!visited[i]) { // å¯¹æ¯ä¸ªè¿é€šåˆ†é‡è°ƒç”¨ä¸€æ¬¡DFSç®—æ³•
      DFS(G, i);       // è‹¥ç¬¬iä¸ªé¡¶ç‚¹æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ‰§è¡ŒDFS
    }
  }
}

// æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•
void DFS(Graph G, int v) { // ä»é¡¶ç‚¹vå‡ºå‘ï¼Œæ·±åº¦ä¼˜å…ˆéå†å›¾G
  visit(v);                // è®¿é—®åˆå§‹é¡¶ç‚¹v
  visited[v] = true;       // å¯¹é¡¶ç‚¹ v åšå·²è®¿é—®æ ‡è®°
  for (int w = FirstNeighbor(G, v); w >= 0;
       w = NextNeighbor(G, v, w)) { // æ£€æµ‹vçš„æ‰€æœ‰é‚»æ¥ç‚¹
    if (!visited[w]) {              // wä¸ºvçš„æœªè®¿é—®çš„é‚»æ¥é¡¶ç‚¹
      DFS(G, w);
    }
  }
  print(v); // è¾“å‡ºé¡¶ç‚¹
}
```

### 6.4.5 å…³é”®è·¯å¾„
AOEç½‘ï¼šåœ¨å¸¦æƒæœ‰å‘å›¾ä¸­ï¼Œä»¥é¡¶ç‚¹ä»£è¡¨äº‹ä»¶ï¼Œä»¥æœ‰å‘è¾¹è¡¨ç¤ºæ´»åŠ¨ï¼Œä»¥è¾¹ä¸Šçš„æƒå€¼è¡¨ç¤ºå®Œæˆè¯¥æ´»åŠ¨çš„å¼€é”€ï¼ˆæ—¶é—´ï¼‰ï¼Œç§°ä¹‹ä¸ºç”¨è¾¹è¡¨ç¤ºæ´»åŠ¨çš„ç½‘ç»œã€‚

ä»…æœ‰ä¸€ä¸ªå…¥åº¦ä¸º0çš„é¡¶ç‚¹ï¼Œç§°ä¸ºå¼€å§‹é¡¶ç‚¹ï¼ˆæºç‚¹ï¼‰ï¼Œå®ƒè¡¨ç¤ºæ•´ä¸ªå·¥ç¨‹çš„å¼€å§‹ï¼›

ä»…æœ‰ä¸€ä¸ªå‡ºåº¦ä¸º0çš„é¡¶ç‚¹ï¼Œç§°ä¸ºç»“æŸé¡¶ç‚¹ï¼ˆæ±‡ç‚¹ï¼‰ï¼Œå®ƒè¡¨ç¤ºæ•´ä¸ªå·¥ç¨‹çš„ç»“æŸã€‚

ä»æºç‚¹åˆ°æ±‡ç‚¹çš„æœ‰å‘è·¯å¾„å¯èƒ½æœ‰å¤šæ¡ï¼Œæ‰€æœ‰è·¯å¾„ä¸­ï¼Œå…·æœ‰æœ€å¤§è·¯å¾„é•¿åº¦çš„è·¯å¾„ç§°ä¸ºå…³é”®è·¯å¾„ï¼Œè€ŒæŠŠå…³é”®è·¯å¾„ä¸Šçš„æ´»åŠ¨ç§°ä¸ºå…³é”®æ´»åŠ¨

- è‹¥å…³é”®æ´»åŠ¨è€—æ—¶å¢åŠ ï¼Œåˆ™æ•´ä¸ªå·¥ç¨‹çš„å·¥æœŸå°†å¢é•¿
- ç¼©çŸ­å…³é”®æ´»åŠ¨çš„æ—¶é—´ï¼Œå¯ä»¥ç¼©çŸ­æ•´ä¸ªå·¥ç¨‹çš„å·¥æœŸ
- å½“ç¼©çŸ­åˆ°ä¸€å®šç¨‹åº¦æ—¶ï¼Œå…³é”®æ´»åŠ¨å¯èƒ½ä¼šå˜æˆéå…³é”®æ´»åŠ¨

> 1. äº‹ä»¶ $V_k$ çš„æœ€æ—©å‘ç”Ÿæ—¶é—´ $ve(k)$ - å†³å®šäº†æ‰€æœ‰ä» $V_k$ å¼€å§‹çš„æ´»åŠ¨èƒ½å¤Ÿå¼€å·¥çš„æœ€æ—©æ—¶é—´
> 2. æ´»åŠ¨ $a_i$ çš„æœ€æ—©å¼€å§‹æ—¶é—´ $e(i)$ - æŒ‡è¯¥æ´»åŠ¨ $a_i$ å¼§çš„èµ·ç‚¹æ‰€è¡¨ç¤ºçš„äº‹ä»¶çš„æœ€æ—©å‘ç”Ÿæ—¶é—´
> 3. äº‹ä»¶ $V_k$ çš„æœ€è¿Ÿå‘ç”Ÿæ—¶é—´ $vl(k)$ - å®ƒæ˜¯æŒ‡åœ¨ä¸æ¨è¿Ÿæ•´ä¸ªå·¥ç¨‹å®Œæˆçš„å‰æä¸‹ï¼Œè¯¥äº‹ä»¶æœ€è¿Ÿå¿…é¡»å‘ç”Ÿçš„æ—¶é—´ã€‚
> 4. æ´»åŠ¨ $a_i$ çš„æœ€è¿Ÿå¼€å§‹æ—¶é—´ $l(i)$ - å®ƒæ˜¯æŒ‡è¯¥æ´»åŠ¨ $a_i$ å¼§çš„ç»ˆç‚¹æ‰€è¡¨ç¤ºäº‹ä»¶çš„æœ€è¿Ÿå‘ç”Ÿæ—¶é—´ä¸è¯¥æ´»åŠ¨æ‰€éœ€æ—¶é—´ä¹‹å·®ã€‚
> 5. æ´»åŠ¨çš„æ—¶é—´ä½™é‡ $d(i)=l(i)-e(i)$ - è¡¨ç¤ºåœ¨ä¸å¢åŠ å®Œæˆæ•´ä¸ªå·¥ç¨‹æ‰€éœ€æ€»æ—¶é—´çš„æƒ…å†µä¸‹ï¼Œæ´»åŠ¨aå¯ä»¥æ‹–å»¶çš„æ—¶é—´
>> ps: $d(i)=0$ çš„æ´»åŠ¨æ˜¯å…³é”®æ´»åŠ¨ï¼Œç”±å…³é”®æ´»åŠ¨ç»„æˆçš„è·¯å¾„å°±æ˜¯å…³é”®è·¯å¾„

# ç¬¬ä¸ƒç« â€”â€”æŸ¥æ‰¾

## 7.1 æŸ¥æ‰¾çš„åŸºæœ¬æ¦‚å¿µ

## 7.2 é¡ºåºã€æŠ˜åŠã€åˆ†å—

### 7.2.1 é¡ºåºæŸ¥æ‰¾

```c++
struct ElemType {
  int key;
  int operator!=(ElemType e) { return key != e.key; }
};

typedef struct {  // æŸ¥æ‰¾è¡¨çš„æ•°æ®ç»“æ„ï¼ˆé¡ºåºè¡¨ï¼‰
  ElemType *elem; // åŠ¨æ€æ•°æ®åŸºå€
  int TableLen;   // è¡¨çš„é•¿åº¦
} SSTable;

// é¡ºåºæŸ¥æ‰¾_éå“¨å…µ
int Search_Seq(SSTable ST, ElemType key) {
  int i;
  for (i = 0; i < ST.TableLen && ST.elem[i] != key; i++) {
  }
  // æŸ¥æ‰¾æˆåŠŸï¼Œåˆ™è¿”å›å…ƒç´ ä¸‹æ ‡ï¼›æŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™è¿”å›-1
  return i == ST.TableLen ? -1 : i;
}

// é¡ºåºæŸ¥æ‰¾_å“¨å…µï¼Œæ•°æ®ä»ä¸‹æ ‡1å¼€å§‹å­˜å‚¨
int Search_Seq_sentinel(SSTable ST, ElemType key) {
  ST.elem[0] = key; // å“¨å…µ
  int i;
  for (i = ST.TableLen; ST.elem[i] != key; --i) { // ä»åå¾€å‰æŸ¥æ‰¾
  }
  return i; // æŸ¥æ‰¾æˆåŠŸï¼Œåˆ™è¿”å›å…ƒç´ ä¸‹æ ‡ï¼›æŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™è¿”å›0
}
```

æŸ¥æ‰¾æˆåŠŸ $ASL_{æˆåŠŸ}=\frac{1+2+3+\cdots+n}{n}=\frac{n+1}{2}$  
æŸ¥æ‰¾å¤±è´¥ $ASL_{å¤±è´¥}=n+1$  

é¡ºåºæŸ¥æ‰¾çš„ä¼˜åŒ–ï¼ˆå¯¹äºé¡ºåºè¡¨ï¼‰ã€é€’å¢æˆ–é€’å‡ã€‘  
æŸ¥æ‰¾å¤±è´¥ $ASL_{å¤±è´¥}=\frac{1+2+3+\cdots+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$

### 7.2.2 æŠ˜åŠæŸ¥æ‰¾
åˆç§°äºŒåˆ†æŸ¥æ‰¾ï¼Œä»…é€‚ç”¨äº <font color='red'>æœ‰åº</font> çš„ <font color='red'>é¡ºåºè¡¨</font>

$å…·æœ‰nä¸ª (n>0) ç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„é«˜åº¦ä¸º \log_{2}{(n+1)} æˆ– \log_{2}{n}+1$

$æ—¶é—´å¤æ‚åº¦ O(\log_{2}{n})$

```c++
struct ElemType {
  int key;
  int operator!=(ElemType e) { return key != e.key; }
  int operator==(ElemType e) { return key == e.key; }
  int operator>(ElemType e) { return key > e.key; }
  int operator<(ElemType e) { return key < e.key; }
};

typedef struct {  // æŸ¥æ‰¾è¡¨çš„æ•°æ®ç»“æ„ï¼ˆé¡ºåºè¡¨ï¼‰
  ElemType *elem; // åŠ¨æ€æ•°æ®åŸºå€
  int TableLen;   // è¡¨çš„é•¿åº¦
} SSTable;

int Binary_Search(SSTable L, ElemType key) {
  int low = 0, high = L.TableLen - 1;
  while (low <= high) {
    int mid = (low + high) / 2; // å–ä¸­é—´ä½ç½®
    if (L.elem[mid] == key) {
      return mid; // æŸ¥æ‰¾æˆåŠŸåˆ™è¿”å›æ‰€åœ¨ä½ç½®
    } else if (L.elem[mid] > key) {
      high = mid - 1; // ä»å‰åŠéƒ¨åˆ†ç»§ç»­æŸ¥æ‰¾
    } else {
      low = mid + 1; // ä»ååŠéƒ¨åˆ†ç»§ç»­æŸ¥æ‰¾
    }
  }
  return -1; // æŸ¥æ‰¾å¤±è´¥ï¼Œè¿”å› -1
}
```

æŠ˜åŠæŸ¥æ‰¾åˆ¤å®šæ ‘çš„æ„é€   
å¹³è¡¡äºŒå‰æ ‘  
å³å­æ ‘ç»“ç‚¹æ•°-å·¦å­æ ‘ç»“ç‚¹æ•° = 0 æˆ– 1  
åˆ¤å®šæ ‘ç»“ç‚¹å…³é”®å­—ï¼šå·¦ï¼œä¸­ï¼œå³ï¼Œæ»¡è¶³äºŒå‰æ’åºæ ‘çš„å®šä¹‰  
å¤±è´¥ç»“ç‚¹ï¼šn+1ä¸ªï¼ˆç­‰äºæˆåŠŸç»“ç‚¹çš„ç©ºé“¾åŸŸæ•°é‡ï¼‰  

### 7.2.3 åˆ†å—æŸ¥æ‰¾â€”â€”(æ‰‹ç®—)

ç´¢å¼•å—ä¹‹é—´æœ‰åº, ç´¢å¼•å—å†…æ— åº

å¯¹ç´¢å¼•è¡¨è¿›è¡ŒæŠ˜åŠæŸ¥æ‰¾æ—¶ï¼Œè‹¥ç´¢å¼•è¡¨ä¸­ä¸åŒ…å«ç›®æ ‡å…³é”®å­—ï¼Œ åˆ™æŠ˜åŠæŸ¥æ‰¾æœ€ç»ˆåœåœ¨ low > high ï¼Œè¦åœ¨ low æ‰€æŒ‡åˆ†å—ä¸­æŸ¥æ‰¾

```c++
//ç´¢å¼•è¡¨
typedef struct{
    ElemType maxValue;  //æ¯ä¸ªåˆ†å—çš„æœ€å¤§å…³é”®å­—
    int low,high;       //å­˜å‚¨ç©ºé—´çš„ç´¢å¼•ä¸‹æ ‡èŒƒå›´
}Index;

//é¡ºåºè¡¨å®é™…å­˜å‚¨çš„å…ƒç´ 
ElemType List[100];
```

å‡è®¾ï¼Œé•¿åº¦ä¸º n çš„æŸ¥æ‰¾è¡¨è¢«å‡åŒ€åœ°åˆ†ä¸º b å—ï¼Œæ¯å— s ä¸ªå…ƒç´ 
åˆ†å—æŸ¥æ‰¾çš„å¹³å‡æŸ¥æ‰¾é•¿åº¦ä¸º $ASL_{åˆ†å—æŸ¥æ‰¾}=ASL_{ç´¢å¼•æŸ¥æ‰¾}+ASL_{å—å†…æŸ¥æ‰¾}$
â‘  ç”¨ <font color='blue'>é¡ºåº</font> æŸ¥æ‰¾ç´¢å¼•è¡¨

$$
\begin{aligned}
n &=b*s   \\[5px]
ASL_{åˆ†å—æŸ¥æ‰¾} &=ASL_{ç´¢å¼•é¡ºåº}+ASL_{å—å†…é¡ºåº}    \\[5px] 
ASL_{ç´¢å¼•é¡ºåº} &=\frac{1+2+ \dots +b}{b}=\frac{b+1}{2}    \\[5px]
ASL_{å—å†…é¡ºåº} &=\frac{1+2+ \dots +s}{s}=\frac{s+1}{2}
\end{aligned}
$$

$$
\begin{aligned}
    ASL &=\frac{b+1}{2}+\frac{s+1}{2} \\[5px]
        &=\frac{\frac{n}{s}+1}{2}+\frac{s+1}{2} \\[5px]
        &=\frac{s^2+2s+n}{2s},å½“s=\sqrt{n}æ—¶ï¼ŒASL_{æœ€å°}=\sqrt{n}+1
\end{aligned}
$$

â‘¡ ç”¨ <font color='blue'>æŠ˜åŠ</font> æŸ¥æ‰¾ç´¢å¼•è¡¨

$$
ASL=\lceil \log_{2}{(b+1)} \rceil+\frac{s+1}{2}
$$

## 7.3 æ ‘å‹æŸ¥æ‰¾

### 7.3.1 äºŒå‰æ’åºæ ‘ï¼ˆäºŒå‰æœç´¢æ ‘BSTï¼‰

å»ºç«‹ã€æŸ¥æ‰¾ã€æ’å…¥ç­‰ç›¸å…³æ“ä½œ

```c++
#include <iostream>

// äºŒå‰æ’åºæ ‘ç»“ç‚¹
typedef struct BSTNode {
  int key;
  struct BSTNode *lchild, *rchild;
} BSTNode, *BSTree;

// åœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾å€¼ä¸º key çš„ç»“ç‚¹
BSTNode *BST_Search(BSTree T, int key) {
  while (T != NULL && key != T->key) { // è‹¥æ ‘ç©ºæˆ–ç­‰äºæ ¹ç»“ç‚¹å€¼ï¼Œåˆ™ç»“æŸå¾ªç¯
    if (key < (T->key))
      T = T->lchild; // å°äºï¼Œåˆ™åœ¨å·¦å­æ ‘ä¸ŠæŸ¥æ‰¾
    else
      T = T->rchild; // å¤§äºï¼Œåˆ™åœ¨å³å­æ ‘ä¸ŠæŸ¥æ‰¾
  }
  return T;
}

// åœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾å€¼ä¸º key çš„ç»“ç‚¹ï¼ˆé€’å½’å®ç°ï¼‰
BSTNode *BSTSearch(BSTree T, int key) {
  if (T == NULL)
    return NULL; // æŸ¥æ‰¾å¤±è´¥
  if (key == T->key)
    return T; // æŸ¥æ‰¾æˆåŠŸ
  else if (key < T->key)
    return BSTSearch(T->lchild, key); // åœ¨å·¦å­æ ‘ä¸­æŸ¥æ‰¾
  else
    return BSTSearch(T->rchild, key); // åœ¨å³å­æ ‘ä¸­æŸ¥æ‰¾
}

// åœ¨äºŒå‰æ’åºæ ‘æ’å…¥å…³é”®å­—ä¸º k çš„æ–°ç»“ç‚¹ï¼ˆé€’å½’å®ç°ï¼‰
int BST_Insert(BSTree &T, int k) {
  if (T == NULL) { // åŸæ ‘ä¸ºç©ºï¼Œæ–°æ’å…¥çš„ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹
    T = (BSTree)malloc(sizeof(BSTNode));
    T->key = k;
    T->lchild = T->rchild = NULL;
    return 1;             // è¿”å› 1 ï¼Œæ’å…¥æˆåŠŸ
  } else if (k == T->key) // æ ‘ä¸­å­˜åœ¨ç›¸åŒå…³é”®å­—çš„ç»“ç‚¹ï¼Œæ’å…¥å¤±è´¥ï¼Œè¿”å› 0
    return 0;
  else if (k < T->key) // æ’å…¥åˆ° T çš„å·¦å­æ ‘
    return BST_Insert(T->lchild, k);
  else // æ’å…¥åˆ° T çš„å³å­æ ‘
    return BST_Insert(T->rchild, k);
}

// æŒ‰ç…§ str[] ä¸­çš„å…³é”®å­—åºåˆ—å»ºç«‹äºŒå‰æ’åºæ ‘
void Create_BST(BSTree &T, int str[], int n) {
  T = NULL; // åˆå§‹åŒ– T ä¸ºç©ºæ ‘
  int i = 0;
  while (i < n) { // ä¾æ¬¡å°†æ¯ä¸ªå…³é”®å­—æ’å…¥åˆ°äºŒå‰æ’åºæ ‘ä¸­
    BST_Insert(T, str[i]);
    i++;
  }
}
```

### 7.3.2 å¹³è¡¡äºŒå‰æ ‘

```c++
#include<iostream>
using namespace std;
typedef struct AVLNode{
    int key;        //ç»“ç‚¹å…³é”®è¯
    int balance;    //å¹³è¡¡å› å­
    struct AVLNode *lchild,*rchild;
}AVLNode,*AVLTree
```

åŸºæœ¬æ“ä½œï¼šæ’å…¥
1. è°ƒæ•´LLï¼ˆå³æ—‹æ“ä½œï¼‰: å®ç° f å‘å³ä¸‹æ—‹è½¬ï¼Œp å‘å³ä¸Šæ—‹è½¬:

> å…¶ä¸­ f æ˜¯çˆ¹ï¼Œp ä¸ºå·¦å­©å­ï¼Œgf ä¸º f ä»–çˆ¹  
> â‘  f -> lchild = p -> rchild;  
> â‘¡ p -> rchild = f;  
> â‘¢ gf -> lchild/rchild = p;  

2. è°ƒæ•´RRï¼ˆå·¦æ—‹æ“ä½œï¼‰: å®ç° f å‘å·¦ä¸‹æ—‹è½¬ï¼Œp å‘å·¦ä¸Šæ—‹è½¬:

> å…¶ä¸­ f æ˜¯çˆ¹ï¼Œp ä¸ºå³å­©å­ï¼Œgf ä¸º f ä»–çˆ¹  
> â‘  f -> rchild = p -> lchild;  
> â‘¡ p -> lchild = f;  
> â‘¢ gf -> lchild/rchild = p;  

3. è°ƒæ•´LR å·¦æ—‹å†å³æ—‹

4. è°ƒæ•´RL å³æ—‹å†å·¦æ—‹

åŸºæœ¬æ“ä½œï¼šåˆ é™¤
1. åˆ é™¤ç»“ç‚¹ï¼ˆæ–¹æ³•åŒâ€œäºŒå‰æ’åºæ ‘â€ï¼‰
   - è‹¥åˆ é™¤çš„ç»“ç‚¹æ˜¯å¶å­ï¼Œç›´æ¥åˆ ã€‚
   - è‹¥åˆ é™¤çš„ç»“ç‚¹åªæœ‰ä¸€ä¸ªå­æ ‘ï¼Œç”¨å­æ ‘é¡¶æ›¿åˆ é™¤ä½ç½®
   - è‹¥åˆ é™¤çš„ç»“ç‚¹æœ‰ä¸¤æ£µå­æ ‘ï¼Œç”¨å‰é©±ï¼ˆæˆ–åç»§ï¼‰ç»“ç‚¹é¡¶æ›¿ï¼Œå¹¶è½¬æ¢ä¸ºå¯¹å‰é©±ï¼ˆæˆ–åç»§ï¼‰ç»“ç‚¹çš„åˆ é™¤ã€‚
2. ä¸€è·¯å‘åŒ—æ‰¾åˆ°æœ€å°ä¸å¹³è¡¡å­æ ‘ï¼Œæ‰¾ä¸åˆ°å°±å®Œç»“æ’’èŠ±
3. æ‰¾æœ€å°ä¸å¹³è¡¡å­æ ‘ä¸‹ï¼Œâ€œä¸ªå¤´â€æœ€é«˜çš„å„¿å­ã€å­™å­
4. æ ¹æ®å­™å­çš„ä½ç½®ï¼Œè°ƒæ•´å¹³è¡¡ï¼ˆLL/RR/LR/RLï¼‰ 
   - å­™å­åœ¨LL: å„¿å­å³å•æ—‹
   - å­™å­åœ¨RR: å„¿å­å·¦å•æ—‹
   - å­™å­åœ¨LR: å­™å­å…ˆå·¦æ—‹ï¼Œå†å³æ—‹
   - å­™å­åœ¨RL: å­™å­å…ˆå³æ—‹ï¼Œå†å·¦
5. å¦‚æœä¸å¹³è¡¡å‘ä¸Šä¼ å¯¼ï¼Œç»§ç»­â‘¡

![](pictures/å¹³è¡¡äºŒå‰æ ‘åˆ é™¤.png)

### 7.3.3 çº¢é»‘æ ‘
çº¢é»‘æ ‘æ˜¯äºŒå‰æ’åºæ ‘:å·¦å­æ ‘ç»“ç‚¹å€¼â‰¤æ ¹ç»“ç‚¹å€¼â‰¤å³å­æ ‘ç»“ç‚¹å€¼

â‘ æ¯ä¸ªç»“ç‚¹æˆ–æ˜¯çº¢è‰²ï¼Œæˆ–æ˜¯é»‘è‰²çš„  
â‘¡æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²çš„  
â‘¢å¶ç»“ç‚¹ï¼ˆå¤–éƒ¨ç»“ç‚¹ã€NULLç»“ç‚¹ã€å¤±è´¥ç»“ç‚¹ï¼‰å‡æ˜¯é»‘è‰²çš„  
â‘£ä¸å­˜åœ¨ä¸¤ä¸ªç›¸é‚»çš„çº¢ç»“ç‚¹ï¼ˆå³çº¢ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹å’Œå­©å­ç»“ç‚¹å‡æ˜¯é»‘è‰²ï¼‰  
â‘¤å¯¹æ¯ä¸ªç»“ç‚¹ï¼Œä»è¯¥èŠ‚ç‚¹åˆ°ä»»ä¸€å¶ç»“ç‚¹çš„ç®€å•è·¯å¾„ä¸Šï¼Œæ‰€å«é»‘ç»“ç‚¹çš„æ•°ç›®ç›¸åŒ  

**å£è¯€ï¼šå·¦æ ¹å³ï¼Œæ ¹å¶é»‘ï¼Œä¸çº¢çº¢ï¼Œé»‘è·¯åŒ**

```c++
struct RBnode {   // çº¢é»‘æ ‘çš„ç»“ç‚¹å®šä¹‰
  int key;        // å…³é”®å­—çš„å€¼
  RBnode *parent; // çˆ¶ç»“ç‚¹æŒ‡é’ˆ
  RBnode *lChild; // å·¦å­©å­æŒ‡é’ˆ
  RBnode *rChild; // å³å­©å­æŒ‡é’ˆ
  int color; // ç»“ç‚¹é¢œè‰²,å¯ç”¨ 0/1 ä»£è¡¨ é»‘/çº¢,ä¹Ÿå¯ç”¨enumæšä¸¾è¡¨ç¤ºé¢œè‰²
};
```

æ€§è´¨ï¼š
1. ä»æ ¹èŠ‚ç‚¹åˆ°å¶ç»“ç‚¹çš„æœ€é•¿è·¯å¾„ä¸å¤§äºæœ€çŸ­è·¯å¾„çš„2å€
2. æœ‰nä¸ªå†…éƒ¨èŠ‚ç‚¹çš„çº¢é»‘æ ‘é«˜åº¦ $h \leqslant 2\log_{2}{(n+1)}$
3. çº¢é»‘æ ‘çš„æŸ¥æ‰¾æ“ä½œæ—¶é—´å¤æ‚åº¦ä¸º $O(\log_{2}{n})$
4. ç»“ç‚¹çš„é»‘é«˜bhâ€”â€”ä»æŸç»“ç‚¹å‡ºå‘ï¼ˆä¸å«è¯¥ç»“ç‚¹ï¼‰åˆ°è¾¾ä»»ä¸€å¶ç»“ç‚¹çš„è·¯å¾„ä¸Šé»‘ç»“ç‚¹æ€»æ•°

> ç»“è®ºï¼šè‹¥æ ¹èŠ‚ç‚¹é»‘é«˜ä¸ºhï¼Œå†…éƒ¨ç»“ç‚¹æ•°ï¼ˆå…³é”®å­—ï¼‰æœ€å°‘æœ‰ $2^h-1$ ä¸ªã€æ»¡äºŒå‰æ ‘çš„çŠ¶æ€ã€‘  
> æ€§è´¨2è¯æ˜ï¼šè‹¥çº¢é»‘æ ‘æ€»é«˜åº¦ = h ï¼Œåˆ™æ ¹èŠ‚ç‚¹é»‘é«˜ $bh \geqslant \frac{h}{2}$ ,å› æ­¤å†…éƒ¨ç»“ç‚¹æ•° $n \geqslant 2^{\frac{h}{2}}-1$ ,ç”±æ­¤æ¨å‡º $h \leqslant 2\log_2(n+1)$

æ’å…¥æ“ä½œï¼š
- å…ˆæŸ¥æ‰¾ï¼Œç¡®å®šæ’å…¥ä½ç½®ï¼ˆåŸç†åŒäºŒå‰æ’åºæ ‘ï¼‰ï¼Œæ’å…¥æ–°ç»“ç‚¹ 
- <font style="background-color:#00ff90">æ–°ç»“ç‚¹</font>æ˜¯<font style="background-color:black;color:white">æ ¹</font>--æŸ“ä¸º<font style="background-color:black;color:white">é»‘è‰²</font>
- <font style="background-color:#00ff90">æ–°ç»“ç‚¹</font><font style="background-color:red;color:white">éæ ¹</font>--æŸ“ä¸º<font style="background-color:red;color:white">çº¢è‰²</font>
  - è‹¥æ’å…¥æ–°ç»“ç‚¹åä¾ç„¶æ»¡è¶³çº¢é»‘æ ‘å®šä¹‰ï¼Œåˆ™æ’å…¥ç»“æŸ
  - è‹¥æ’å…¥æ–°ç»“ç‚¹åä¸æ»¡è¶³çº¢é»‘æ ‘å®šä¹‰ï¼Œéœ€è¦<font style="background-color:yellow">è°ƒæ•´</font>ï¼Œä½¿å…¶é‡æ–°æ»¡è¶³çº¢é»‘æ ‘å®šä¹‰
    - <font style="background-color:black;color:white">é»‘å”</font>ï¼šæ—‹è½¬+æŸ“è‰²
      - LLå‹ï¼šå³å•æ—‹ï¼Œçˆ¶æ¢çˆ·+æŸ“è‰²
      - RRå‹ï¼šå·¦å•æ—‹ï¼Œçˆ¶æ¢çˆ·+æŸ“è‰²
      - LRå‹ï¼šå·¦ã€å³åŒæ—‹ï¼Œå„¿æ¢çˆ·+æŸ“è‰²
      - RLå‹ï¼šå³ã€å·¦åŒæ—‹ï¼Œå„¿æ¢çˆ·ï¼‹æŸ“è‰²
    - <font style="background-color:red;color:white">çº¢å”</font>ï¼šæŸ“è‰²+å˜æ–°
      - å”çˆ¶çˆ·æŸ“è‰²ï¼Œçˆ·å˜ä¸ºæ–°ç»“ç‚¹
## 7.4 Bæ ‘å’ŒB+æ ‘

### 7.4.1 Bæ ‘

```c++
// 5å‰æ’åºæ ‘çš„ç»“ç‚¹å®šä¹‰
struct Node{
    ElemType keys[4];       // æœ€å¤š4ä¸ªå…³é”®å­—
    struct Node *child[5];  // æœ€å¤š5ä¸ªå­©å­
    int num;                // ç»“ç‚¹ä¸­æœ‰å‡ ä¸ªå…³é”®å­—
}
```

> mé˜¶Bæ ‘ã€å¤šè·¯å¹³è¡¡æŸ¥æ‰¾æ ‘ã€‘çš„æ ¸å¿ƒç‰¹æ€§
> 1. æ ‘ä¸­æ¯ä¸ªç»“ç‚¹è‡³å¤šæœ‰mæ£µå­æ ‘ï¼Œå³è‡³å¤šå«æœ‰m-1ä¸ªå…³é”®å­—ã€‚
> 2. æ ¹ç»“ç‚¹çš„å­æ ‘æ•° $ \in [ 2 , m ]$ , å…³é”®å­—ä¸ªæ•° $ \in[1 , m-1] $
>     å…¶ä»–å­æ ‘çš„å­æ ‘æ•° $ \in [\lceil m/2 \rceil,m]$,å…³é”®å­—ä¸ªæ•° $ \in [ \lceil m/2\rceil-1 ,m-1]$
> 3. å¯¹ä»»ä¸€ç»“ç‚¹ï¼Œå…¶æ‰€æœ‰å­æ ‘çš„é«˜åº¦ç›¸åŒ
> 4. æ‰€æœ‰çš„å¶ç»“ç‚¹éƒ½å‡ºç°åœ¨åŒä¸€å±‚æ¬¡ä¸Šï¼Œå¹¶ä¸”ä¸å¸¦ä¿¡æ¯ã€å¤±è´¥ç»“ç‚¹ï¼Œç©ºæŒ‡é’ˆã€‘
> 6. å…³é”®å­—çš„å€¼ï¼šå­æ ‘0 < å…³é”®å­—1 < å­æ ‘1 < å…³é”®å­—2 ...

<font size=5px>å¦‚ä½•ä¿è¯æŸ¥æ‰¾æ•ˆç‡</font>

ç­–ç•¥1ï¼šmå‰æŸ¥æ‰¾æ ‘ä¸­ï¼Œè§„å®š <font color='red'>é™¤äº†æ ¹ç»“ç‚¹å¤–</font>ï¼Œä»»ä½•ç»“ç‚¹è‡³å°‘æœ‰ $\color{red}{\lceil m/2 \rceil}$ ä¸ªåˆ†å‰ï¼Œå³è‡³å°‘å«æœ‰ $\color{red}{\lceil m/2 \rceil-1}$ ä¸ªå…³é”®å­—
&emsp;example:
&emsp;å¯¹äº5å‰æ’åºæ ‘ï¼Œé™¤äº†æ ¹ç»“ç‚¹å¤–ï¼Œä»»ä½•ç»“ç‚¹éƒ½è‡³å°‘æœ‰3ä¸ªåˆ†æ”¯ï¼Œ2ä¸ªå…³é”®å­—

---

ç­–ç•¥2ï¼šmå‰æŸ¥æ‰¾æ ‘ä¸­ï¼Œè§„å®šå¯¹äºä»»ä½•ä¸€ä¸ªç»“ç‚¹ï¼Œå…¶æ‰€æœ‰å­æ ‘çš„é«˜åº¦éƒ½è¦ç›¸åŒ

---

æ‰€æœ‰éå¶èŠ‚ç‚¹çš„ç»“æ„å¦‚ä¸‹ï¼š

$$
K_i ä»£è¡¨ç»“ç‚¹çš„å…³é”®å­—    \\[5px]
P_i ä»£è¡¨æŒ‡å‘å­æ ‘æ ¹ç»“ç‚¹çš„æŒ‡é’ˆ    \\[5px]
\begin{array}{|c|c|c|c|c|c|c|c|c|}
 n & P_0 & K_1 & P_1 & K_2 & P_2 & \dots & K_n & P_n 
\end{array}
$$

æœ€å°é«˜åº¦â€”â€”è®©æ¯ä¸ªç»“ç‚¹å°½å¯èƒ½çš„æ»¡ï¼Œæœ‰ $m-1$ ä¸ªå…³é”®å­—, $m$ ä¸ªåˆ†å‰ï¼Œåˆ™æœ‰ $n<=(m-1)(1+m+m^2+m^3+\cdots+m^{h-1})=m^h-1$ ,å› æ­¤ $h>=\log_m(n+1)$

æœ€å¤§é«˜åº¦â€”â€”è®©å„å±‚çš„åˆ†å‰å°½å¯èƒ½çš„å°‘ï¼Œå³æ ¹èŠ‚ç‚¹åªæœ‰2ä¸ªåˆ†å‰ï¼Œå…¶ä»–ç»“ç‚¹åªæœ‰ $\lceil m/2 \rceil$ ä¸ªåˆ†å‰
å„å±‚ç»“ç‚¹è‡³å°‘æœ‰:
ç¬¬ä¸€å±‚ $1$ 
ç¬¬äºŒå±‚ $2$ 
ç¬¬ä¸‰å±‚ $2\lceil m/2 \rceil$
ç¬¬hå±‚ $2(\lceil m/2 \rceil)^{h-2}$
ç¬¬h+1å±‚ã€å¶å­ç»“ç‚¹ã€‘ $2(\lceil m/2 \rceil)^{h-1}$

nä¸ªå…³é”®å­—çš„Bæ ‘å¿…æœ‰n+1ä¸ªå¶å­ç»“ç‚¹ï¼Œåˆ™ $n+1>=2(\lceil m/2 \rceil)^{h-1}$ ,å³ $ h<=\log_{\lceil m/2 \rceil}\frac{n+1}{2}+1$

åŸºæœ¬æ“ä½œï¼šæ’å…¥ã€æ³¨æ„æº¢å‡ºåˆ†è£‚ã€‘ã€åˆ é™¤ã€å¦‚æœä¸ºç»ˆç«¯ç»“ç‚¹ï¼Œåˆ™ç›´æ¥åˆ é™¤ï¼›è‹¥ä¸æ˜¯ç»ˆç«¯ç»“ç‚¹ï¼Œä½¿ç”¨ç›´æ¥å‰é©±æˆ–è€…ç›´æ¥åç»§å–ä»£è¢«åˆ é™¤çš„å…ƒç´ ,è‹¥å…ƒç´ æ•°é‡ä¸å¤Ÿå¯å‘å…„å¼Ÿç»“ç‚¹å€Ÿå…ƒç´ ï¼Œå€˜è‹¥å…„å¼Ÿç»“ç‚¹æ•°é‡ä¹Ÿä¸å¤Ÿï¼Œå¯è€ƒè™‘åˆå¹¶ç»“ç‚¹ã€‘

### 7.4.2 B+æ ‘
ä¸€æ£µmé˜¶çš„B+æ ‘éœ€æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š

1. æ¯ä¸ªåˆ†æ”¯ç»“ç‚¹æœ€å¤šæœ‰mæ£µå­æ ‘ï¼ˆå­©å­ç»“ç‚¹ï¼‰ã€‚
2. éå¶æ ¹ç»“ç‚¹è‡³å°‘æœ‰ä¸¤æ£µå­æ ‘ï¼Œå…¶ä»–æ¯ä¸ªåˆ†æ”¯ç»“ç‚¹è‡³å°‘æœ‰ $\lceil m/2 \rceil$ æ£µå­æ ‘ã€‚
3. ç»“ç‚¹çš„å­æ ‘ä¸ªæ•°ä¸å…³é”®å­—ä¸ªæ•°ç›¸ç­‰ã€‚
4. æ‰€æœ‰å¶ç»“ç‚¹åŒ…å«å…¨éƒ¨å…³é”®å­—åŠæŒ‡å‘ç›¸åº”è®°å½•çš„æŒ‡é’ˆï¼Œå¶ç»“ç‚¹ä¸­å°†å…³é”®å­—æŒ‰å¤§å°é¡ºåºæ’åˆ—ï¼Œå¹¶ä¸”ç›¸é‚»å¶ç»“ç‚¹æŒ‰å¤§å°é¡ºåºç›¸äº’é“¾æ¥èµ·æ¥ã€‚

## 7.5 æ•£åˆ—è¡¨ï¼ˆå“ˆå¸Œè¡¨ï¼‰

æ•£åˆ—å‡½æ•°å¯èƒ½ä¼šæŠŠä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„ä¸åŒå…³é”®å­—æ˜ å°„åˆ°åŒä¸€åœ°å€ï¼Œç§°è¿™ç§æƒ…å†µä¸º **å†²çª**  
è¿™äº›å‘ç”Ÿç¢°æ’çš„ä¸åŒå…³é”®å­—æˆä¸ºç§°ä¸º **åŒä¹‰è¯**

åœ¨å¼€æ”¾å®šå€æ³•ä¸­æ•£åˆ—åˆ°åŒä¸€ä¸ªåœ°å€è€Œäº§ç”Ÿçš„"å †ç§¯"é—®é¢˜ï¼Œæ˜¯åŒä¹‰è¯å†²çªçš„æ¢æŸ¥åºåˆ—å’ŒéåŒä¹‰è¯ä¹‹é—´ä¸åŒçš„æ¢æŸ¥åºåˆ—äº¤ç»‡åœ¨ä¸€èµ·ï¼Œå¯¼è‡´å…³é”®å­—æŸ¥è¯¢éœ€è¦ç»è¿‡è¾ƒé•¿çš„æ¢æµ‹è·ç¦»ï¼Œé™ä½äº†æ•£åˆ—çš„æ•ˆç‡ã€‚å› æ­¤è¦é€‰æ‹©å¥½çš„å¤„ç†å†²çªçš„æ–¹æ³•æ¥é¿å…"å †ç§¯"

è£…å¡«å› å­ $ \alpha =\frac{è¡¨ä¸­è®°å½•æ•°}{æ•£åˆ—è¡¨é•¿åº¦} $

æ„é€ æ–¹æ³•ï¼š
1. é™¤ç•™ä½™æ•°æ³• $\quad H(key)=key\mod{p} \quad$  
    æ•£åˆ—è¡¨è¡¨é•¿ä¸ºmï¼Œå–ä¸€ä¸ªä¸å¤§äºmä½†æœ€æ¥è¿‘æˆ–ç­‰äºmçš„è´¨æ•°p
2. ç›´æ¥å®šå€æ³• $\quad H(key)=key \quad æˆ–è€… \quad H(key)=a*key+b \quad$ è®¡ç®—ç®€å•ï¼Œä¸ä¼šäº§ç”Ÿå†²çªï¼Œé€‚ç”¨äºå…³é”®å­—åˆ†å¸ƒåŸºæœ¬è¿ç»­çš„æƒ…å†µ
3. æ•°å­—åˆ†ææ³•  &emsp; é€‰å–æ•°ç åˆ†å¸ƒè¾ƒä¸ºå‡åŒ€çš„è‹¥å¹²ä½ä½œä¸ºæ•£åˆ—åœ°å€ã€æ¯”å¦‚æ‰‹æœºå·ã€‘
4. å¹³æ–¹å–ä¸­æ³•  &emsp; å–å…³é”®å­—çš„å¹³æ–¹å€¼çš„ä¸­é—´å‡ ä½ä½œä¸ºæ•£åˆ—åœ°å€

è§£å†³å†²çªçš„æ–¹æ³•ï¼š
1. å¼€æ”¾å®šå€æ³• $H_i = (H(key)+d_i)\mod{m}, d_iä¸ºå¢é‡æ•°åˆ—, mä¸ºè¡¨é•¿åº¦ $ 
   1. çº¿æ€§æ¢æµ‹æ³•ï¼Œå³å‘ç”Ÿå†²çªæ—¶ï¼Œæ¯æ¬¡å¾€åæ¢æµ‹ç›¸é‚»çš„ä¸‹ä¸€ä¸ªå•å…ƒæ˜¯å¦ä¸ºç©º, $d_i=0,1,2,3,\cdots,m-1$
   2. å¹³æ–¹æ¢æµ‹æ³•, $d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2\quad å…¶ä¸­ k<=\frac{m}{2}$
   3. ä¼ªéšæœºåºåˆ—æ³•
   4. å†æ•£åˆ—æ³•
      <font style="background-color:red;color:white">æ³¨æ„ï¼šé‡‡ç”¨â€œå¼€æ”¾å®šå€æ³•â€æ—¶ï¼Œåˆ é™¤ç»“ç‚¹ä¸èƒ½ç®€å•åœ°å°†è¢«åˆ ç»“ç‚¹çš„ç©ºé—´ç½®ä¸ºç©ºï¼Œå¦åˆ™å°†æˆªæ–­åœ¨å®ƒä¹‹åå¡«å…¥æ•£åˆ—è¡¨çš„åŒä¹‰è¯ç»“ç‚¹çš„æŸ¥æ‰¾è·¯å¾„ï¼Œå¯ä»¥åšä¸€ä¸ªâ€œåˆ é™¤æ ‡è®°â€ï¼Œè¿›è¡Œé€»è¾‘åˆ é™¤</font>
2. æ‹‰é“¾æ³•

# ç¬¬å…«ç« â€”â€”æ’åº

## 8.1 æ’å…¥æ’åº
1. ç›´æ¥æ’å…¥æ’åºï¼ˆå“¨å…µä¸å¦ï¼‰[ç¨³å®š]
   - æœ€å¥½æ—¶é—´å¤æ‚åº¦ $ O(n) $
   - æœ€åæ—¶é—´å¤æ‚åº¦ $ O(n^2) $
   - å¹³å‡æ—¶é—´å¤æ‚åº¦ $ O(n^2) $
   - é€‚ç”¨äºé¡ºåºè¡¨ã€é“¾è¡¨
2. æŠ˜åŠæ’å…¥æ’åº[ç¨³å®š]
   - æœ€å¥½æ—¶é—´å¤æ‚åº¦ $ O(n) $
   - æœ€åæ—¶é—´å¤æ‚åº¦ $ O(n^2) $
   - å¹³å‡æ—¶é—´å¤æ‚åº¦ $ O(n^2) $
   - ä»…é€‚ç”¨äºé¡ºåºè¡¨
3. å¸Œå°”æ’åº[ä¸ç¨³å®š]
   - æ—¶é—´å¤æ‚åº¦:æœªçŸ¥
   - ä»…ç”¨äºé¡ºåºè¡¨
```c++
// ç›´æ¥æ’å…¥æ’åº
void InsertSort(int A[], int n) {
  int i, j, temp;
  for (i = 1; i < n; i++) { // å°†å„å…ƒç´ æ’å…¥å·²æ’å¥½åºçš„åºåˆ—ä¸­
    if (A[i] < A[i - 1]) {  // è‹¥A[i]å…³é”®å­—å°äºå‰é©±
      temp = A[i];
      for (j = i - 1; j >= 0 && A[j] > temp; --j) {        // æ£€æŸ¥æ‰€æœ‰å‰é¢å·²æ’å¥½åºçš„å…ƒç´ 
        A[j + 1] = A[j]; // æ‰€æœ‰å¤§äºtempä¹Ÿå°±æ˜¯A[i]çš„å…ƒç´ éƒ½å¾€åæŒªä½
      }
      A[j + 1] = temp; // å¤åˆ¶åˆ°æ’å…¥ä½ç½®
    }
  }
}

// ç›´æ¥æ’å…¥æ’åºï¼ˆå¸¦å“¨å…µï¼‰æ•°ç»„å­˜å‚¨ä»ä¸‹æ ‡1å¼€å§‹
void _InsertSort(int A[], int n) {
  int i, j;
  for (i = 2; i < n; i++) {
    if (A[i] < A[i - 1]) {
      A[0] = A[i];
      for (j = i - 1; A[0] < A[j]; --j) {
        A[j + 1] = A[j];
      }
      A[j + 1] = A[0];
    }
  }
}

// æŠ˜åŠæ’å…¥æ’åº
void HalfInsertSort(int A[], int n) {
  int i, j, low, high, mid;
  for (i = 2; i <= n; i++) { // ä¾æ¬¡å°†A[2]~A[n]æ’å…¥å‰é¢çš„å·²æ’åºåºåˆ—
    A[0] = A[i];             // å°†A[i]æš‚å­˜åˆ°A[0]
    low = 1;
    high = i - 1;         // è®¾ç½®æŠ˜åŠæŸ¥æ‰¾çš„èŒƒå›´
    while (low <= high) { // æŠ˜åŠæŸ¥æ‰¾ï¼ˆé€’å¢æœ‰åºåºåˆ—ï¼‰
      mid = (low + high) / 2;
      if (A[mid] > A[0])
        high = mid - 1;
      else
        low = mid + 1;
    }
    for (j = i - 1; j >= high + 1; --j) {
      A[j + 1] = A[j]; // ç»Ÿä¸€åç§»å…ƒç´ ï¼Œç©ºå‡ºæ’å…¥ä½ç½®
    }
    A[high + 1] = A[0]; // æ’å…¥æ“ä½œ
  }
}

// å¸Œå°”æ’åº
void ShellSort(int A[], int n) {
  int d, i, j; // A[0]åªæ˜¯æš‚å­˜å•å…ƒï¼Œä¸æ˜¯å“¨å…µï¼Œå½“j<=0æ—¶ï¼Œæ’å…¥ä½ç½®å·²åˆ°
  for (d = n / 2; d >= 1; d = d / 2) { // æ­¥é•¿å˜åŒ–
    for (i = d + 1; i <= n; i++) {
      if (A[i] < A[i - d]) { // éœ€å°†A[i]æ’å…¥æœ‰åºå¢é‡å­è¡¨
        A[0] = A[i];         // æš‚å­˜A[0]
        for (j = i - d; j > 0 && A[0] < A[j]; j -= d) {
          A[j + d] = A[j]; // è®°å½•åç§»ï¼Œå¯»æ‰¾æ’å…¥ä½ç½®
        }
        A[j + d] = A[0]; // æ’å…¥
      }
    }
  }
}
```

## 8.2 äº¤æ¢æ’åº
1. å†’æ³¡æ’åº[ç¨³å®š]
   - ä»åå¾€å‰ï¼Œä¸¤ä¸¤æ¯”è¾ƒï¼Œè‹¥ä¸ºé€†åºï¼Œåˆ™äº¤æ¢æ¬¡åº
   - æ¯ä¸€èººæ•ˆæœå°±æ˜¯ï¼Œæœ€å°çš„å…ƒç´ ä¾æ¬¡æ¥åˆ°å¤´éƒ¨
   - æœ€å¥½æƒ…å†µ(æœ‰åº): $$æ¯”è¾ƒæ¬¡æ•°=n-1;äº¤æ¢æ¬¡æ•°=0 \\ æœ€å¥½æ—¶é—´å¤æ‚åº¦=O(n)$$
   - æœ€åæƒ…å†µ(é€†åº): $$æ¯”è¾ƒæ¬¡æ•°=(n-1)+(n-2)+\cdots+1=\frac{n(n-1)}{2}=äº¤æ¢æ¬¡æ•° \\ æœ€åæ—¶é—´å¤æ‚åº¦ä¸ºO(n^2)$$
   - å¹³å‡æ—¶é—´å¤æ‚åº¦ $O(n^2)$
   - é€‚ç”¨æ€§ï¼šé¡ºåºè¡¨ã€é“¾è¡¨éƒ½å¯ä»¥
2. å¿«é€Ÿæ’åº[ä¸ç¨³å®š]
   - æ—¶é—´å¤æ‚åº¦ $O(n*é€’å½’å±‚æ•°)$
   - æœ€å¥½æ—¶é—´å¤æ‚åº¦ $=O(n\log_{2}{n})$ æœ€åæ—¶é—´å¤æ‚åº¦ $=O(n^2)$
   - å¹³å‡æ—¶é—´å¤æ‚åº¦ $=O(n\log_{2}{n})$
   - å½“æ¯æ¬¡çš„æ¢è½´éƒ½æŠŠè¡¨ç­‰åˆ†ä¸ºé•¿åº¦ç›¸è¿‘çš„ä¸¤ä¸ªå­è¡¨æ—¶ï¼Œé€Ÿåº¦æ˜¯æœ€å¿«çš„;å½“è¡¨æœ¬èº«å·²ç»æœ‰åºæˆ–é€†åºæ—¶ï¼Œé€Ÿåº¦æœ€æ…¢
   - å¿«æ’çš„é˜¶æ®µæ€§æ’åºç»“æœçš„ç‰¹ç‚¹æ˜¯ï¼Œç¬¬iè¶Ÿå®Œæˆæ—¶ï¼Œè‡³å°‘ä¼šæœ‰iä¸ªä»¥ä¸Šçš„æ•°å‡ºç°åœ¨å®ƒæœ€ç»ˆå°†è¦å‡ºç°çš„ä½ç½®

```c++
// å†’æ³¡æ’åº
void swap(int &a, int &b) {
  int temp = a;
  a = b;
  b = temp;
}

void BubbleSort(int A[], int n) {
  for (int i = 0; i < n - 1; i++) {
    bool flag = false; // è¡¨ç¤ºæœ¬è¶Ÿå†’æ³¡æ˜¯å¦å‘ç”Ÿäº¤æ¢çš„æ ‡å¿—
    for (int j = n - 1; j > i; j--) { // ä¸€è¶Ÿå†’æ³¡è¿‡ç¨‹
      if (A[j - 1] > A[j]) {          // è‹¥ä¸ºé€†åº
        swap(A[j - 1], A[j]);
        flag = true;
      }
      if (flag == false) // æœ¬è¶Ÿéå†åæ²¡æœ‰å‘ç”Ÿäº¤æ¢ï¼Œè¯´æ˜è¡¨å·²ç»æœ‰åº
        return;
    }
  }
}

// å¿«é€Ÿæ’åº, å¯¹äºé¡ºåºè¡¨
int Partition(int A[], int low, int high) {
  int pivot = A[low];  // ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºæ¢è½´
  while (low < high) { // ç”¨lowã€highæœç´¢æ¢è½´çš„æœ€ç»ˆä½ç½®
    while (low < high && A[high] >= pivot)
      --high;
    A[low] = A[high]; // æ¯”æ¢è½´å°çš„å…ƒç´ ç§»åŠ¨åˆ°å·¦ç«¯
    while (low < high && A[low] <= pivot)
      ++low;
    A[high] = A[low]; // æ¯”æ¢è½´å¤§çš„å…ƒç´ ç§»åŠ¨åˆ°å³ä¾§
  }
  A[low] = pivot; // æ¢è½´å…ƒç´ å­˜æ”¾åˆ°æœ€ç»ˆä½ç½®
  return low;     // è¿”å›å­˜æ”¾æ¢è½´çš„æœ€ç»ˆä½ç½®
}

void QuickSort(int A[], int low, int high) {
  if (low < high) {                         // é€’å½’è·³å‡ºçš„æ¡ä»¶
    int pivotpos = Partition(A, low, high); // åˆ’åˆ†
    QuickSort(A, low, pivotpos - 1);        // åˆ’åˆ†å·¦å­è¡¨
    QuickSort(A, pivotpos + 1, high);       // åˆ’åˆ†å³å­è¡¨
  }
}

// å¿«é€Ÿæ’åº, å¯¹äºå•é“¾è¡¨
typedef struct LNode {
  int data;
  struct LNode *next;
} LNode;

/**
 * Swaps the data between two LNode objects.
 *
 * @param pA Reference to the first LNode object.
 * @param pB Reference to the second LNode object.
 */
void swap(LNode &pA, LNode &pB) {
  int tmp = pA.data;
  pA.data = pB.data;
  pB.data = tmp;
}

/**
 * Partitions the linked list around a pivot element.
 *
 * @param pHead Pointer to the head of the linked list.
 * @param pTail Pointer to the tail of the linked list.
 *
 * @return Pointer to the pivot element after partition.
 */
LNode *GetMid(LNode *pHead, LNode *pTail) {
  LNode *p = pHead;
  LNode *q = pHead->next;
  while (q != pTail) {
    if (q->data < key) {
      p = p->next;
      swap(p,q);
    }
    q=q->next;
  }
  swap(pHead, p);
  return p;
}

void QuickSort(LNode *pHead, LNode *pTail) {
  if (pHead == pTail) {
    return;
  } else {
    LNode *pMid = GetMid(pHead, pTail);
    QuickSort(pHead, pMid);
    QuickSort(pMid->next, pTail);
  }
}
```

## 8.3 é€‰æ‹©æ’åº

é€‰æ‹©æ’åº:æ¯ä¸€è¶Ÿåœ¨å¾…æ’åºå…ƒç´ ä¸­é€‰å–å…³é”®å­—æœ€å°ï¼ˆæˆ–æœ€å¤§ï¼‰çš„å…ƒç´ åŠ å…¥æœ‰åºå­åºåˆ—

1. ç®€å•é€‰æ‹©æ’åº[ä¸ç¨³å®š]:
   - æ€»å…±éœ€è¦å¯¹æ¯”å…³é”®å­—æ¬¡æ•° $ =(n-1)+(n-2)+\cdots+1=\frac{n(n-1)}{2} $
   - å…ƒç´ äº¤æ¢æ¬¡æ•° $ï¼œ n-1$ æ¬¡
   - é€‚ç”¨äºé¡ºåºè¡¨ã€é“¾è¡¨
2. æ¨æ’åº[ä¸ç¨³å®š]
   - å¤§æ ¹å †ï¼šæ ¹>=å·¦ã€å³
   - å¤„ç†è¿‡ç¨‹ï¼šæ¯ä¸ªç»“ç‚¹ä¸å·¦å³å­©å­å¯¹æ¯”ï¼Œè‹¥ä¸æ»¡è¶³å¤§æ ¹å †è¦æ±‚ï¼Œåˆ™å°†ç»“ç‚¹ä¸å­©å­ä¸­æœ€å¤§çš„é‚£ä¸ªäº’æ¢
   - è‹¥å…ƒç´ äº’æ¢ç ´åäº†ä¸‹ä¸€çº§çš„å †ï¼Œåˆ™é‡‡ç”¨ç›¸åŒçš„æ–¹æ³•ç»§ç»­å¾€ä¸‹è°ƒæ•´ï¼ˆå°å…ƒç´ ä¸æ–­â€œä¸‹å â€ï¼‰
   - æ—¶é—´å¤æ‚åº¦:å»ºå † $O(n)$ ã€æ’åº $O(n\log_{2}{n})$ ;æ€»çš„æ—¶é—´å¤æ‚åº¦= $O(n\log_{2}{n}ï¼‰$
   - åŸºäºå¤§æ ¹å †çš„å †æ’åºå¾—åˆ°"é€’å¢åºåˆ—",åŸºäºå°æ ¹å †çš„å †æ’åºå¾—åˆ°"é€’å‡åºåˆ—"

å †æ’åºçš„ç®€å•æ“ä½œ:
1. æ’å…¥
   - å¯¹äºå°æ ¹å †ï¼Œæ–°å…ƒç´ æ”¾åˆ°è¡¨å°¾ï¼Œä¸çˆ¶èŠ‚ç‚¹å¯¹æ¯”ï¼Œ è‹¥æ–°å…ƒç´ æ¯”çˆ¶èŠ‚ç‚¹æ›´å°ï¼Œåˆ™å°†äºŒè€…äº’æ¢ã€‚æ–°å…ƒç´ å°±è¿™æ ·ä¸€è·¯â€œä¸Šå‡â€ï¼Œç›´åˆ°æ— æ³•ç»§ç»­ä¸Šå‡ä¸ºæ­¢
2. åˆ é™¤
   - è¢«åˆ é™¤çš„å…ƒç´ ç”¨å †åº•å…ƒç´ æ›¿ä»£ï¼Œç„¶åè®©è¯¥å…ƒç´ ä¸æ–­â€œä¸‹å â€ï¼Œç›´åˆ°æ— æ³•ä¸‹å ä¸ºæ­¢

```c++
void swap(int &a, int &b) {
  int temp = a;
  a = b;
  b = temp;
}

// ç®€å•é€‰æ‹©æ’åº
void SelectSort(int A[], int n) {
  for (int i = 0; i < n - 1; i++) {   // ä¸€å…±è¿›è¡Œn-1è¶Ÿ
    int min = i;                      // è®°å½•æœ€å°å…ƒç´ ä½ç½®
    for (int j = i + 1; j < n; j++) { // åœ¨A[i...n-1]ä¸­é€‰æ‹©æœ€å°çš„å…ƒç´ 
      if (A[j] < A[min])
        min = j; // æ›´æ–°æœ€å°å…ƒç´ ä½ç½®
    }
    if (min != i)
      swap(A[i], A[min]); // å°è£…äº¤æ¢å…ƒç´ 
  }
}

// å°†ä»¥kä¸ºæ ¹çš„å­æ ‘è°ƒæ•´ä¸ºå¤§æ ¹å †
void HeadAdjust(int A[], int k, int len) {
  A[0] = A[k];                            // A[0]æš‚å­˜å­æ ‘çš„æ ¹ç»“ç‚¹
  for (int i = 2 * k; i <= len; i *= 2) { // æ²¿ç€keyè¾ƒå¤§çš„ç»“ç‚¹å¾€ä¸‹ç­›é€‰
    if (i < len && A[i] < A[i + 1])
      i++;           // å–keyè¾ƒå¤§çš„ç»“ç‚¹å­ç»“ç‚¹çš„ä¸‹æ ‡
    if (A[0] > A[i]) // ç­›é€‰ç»“æŸ
      break;
    else {
      A[k] = A[i]; // å°†A[i]è°ƒæ•´åˆ°åŒäº²ç»“ç‚¹ä¸Š
      k = i;       // ä¿®æ”¹kå€¼ï¼Œä»¥ä¾¿ç»§ç»­å‘ä¸‹ç­›é€‰
    }
  }
  A[k] = A[0]; // è¢«ç­›é€‰çš„å€¼æ”¾å…¥æœ€ç»ˆä½ç½®
}

// å»ºç«‹å¤§æ ¹å †
void BuildMaxHeap(int A[], int len) {
  for (int i = len / 2; i > 0; i--) // ä»åå¾€å‰è°ƒæ•´æ‰€æœ‰éç»ˆç«¯ç»“ç‚¹
    HeadAdjust(A, i, len);
}

// å †æ’åº
void HeapSort(int A[], int len) {
  BuildMaxHeap(A, len);           // åˆå§‹å»ºå †
  for (int i = len; i > 1; i--) { // n-1è¶Ÿçš„äº¤æ¢å’Œå»ºå †è¿‡ç¨‹
    swap(A[i], A[1]);             // å †é¡¶å…ƒç´ å’Œå †åº•å…ƒç´ äº¤æ¢
    HeadAdjust(A, 1, i - 1);      // å‰©ä½™å¾…æ’åºå…ƒç´ æ•´ç†æˆå †
  }
}
```

## 8.4 å½’å¹¶æ’åºå’ŒåŸºæ•°æ’åº

### 8.4.1 å½’å¹¶æ’åºâ€”â€”ç¨³å®š

å½’å¹¶:æŠŠä¸¤ä¸ªæˆ–å¤šä¸ªå·²ç»æœ‰åºçš„åºåˆ—åˆå¹¶æˆä¸€ä¸ªæœ‰åºåºåˆ—
1. ç»“è®ºï¼šnä¸ªå…ƒç´ è¿›è¡Œ2è·¯å½’å¹¶æ’åºï¼Œå½’å¹¶è¶Ÿæ•°= $\lceil \log_{2}{n} \rceil$
2. æ¯è¶Ÿå½’å¹¶æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$
3. åˆ™ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º $O(n\log_{2}{n})$

<font style="color:red">mè·¯å½’å¹¶ï¼Œæ¯é€‰å‡ºä¸€ä¸ªå…ƒç´ éœ€è¦å¯¹æ¯”å…³é”®å­— m-1 æ¬¡</font>

![](pictures/å½’å¹¶æ’åº.png)

```c++
#include <iostream>
#define MaxSize 100

int *B = (int *)malloc(MaxSize * sizeof(int)); // è¾…åŠ©æ•°ç»„B

// A[low...mid] A[mid+1...high]å„è‡ªæœ‰åºï¼Œå°†ä¸¤éƒ¨åˆ†å½’å¹¶
void Merge(int A[], int low, int mid, int high) {
  int i, j, k;
  for (k = low; k <= high; k++)
    B[k] = A[k]; // å°†Aä¸­æ‰€æœ‰å…ƒç´ å¤åˆ¶åˆ°Bä¸­
  for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) {
    if (B[i] <= B[j])
      A[k] = B[i++]; // å°†è¾ƒå°å€¼å¤åˆ¶åˆ°Aä¸­
    else
      A[k] = B[j++];
  }
  while (i <= mid)
    A[k++] = B[i++];
  while (j <= high)
    A[k++] = B[j++];
}

void MergeSort(int A[], int low, int high) {
  if (low < high) {
    int mid = (low + high) / 2;  // ä»ä¸­é—´åˆ’åˆ†
    MergeSort(A, low, mid);      // å¯¹å·¦åŠéƒ¨åˆ†å½’å¹¶æ’åº
    MergeSort(A, mid + 1, high); // å¯¹å³åŠéƒ¨åˆ†å½’å¹¶æ’åº
    Merge(A, low, mid, high);    // å½’å¹¶
  }
}
```

### 8.4.2 åŸºæ•°æ’åºâ€”â€”ç¨³å®š
æ“…é•¿è§£å†³çš„é—®é¢˜ï¼š
1. æ•°æ®å…ƒç´ çš„å…³é”®å­—å¯ä»¥æ–¹ä¾¿åœ°æ‹†åˆ†ä¸º d ç»„ï¼Œä¸” d è¾ƒå°
2. æ¯ç»„å…³é”®å­—çš„å–å€¼èŒƒå›´ä¸å¤§ï¼Œå³ r è¾ƒå°
3. æ•°æ®å…ƒç´ ä¸ªæ•° n è¾ƒå¤§


# ç¬¬ä¹ç« â€”â€”ç®—æ³•

## 9.1 åˆ†æ²»æ³•

æ—¶é—´å¤æ‚åº¦çš„è®¡ç®—:è¡¨ç¤ºæŠŠè§„æ¨¡ä¸º $n$ çš„é—®é¢˜åˆ†æˆ $k$ ä¸ªè§„æ¨¡ä¸º $\frac{n}{m}$ çš„é—®é¢˜

$$
T_n= \left\{ 
\begin{array}{rl}
O(1) & ,n=1 \\
kT(\frac{n}{m})+O(f(n)) &,n>1
\end{array} \right.
$$

è®¡ç®—æ­¥éª¤:
â‘  $ä»¤ \frac{n}{m^x}=1, è§£å‡º x=\log_{m}{n }$
â‘¡ $ä»¤ T(n)=O(k^x+x*f(n)), å–æœ€é«˜æ¬¡å¹‚$

ä¸¾ä¾‹:
$$
T_n= \left\{ 
\begin{array}{rl}
O(1) & ,n=1 \\
4T(\frac{n}{2})+O(n) &,n>1
\end{array} \right.
$$

â‘  $ä»¤ \frac{n}{2^x}=1, è§£å‡º x=\log_{2}{n}$
â‘¡ $ä»¤ T(n)=O(k^x+x*f(n))=O(4^{\log_{2}{n}}+n\log_{2}{n})=O(n^2+n\log_{2}{n})=O(n^2)$

1. æŠ˜åŠæŸ¥æ‰¾

---

> å¤§æ•´æ•°çš„ä¹˜æ³•: æœ‰Xã€Yæ˜¯nä½äºŒè¿›åˆ¶æ•°ï¼Œç°è®¡ç®—Xã€Yçš„ä¹˜ç§¯
> ç®—æ³•æ€è·¯: æŠŠXã€Yå„æ‹†æˆä¸€åŠï¼Œè¿›è¡Œä¸€åŠä¸€åŠçš„ç›¸ä¹˜å¾— $XY=(A*2^{\frac{n}{2}}+B)(C*2^{\frac{n}{2}}+D)=AC*2^n+(AD+BC)*2^{\frac{n}{2}}+BD$
> 4æ¬¡n/2ä½ä¹˜æ³•ï¼Œ3æ¬¡ä¸è¶…è¿‡2nä½çš„åŠ æ³•ã€‚

$$
T_n= \left\{ 
\begin{array}{rl}
O(1) & ,n=1 \\
4T(\frac{n}{2})+O(n) &,n>1
\end{array} \right.
$$

> æ—¶é—´å¤æ‚åº¦ $O(n^2)$ ç©ºé—´å¤æ‚åº¦ $O(n)$

---

> çŸ©é˜µç›¸ä¹˜â€”â€”æœ‰Aã€Bæ˜¯né˜¶æ–¹é˜µï¼Œç°è®¡ç®—çŸ©é˜µAã€Bçš„ä¹˜ç§¯
> ç®—æ³•æ€è·¯: æŠŠAã€Bå„æ‹†æˆå››ç“£å­çŸ©é˜µï¼Œè¿›è¡Œå­çŸ©é˜µçš„ç›¸ä¹˜, 8æ¬¡n/2ä½ä¹˜æ³•, 4æ¬¡åŠ æ³•

$$
T_n= \left\{ 
\begin{array}{rl}
O(1) & ,n=1 \\
8T(\frac{n}{2})+O(n^2) &,n>1
\end{array} \right.
$$

> æ—¶é—´å¤æ‚åº¦ $O(n^3)$ ç©ºé—´å¤æ‚åº¦ $O(n^2)$

---

> æ£‹ç›˜è¦†ç›–ç®—æ³•
> 1. å°†æ£‹ç›˜å››ç­‰åˆ†
> 2. æŠŠå½“å‰æ£‹ç›˜é è¿‘åˆ†å‰²çº¿æœ€ä¸­é—´çš„ä½ç½®ï¼Œå¹¶ä¸”è¯¥æ£‹ç›˜ä¸­æ²¡æœ‰ç‰¹æ®Šç‚¹ï¼Œç”¨ä¸€ä¸ªLå½¢éª¨ç‰Œè¦†ç›–
> 3. é‡å¤ä¸Šè¿°æ­¥éª¤

$$
T_n= \left\{ 
\begin{array}{rl}
O(1) & ,n=1 \\
4T(n-1)+O(1) &,n>1
\end{array} \right.
$$

> 4. æ—¶é—´å¤æ‚åº¦ $O(4^n)$ ç©ºé—´å¤æ‚åº¦ $O(n^2)$

---

1. åˆå¹¶æ’åº
2. å¿«é€Ÿæ’åº
3. çº¿æ€§æ—¶é—´é€‰æ‹©: ç»™å®šä¸€æ•°ç»„Aå’Œä¸€ä¸ªæ•´æ•°kï¼Œæ‰¾å‡ºè¿™nä¸ªå…ƒç´ ä¸­ç¬¬kå°çš„å…ƒç´ 


```c++
#include <iostream>
#include <vector>

using namespace std;

/**
 * æ£‹ç›˜è¦†ç›–ç®—æ³•
 * Recursively covers a chessboard with L-shaped tiles.
 *
 * @param board: æ£‹ç›˜
 * @param tr: æ£‹ç›˜å·¦ä¸Šè§’æ–¹æ ¼çš„è¡Œç´¢å¼•
 * @param tc: æ£‹ç›˜å·¦ä¸Šè§’æ–¹æ ¼çš„åˆ—ç´¢å¼•
 * @param dr: ç‰¹æ®Šæ–¹æ ¼çš„è¡Œç´¢å¼•
 * @param dc: ç‰¹æ®Šæ–¹æ ¼çš„åˆ—ç´¢å¼•
 * @param size: æ£‹ç›˜çš„å¤§å°
 * @param tile: å½“å‰è¦ä½¿ç”¨çš„Lå‹éª¨ç‰Œç¼–å·
 *
 * @throws None.
 */
void chessboard_cover(vector<vector<int>> &board, int tr, int tc, int dr,
                      int dc, int size, int &tile) {
  if (size == 1) {
    return;
  }

  int t = tile++;
  int s = size / 2; // åˆ†å‰²æ£‹ç›˜

  // è¦†ç›–å·¦ä¸Šè§’å­æ£‹ç›˜
  if (dr < tr + s && dc < tc + s) {
    chessboard_cover(board, tr, tc, dr, dc, s, tile);
  } else {
    board[tr + s - 1][tc + s - 1] = t; // ç”¨tå·Lå‹éª¨ç‰Œè¦†ç›–å³ä¸‹è§’
    chessboard_cover(board, tr, tc, tr + s - 1, tc + s - 1, s, tile);
  }

  // è¦†ç›–å³ä¸Šè§’å­æ£‹ç›˜
  if (dr < tr + s && dc >= tc + s) {
    chessboard_cover(board, tr, tc + s, dr, dc, s, tile);
  } else {
    board[tr + s - 1][tc + s] = t; // ç”¨tå·Lå‹éª¨ç‰Œè¦†ç›–å·¦ä¸‹è§’
    chessboard_cover(board, tr, tc + s, tr + s - 1, tc + s, s, tile);
  }

  // è¦†ç›–å·¦ä¸‹è§’å­æ£‹ç›˜
  if (dr >= tr + s && dc < tc + s) {
    chessboard_cover(board, tr + s, tc, dr, dc, s, tile);
  } else {
    board[tr + s][tc + s - 1] = t; // ç”¨tå·Lå‹éª¨ç‰Œè¦†ç›–å³ä¸Šè§’
    chessboard_cover(board, tr + s, tc, tr + s, tc + s - 1, s, tile);
  }

  // è¦†ç›–å³ä¸‹è§’å­æ£‹ç›˜
  if (dr >= tr + s && dc >= tc + s) {
    chessboard_cover(board, tr + s, tc + s, dr, dc, s, tile);
  } else {
    board[tr + s][tc + s] = t; // ç”¨tå·Lå‹éª¨ç‰Œè¦†ç›–å·¦ä¸Šè§’
    chessboard_cover(board, tr + s, tc + s, tr + s, tc + s, s, tile);
  }
}

int main() {
  const int SIZE = 4;                                    // æ£‹ç›˜å¤§å°ä¸º4x4
  vector<vector<int>> board(SIZE, vector<int>(SIZE, 0)); // åˆ›å»º4x4æ£‹ç›˜
  int tile = 1; // Lå‹éª¨ç‰Œçš„èµ·å§‹ç¼–å·

  // å‡è®¾ç‰¹æ®Šæ–¹æ ¼åœ¨(1, 1)ä½ç½®ï¼Œæ ‡è®°ä¸º-1
  int special_row = 1, special_col = 1;
  board[special_row][special_col] = -1;

  // è°ƒç”¨å‡½æ•°è¦†ç›–æ£‹ç›˜
  chessboard_cover(board, 0, 0, special_row, special_col, SIZE, tile);

  // æ‰“å°æ£‹ç›˜
  for (const auto &row : board) {
    for (int val : row) {
      cout << val << " ";
    }
    cout << endl;
  }

  return 0;
}
```

```c++
#include <iostream>
#define M 100
using namespace std;

int a[M] = {6, 7, 5, 2, 5, 8, 3, 5, 1};
int n = 9;

/**
 * çº¿æ€§æ—¶é—´é€‰æ‹©
 * Partitions an array segment by selecting a random
 * pivot element and reorders so that elements less
 * than pivot are on the left and others on the right.
 *
 * @param left The starting index of the segment.
 * @param right The ending index of the segment.
 *
 * @return The index of the pivot element after
 *         partitioning.
 */
int RandomizedPatition(int left, int right) {
  srand((unsigned)time(NULL));
  int t = rand() % (right - left) + left;

  swap(a[t], a[left]); // éšæœºå…ƒç´ ä½œä¸ºæ ‡å‡†

  int flag = a[left];

  while (left < right) {
    while (left < right && a[right] >= flag)
      right--;
    if (left < right) {
      swap(a[right], a[left]);
    }
    while (left < right && a[left] <= flag)
      left++;
    if (left < right) {
      swap(a[right], a[left]);
    }
  }

  a[left] = flag;
  return left;
}

/**
 * Selects the k-th smallest element from an array using a randomized 
 * selection algorithm, which is an expected O(n) on average.
 *
 * @param left The starting index of the array to consider.
 * @param right The ending index of the array to consider.
 * @param k The rank of the element to find.
 *
 * @return The k-th smallest element in the array.
 */
int RandomizedSelect(int left, int right, int k) {
  if (left == right)
    return a[right];
  int p = RandomizedPatition(left, right); // å°†æ•°ç»„åˆ†æˆä¸¤éƒ¨åˆ†
  int s = p - left + 1;
  if (k <= s)
    return RandomizedSelect(left, p, k);
  else {
    return RandomizedSelect(p + 1, right, k - s);
  }
}

int main() {
  cout << RandomizedSelect(0, n - 1, 8);
  getchar();
  return 0;
}
```

## 9.2 åŠ¨æ€è§„åˆ’

çŸ©é˜µè¿ä¹˜

$$
m[i][j]= \left\{ 
\begin{array}{rl}
0 & ,i=j \\
\min\limits_{i \leqslant k \leqslant j}\{m[i][k]+m[i+1][j]+p_{i-1}p_{k}p_{j}\} &,i<j
\end{array} \right.
$$

```c++
#include <iostream>
#include <limits>
#include <vector>

// Helper function to print the optimal parenthesization.
void printOptimalParens(const std::vector<std::vector<int>> &s, int i, int j) {
  if (i == j) {
    std::cout << "A" << i;
  } else {
    std::cout << "(";
    printOptimalParens(s, i, s[i][j]);
    printOptimalParens(s, s[i][j] + 1, j);
    std::cout << ")";
  }
}

// Function to find the minimum number of multiplications needed to multiply a
// chain of matrices.
void matrixChainOrder(const std::vector<int> &p) {
  int n = p.size() - 1;
  std::vector<std::vector<int>> m(n + 1, std::vector<int>(n + 1, 0));
  std::vector<std::vector<int>> s(n + 1, std::vector<int>(n + 1, 0));

  // Cost is zero when multiplying one matrix.
  for (int i = 1; i <= n; i++) {
    m[i][i] = 0;
  }

  // L is chain length.
  for (int L = 2; L <= n; L++) {
    for (int i = 1; i <= n - L + 1; i++) {
      int j = i + L - 1;
      m[i][j] = std::numeric_limits<int>::max();
      for (int k = i; k <= j - 1; k++) {
        // q = cost/scalar multiplications
        int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
        if (q < m[i][j]) {
          m[i][j] = q;
          s[i][j] = k; // Save the index where we split the product.
        }
      }
    }
  }

  std::cout << "Minimum number of multiplications is " << m[1][n] << std::endl;
  std::cout << "Optimal Parenthesization is: ";
  printOptimalParens(s, 1, n);
  std::cout << std::endl;
}

```

æœ€é•¿å…¬å…±å­åºåˆ—

$$
c[i][j]è®°å½•åºåˆ— X_i å’Œ Y_j çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ \\
c[i][j]= \left\{ 
\begin{array}{rl}
0 & i=0æˆ–j=0 \\
c[i-1][j-1]+1 & i>0, j>0; X_i=Y_i \\
\max\{c[i-1][j],c[i][j-1]\} & i>0, j>0; X_i!=Y_i
\end{array} \right.
$$

```c++
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<std::vector<int>> lcs_length(const std::string &X, const std::string &Y) {
    int m = X.size();
    int n = Y.size();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X[i - 1] == Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp;
}

std::string lcs_construct(const std::vector<std::vector<int>> &dp, const std::string &X, const std::string &Y) {
    std::string lcs;
    int i = X.size();
    int j = Y.size();

    while (i > 0 && j > 0) {
        if (X[i - 1] == Y[j - 1]) {
            lcs.push_back(X[i - 1]);
            i--;
            j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }

    std::reverse(lcs.begin(), lcs.end());
    return lcs;
}

int main() {
    std::string X = "ABCBDAB";
    std::string Y = "BDCABC";

    std::vector<std::vector<int>> dp = lcs_length(X, Y);
    std::string lcs = lcs_construct(dp, X, Y);

    std::cout << "The Longest Common Subsequence of " << X << " and " << Y << " is: " << lcs << std::endl;

    return 0;
}
```

æœ€é•¿ä¸Šå‡å­åºåˆ—: ç»™å®šä¸€ä¸ªåºåˆ— $A=\{x_0,x_1,\cdots,x_n\}$

æ±‚Açš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ï¼Œå­åºåˆ—ä¸è¦æ±‚è¿ç»­
$$
A[\quad] = [1, 7, 3, 5, 9, 4, 8] \\
è®¾: dp[i]ä»£è¡¨ä»¥a[i]ç»“å°¾çš„æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦\\
é€’å½’å…¬å¼: dp[i]=\max(dp[i],dp[j]+1)(0 \leqslant j < i, a[j]<a[i]) \\
è¾¹ç•Œå¤„ç†: dp[i]=1 (0 \leqslant j < n) \\
è§£é‡Š: åœ¨ 0-j èŒƒå›´å†…, æ‰¾åˆ°a[i]å‰é¢æ¯”a[i]å°çš„å…ƒç´ , å–å…¶å¯¹åº”å…ƒç´ ä¸­æœ€å¤§çš„dpå€¼+1, å°±æ˜¯dp[i]çš„å€¼, é€è¡Œæ›´æ–°ï¼Œç›´åˆ°æœ€å
$$

```c++
#include <iostream>
#include <vector>
#include <algorithm>

int longest_increasing_subsequence(const std::vector<int>& sequence) {
    if (sequence.empty()) return 0;

    std::vector<int> dp(sequence.size(), 1); // åˆå§‹åŒ– dp æ•°ç»„ï¼Œæ‰€æœ‰å…ƒç´ å€¼ä¸º 1
    int max_length = 1; // æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦è‡³å°‘ä¸º 1

    for (size_t i = 1; i < sequence.size(); ++i) {
        for (size_t j = 0; j < i; ++j) {
            // å¦‚æœå½“å‰å…ƒç´ å¤§äºä¹‹å‰çš„æŸä¸ªå…ƒç´ ï¼Œå¹¶ä¸”ä¹‹å‰å…ƒç´ çš„ LIS åŠ  1 å¤§äºå½“å‰å…ƒç´ çš„ LIS
            if (sequence[i] > sequence[j]) {
                dp[i] = std::max(dp[i], dp[j] + 1);
            }
        }
        max_length = std::max(max_length, dp[i]); // æ›´æ–°æœ€é•¿ä¸Šå‡å­åºåˆ—çš„é•¿åº¦
    }

    return max_length;
}

int main() {
    std::vector<int> sequence = {10, 22, 9, 33, 21, 50, 41, 60, 80};
    int lis_length = longest_increasing_subsequence(sequence);

    std::cout << "The length of the Longest Increasing Subsequence is: " << lis_length << std::endl;

    return 0;
}
```

æœ€é•¿å…¬å…±è¿ç»­å­åºåˆ—: æœ€é•¿å…¬å…±å­åºåˆ—æ”¹ç‰ˆ

æœ€å¤§å­æ®µå’Œ
```c++
int max_subarray_sum(const std::vector<int>& nums) {
    if (nums.empty()) return 0;

    int max_sum = nums[0]; // åˆå§‹åŒ–æœ€å¤§å’Œä¸ºæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    int current_sum = nums[0]; // åˆå§‹åŒ–å½“å‰å’Œä¸ºæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 

    for (size_t i = 1; i < nums.size(); ++i) {
        // æ›´æ–°å½“å‰å’Œä¸ºå½“å‰å…ƒç´ ä¸ä¹‹å‰å½“å‰å’Œçš„è¾ƒå¤§è€…
        current_sum = std::max(nums[i], current_sum + nums[i]);
        // æ›´æ–°æœ€å¤§å’Œ
        max_sum = std::max(max_sum, current_sum);
    }

    return max_sum;
}
```

0-1 èƒŒåŒ…é—®é¢˜

è®¾ $m[i][j]$ è¡¨ç¤ºèƒŒåŒ…å®¹é‡ä¸º $j$ æ—¶ï¼Œè€ƒè™‘è£…å‰ $i$ ä¸ªç‰©å“æ—¶çš„æœ€å¤§ä»·å€¼

$$
m[i][j]= \left\{ 
\begin{array}{rl}
0 & i=0æˆ–j=0 \\
m[i-1][j] & w[i]>j \\
\max\{m[i-1][j],m[i][j-w[i]]+v[i]\} & w[i] \leqslant j
\end{array} \right.
$$

è§£é‡Š:  
- i=0 å¯é€‰çš„ç‰©å“ä¸º0
- j=0 èƒŒåŒ…å®¹é‡ä¸º0
- ç”±äºç¬¬iä¸ªç‰©å“å¤ªé‡äº†è£…ä¸ä¸‹, $m[i-1][j]$ å®¹é‡ä¸å˜, åªè€ƒè™‘è£…å‰ $i-1$ ä¸ªç‰©å“
- å€˜è‹¥ç¬¬iä¸ªç‰©å“ä¸é‡, $m[i][j-w[i]]+v[i]$ è¡¨ç¤ºæŠŠç¬¬ $i$ ä¸ªç‰©å“è£…ä¸‹æ¥çš„ä»·å€¼

```c++
// Returns the maximum value that can be put in a knapsack of capacity W
int knapSack(int W, vector<int>& wt, vector<int>& val, int n) {
    // Create a vector to store the maximum value that can be obtained for each weight
    vector<vector<int>> dp(n + 1, vector<int>(W + 1));

    // Build table dp[][] in bottom up manner
    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            if (i == 0 || w == 0) {
                dp[i][w] = 0; // Base case: no items or no capacity
            } else if (wt[i - 1] <= w) {
                // Item i can be included if it does not exceed the current weight w
                dp[i][w] = max(val[i - 1] + dp[i - 1][w - wt[i - 1]], dp[i - 1][w]);
            } else {
                // Item i cannot be included if it exceeds the current weight w
                dp[i][w] = dp[i - 1][w];
            }
        }
    }

    return dp[n][W]; // Return the maximum value that can be obtained for the given knapsack capacity
}
```

## 9.3 è´ªå¿ƒ

1. å“ˆå¤«æ›¼ç¼–ç 
2. æœ€å°ç”Ÿæˆæ ‘: Prim ç®—æ³• Kruskal ç®—æ³•
3. å•æºæœ€çŸ­è·¯å¾„: Dijkstra ç®—æ³•

```c++
#include <iostream>
using namespace std;

#define MaxVertexNum 10 // é¡¶ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
#define INF 1000        // å®å®šä¹‰ å¸¸é‡ â€œæ— ç©·â€

typedef char VertexType; // é¡¶ç‚¹çš„æ•°æ®ç±»å‹
typedef int EdgeType;    // å¸¦æƒå›¾ä¸­è¾¹ä¸Šæƒå€¼çš„æ•°æ®ç±»å‹

typedef struct {
  VertexType Vex[MaxVertexNum];              // é¡¶ç‚¹è¡¨
  EdgeType Edge[MaxVertexNum][MaxVertexNum]; // é‚»æ¥çŸ©é˜µï¼Œè¾¹çš„æƒå€¼è¡¨
  int vexnum, arcnum; // å›¾çš„å½“å‰é¡¶ç‚¹æ•°å’Œè¾¹æ•°/å¼§æ•°
} MGraph;

// Prim ç®—æ³•
void Prim(MGraph G, int currentVex, int &sum) {
  int set[MaxVertexNum];     // è®°å½•æŸ“è‰²çš„é¡¶ç‚¹
  int lowcost[MaxVertexNum]; // è®°å½•æŸ“è‰²é¡¶ç‚¹çš„æœ€å°æƒå€¼

  for (int i = 0; i < G.vexnum; i++) {
    set[i] = 0;
    lowcost[i] = G.Edge[currentVex][i];
  }

  set[currentVex] = 1;

  for (int i = 0; i < G.vexnum - 1; i++) {
    int min = INF; // è®°å½•æœ€å°æƒå€¼
    // æ‰¾åˆ°å½“å‰æœ€å°æƒå€¼çš„é¡¶ç‚¹
    for (int j = 0; j < G.vexnum; j++) {
      if (set[j] == 0 && lowcost[j] < min) {
        min = lowcost[j];
        currentVex = j;
      }
    }
    set[currentVex] = 1;
    sum += min;

    // æ›´æ–°lowcost
    for (int j = 0; j < G.vexnum; j++) {
      if (set[j] == 0 && G.Edge[currentVex][j] < lowcost[j]) {
        lowcost[j] = G.Edge[currentVex][j];
      }
    }
  }
}

int main() {
  MGraph G;
  const int size = 5;
  G.vexnum = size;
  EdgeType A[size][size] = {{INF, 5, 1, 2, INF},
                            {5, INF, 3, INF, 4},
                            {1, 3, INF, 6, 2},
                            {2, INF, 6, INF, 3},
                            {INF, 4, 2, 3, INF}};

  for (int i = 0; i < size; ++i) {
    for (int j = 0; j < size; ++j) {
      G.Edge[i][j] = A[i][j];
    }
  }

  int sum;
  Prim(G, 0, sum);
  cout << sum << endl;

  return 0;
}
```

