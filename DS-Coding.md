- [ç¬¬ä¸€ç« â€”â€”ç»ªè®º](#ç¬¬ä¸€ç« ç»ªè®º)
- [ç¬¬äºŒç« â€”â€”çº¿æ€§è¡¨](#ç¬¬äºŒç« çº¿æ€§è¡¨)
  - [2.1 çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ](#21-çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ)
  - [2.2 çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤ºã€é‡è¦ã€‘](#22-çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤ºé‡è¦)
  - [2.3 çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤ºã€é‡è¦ã€‘](#23-çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤ºé‡è¦)
    - [2.3.1 å•é“¾è¡¨](#231-å•é“¾è¡¨)
    - [2.3.2 åŒé“¾è¡¨](#232-åŒé“¾è¡¨)
- [ç¬¬ä¸‰ç« â€”â€”æ ˆã€é˜Ÿåˆ—å’Œæ•°ç»„](#ç¬¬ä¸‰ç« æ ˆé˜Ÿåˆ—å’Œæ•°ç»„)
  - [3.1 æ ˆ](#31-æ ˆ)
    - [3.1.1 æ ˆçš„åŸºæœ¬æ¦‚å¿µ](#311-æ ˆçš„åŸºæœ¬æ¦‚å¿µ)
    - [3.1.2 æ ˆçš„é¡ºåºå­˜å‚¨ï¼ˆé¡ºåºæ ˆï¼‰ã€é‡è¦ã€‘](#312-æ ˆçš„é¡ºåºå­˜å‚¨é¡ºåºæ ˆé‡è¦)
      - [å…±äº«æ ˆ](#å…±äº«æ ˆ)
    - [3.1.3 æ ˆçš„é“¾å¼å­˜å‚¨ï¼ˆé“¾å¼æ ˆï¼‰ã€é‡è¦ã€‘](#313-æ ˆçš„é“¾å¼å­˜å‚¨é“¾å¼æ ˆé‡è¦)
    - [3.1.4 æ ˆçš„åº”ç”¨](#314-æ ˆçš„åº”ç”¨)
  - [3.2 é˜Ÿåˆ—](#32-é˜Ÿåˆ—)
    - [3.2.1 é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„](#321-é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„)
    - [3.2.2 é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨ã€é‡è¦ã€‘](#322-é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨é‡è¦)
    - [3.2.3 é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨ã€é‡è¦ã€‘](#323-é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨é‡è¦)
    - [3.2.4 åŒç«¯é˜Ÿåˆ—ï¼ˆä¸å—é™å’Œå—é™ï¼‰](#324-åŒç«¯é˜Ÿåˆ—ä¸å—é™å’Œå—é™)
    - [3.2.5 é˜Ÿåˆ—çš„åº”ç”¨](#325-é˜Ÿåˆ—çš„åº”ç”¨)
  - [3.3 æ•°ç»„å’Œç‰¹æ®ŠçŸ©é˜µ](#33-æ•°ç»„å’Œç‰¹æ®ŠçŸ©é˜µ)
- [ç¬¬å››ç« â€”â€”ä¸²ã€ä¸è€ƒï¼Œå¯ç•¥è¿‡ã€‘](#ç¬¬å››ç« ä¸²ä¸è€ƒå¯ç•¥è¿‡)
  - [4.1 ä¸²çš„å®šä¹‰å’Œå®ç°](#41-ä¸²çš„å®šä¹‰å’Œå®ç°)
    - [ä¸²çš„é¡ºåºå­˜å‚¨ã€é‡è¦ã€‘](#ä¸²çš„é¡ºåºå­˜å‚¨é‡è¦)
    - [ä¸²çš„é“¾å¼å­˜å‚¨ã€é‡è¦ã€‘](#ä¸²çš„é“¾å¼å­˜å‚¨é‡è¦)
  - [4.2 ä¸²çš„æ¨¡å¼åŒ¹é…](#42-ä¸²çš„æ¨¡å¼åŒ¹é…)
    - [4.2.1 æœ´ç´ æ¨¡å¼åŒ¹é…ï¼ˆå®šä½æ“ä½œï¼‰](#421-æœ´ç´ æ¨¡å¼åŒ¹é…å®šä½æ“ä½œ)
    - [4.2.2 KMP](#422-kmp)
    - [4.2.3 KMPç®—æ³•ä¼˜åŒ–â€”â€”nextvalæ•°ç»„](#423-kmpç®—æ³•ä¼˜åŒ–nextvalæ•°ç»„)
- [ç¬¬äº”ç« â€”â€”æ ‘ä¸äºŒå‰æ ‘](#ç¬¬äº”ç« æ ‘ä¸äºŒå‰æ ‘)
  - [5.1 æ ‘çš„åŸºæœ¬æ¦‚å¿µ](#51-æ ‘çš„åŸºæœ¬æ¦‚å¿µ)
  - [5.2 äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ](#52-äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ)
    - [5.2.1 äºŒå‰æ ‘çš„å®šä¹‰åŠå…¶ä¸»è¦ç‰¹å¾](#521-äºŒå‰æ ‘çš„å®šä¹‰åŠå…¶ä¸»è¦ç‰¹å¾)
    - [5.2.2 äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„ã€éå†ã€é‡è¦ã€‘](#522-äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„éå†é‡è¦)
  - [5.3 çº¿ç´¢äºŒå‰æ ‘](#53-çº¿ç´¢äºŒå‰æ ‘)
    - [5.3.1 çº¿ç´¢åŒ–äºŒå‰æ ‘](#531-çº¿ç´¢åŒ–äºŒå‰æ ‘)
    - [5.3.2 çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±ï¼ˆåç»§ï¼‰\[æ²¡æ•´ç†å®Œæ•´\]](#532-çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±åç»§æ²¡æ•´ç†å®Œæ•´)
  - [5.4 æ ‘ã€æ£®æ—](#54-æ ‘æ£®æ—)
    - [5.4.1 æ ‘çš„å­˜å‚¨ç»“æ„](#541-æ ‘çš„å­˜å‚¨ç»“æ„)
  - [5.5 æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨](#55-æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨)
    - [5.5.1 å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç ](#551-å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç )
- [ç¬¬å…­ç« â€”â€”å›¾](#ç¬¬å…­ç« å›¾)
  - [6.1 å›¾çš„åŸºæœ¬æ¦‚å¿µ](#61-å›¾çš„åŸºæœ¬æ¦‚å¿µ)
  - [6.2 å›¾çš„å­˜å‚¨åŠåŸºæœ¬æ“ä½œ](#62-å›¾çš„å­˜å‚¨åŠåŸºæœ¬æ“ä½œ)
    - [6.2.1 é‚»æ¥çŸ©é˜µæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰](#621-é‚»æ¥çŸ©é˜µæ³•é¡ºåºå­˜å‚¨)
    - [6.2.2 é‚»æ¥è¡¨æ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰](#622-é‚»æ¥è¡¨æ³•é¡ºåºé“¾å¼å­˜å‚¨)
  - [6.3 å›¾çš„éå†](#63-å›¾çš„éå†)
    - [6.3.1 BFS å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•](#631-bfs-å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•)
    - [6.3.2 DFS æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•](#632-dfs-æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•)
  - [6.4åº”ç”¨](#64åº”ç”¨)
    - [6.4.1 æœ€å°ç”Ÿæˆæ ‘](#641-æœ€å°ç”Ÿæˆæ ‘)
    - [6.4.2 æœ€çŸ­è·¯å¾„](#642-æœ€çŸ­è·¯å¾„)
    - [6.4.3 æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰æè¿°è¡¨è¾¾å¼](#643-æœ‰å‘æ— ç¯å›¾dagæè¿°è¡¨è¾¾å¼)
    - [6.4.4 æ‹“æ‰‘æ’åº(é€†æ‹“æ‰‘æ’åº)](#644-æ‹“æ‰‘æ’åºé€†æ‹“æ‰‘æ’åº)
    - [6.4.5 å…³é”®è·¯å¾„](#645-å…³é”®è·¯å¾„)
- [ç¬¬ä¸ƒç« â€”â€”æŸ¥æ‰¾](#ç¬¬ä¸ƒç« æŸ¥æ‰¾)
  - [7.1 æŸ¥æ‰¾çš„åŸºæœ¬æ¦‚å¿µ](#71-æŸ¥æ‰¾çš„åŸºæœ¬æ¦‚å¿µ)
  - [7.2 é¡ºåºã€æŠ˜åŠã€åˆ†å—](#72-é¡ºåºæŠ˜åŠåˆ†å—)
    - [7.2.1 é¡ºåºæŸ¥æ‰¾](#721-é¡ºåºæŸ¥æ‰¾)
    - [7.2.2 æŠ˜åŠæŸ¥æ‰¾](#722-æŠ˜åŠæŸ¥æ‰¾)
    - [7.2.3 åˆ†å—æŸ¥æ‰¾](#723-åˆ†å—æŸ¥æ‰¾)
  - [7.3 æ ‘å‹æŸ¥æ‰¾](#73-æ ‘å‹æŸ¥æ‰¾)
    - [7.3.1 äºŒå‰æ’åºæ ‘ï¼ˆäºŒå‰æœç´¢æ ‘BSTï¼‰](#731-äºŒå‰æ’åºæ ‘äºŒå‰æœç´¢æ ‘bst)
    - [7.3.2 å¹³è¡¡äºŒå‰æ ‘](#732-å¹³è¡¡äºŒå‰æ ‘)
  - [7.4 Bæ ‘å’ŒB+æ ‘](#74-bæ ‘å’Œbæ ‘)
  - [7.5 æ•£åˆ—è¡¨ï¼ˆå“ˆå¸Œè¡¨ï¼‰](#75-æ•£åˆ—è¡¨å“ˆå¸Œè¡¨)
- [ç¬¬å…«ç« â€”â€”æ’åº](#ç¬¬å…«ç« æ’åº)
  - [8.1 æ’å…¥æ’åº](#81-æ’å…¥æ’åº)
  - [8.2 äº¤æ¢æ’åº](#82-äº¤æ¢æ’åº)
  - [8.3 é€‰æ‹©æ’åº](#83-é€‰æ‹©æ’åº)
  - [8.4 å½’å¹¶æ’åºå’ŒåŸºæ•°æ’åº](#84-å½’å¹¶æ’åºå’ŒåŸºæ•°æ’åº)
    - [8.4.1 å½’å¹¶æ’åº](#841-å½’å¹¶æ’åº)
    - [8.4.2 åŸºæ•°æ’åº](#842-åŸºæ•°æ’åº)
  - [8.5 å†…éƒ¨æ’åºç®—æ³•çš„æ¯”è¾ƒ](#85-å†…éƒ¨æ’åºç®—æ³•çš„æ¯”è¾ƒ)

# ç¬¬ä¸€ç« â€”â€”ç»ªè®º

# ç¬¬äºŒç« â€”â€”çº¿æ€§è¡¨
## 2.1 çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ



## 2.2 çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤ºã€é‡è¦ã€‘
- é™æ€åˆ†é…
  - data[MaxSize]
  
  - åŸºæœ¬æ“ä½œï¼šæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾
```c++
// é™æ€æ•°ç»„æ’å…¥
bool ListInsert(SqList &L, int i, int e) {
  if (i < 1 || i > L.length + 1)
    return false;
  if (L.length >= MaxSize)
    return false;
  for (int j = L.length; j >= i; j--) {
    L.data[j] = L.data[j - 1];
  }                  // å°†ç¬¬iä¸ªå…ƒç´ åŠä¹‹åçš„å…ƒç´ åç§»
  L.data[i - 1] = e; // åœ¨ä½ç½®iå¤„æ”¾å…¥e
  L.length++;
  return true;
}

//é™æ€æ•°æ®åˆ é™¤
bool ListDelete(SqList &L, int i, int &deletedData) {
  if (i < 1 || i > L.length) // åˆ¤æ–­içš„èŒƒå›´æ˜¯å¦æœ‰æ•ˆ
    return false;
  deletedData = L.data[i - 1]; // å°†è¢«åˆ é™¤çš„å…ƒç´ èµ‹å€¼ç»™e
  for (int j = i; j < L.length; j++)
    L.data[j - 1] = L.data[j]; // å°†ç¬¬iä¸ªä½ç½®åçš„å…ƒç´ å‰ç§»
  L.length--;
  return true;
}

// æŒ‰ä½æŸ¥æ‰¾
int GetElem(SqList L, int i) { return L.data[i - 1]; }

// æŒ‰å€¼æŸ¥æ‰¾
int LocateElem(SqList L, int e) {
  for (int i = 0; i < L.length; i++) {
    if (L.data[i] == e)
      return i + 1;
  }
  return 0;
}
```

æ’å…¥æ“ä½œå¹³å‡æƒ…å†µï¼š

> å‡è®¾æ–°å…ƒç´ æ’å…¥åˆ°ä»»ä½•ä¸€ä¸ªä½ç½®çš„æ¦‚ç‡ç›¸åŒï¼Œå³$i=1,2,3,\cdots,length,length+1$çš„æ¦‚ç‡éƒ½æ˜¯$p=\frac{1}{n+1}$
>
> - i=1ï¼Œç§»åŠ¨nä¸ªæ•°ï¼Œå¾ªç¯næ¬¡ï¼›ã€æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦$O(n)$ã€‘
> - i=2ï¼Œç§»åŠ¨n-1ä¸ªæ•°ï¼Œå¾ªç¯n-1æ¬¡ï¼›
> - i=3ï¼Œç§»åŠ¨n-1ä¸ªæ•°ï¼Œå¾ªç¯n-2æ¬¡
> - â€¦â€¦
> - i=n+1æ—¶ï¼Œæ— éœ€ç§»åŠ¨æ•°ç»„ï¼Œå¾ªç¯0æ¬¡ã€æœ€å¥½æƒ…å†µæ—¶é—´å¤æ‚åº¦$O(1)$ã€‘
>
> å¹³å‡å¾ªç¯æ¬¡æ•°=$[n+(n-1)+(n-2)+\cdots+1+0]*\frac{1}{n+1}=\frac{(1+n)n}{2}\frac{1}{n+1}=\frac{n}{2}$
>
> å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$

åˆ é™¤æ“ä½œå¹³å‡æƒ…å†µï¼š

> å‡è®¾åˆ é™¤ä»»ä½•ä¸€ä¸ªä½ç½®å…ƒç´ çš„æ¦‚ç‡ç›¸åŒï¼Œå³$i=1,2,3,\cdots,length$çš„æ¦‚ç‡éƒ½æ˜¯$p=\frac{1}{n}$
>
> - i=1ï¼Œç§»åŠ¨n-1ä¸ªæ•°ï¼Œå¾ªç¯n-1æ¬¡ï¼›ã€æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦$O(n)$ã€‘
> - i=2ï¼Œç§»åŠ¨n-2ä¸ªæ•°ï¼Œå¾ªç¯n-2æ¬¡ï¼›
> - i=3ï¼Œç§»åŠ¨n-3ä¸ªæ•°ï¼Œå¾ªç¯n-3æ¬¡
> - â€¦â€¦
> - i=nï¼Œç§»åŠ¨0ä¸ªæ•°ï¼Œå¾ªç¯0æ¬¡ã€æœ€å¥½æƒ…å†µæ—¶é—´å¤æ‚åº¦$O(1)$ã€‘
>
> å¹³å‡å¾ªç¯æ¬¡æ•°=$[(n-1)+(n-2)+\cdots+1+0]*\frac{1}{n+1}=\frac{(n-1)n}{2}\frac{1}{n}=\frac{n-1}{2}$
>
> å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$

- åŠ¨æ€åˆ†é…

```c++
#define InitSize 10 // é¡ºåºè¡¨çš„åˆå§‹é•¿åº¦
typedef struct {
  int *data;   // æŒ‡ç¤ºåŠ¨æ€åˆ†é…æ•°ç»„çš„æŒ‡é’ˆ
  int MaxSize; // é¡ºåºè¡¨çš„æœ€å¤§å®¹é‡
  int length;  // é¡ºåºè¡¨çš„å½“å‰é•¿åº¦
} SeqList;     // é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰(åŠ¨æ€åˆ†é…æ–¹å¼)

void InitList(SeqList &L) {
  // ç”¨ malloc å‡½æ•°ç”³è¯·ä¸€ç‰‡è¿ç»­çš„å­˜å‚¨ç©ºé—´
  L.data = (int *)malloc(InitSize * sizeof(int));
  L.length = 0;
  L.MaxSize = InitSize;
}

// å¢åŠ åŠ¨æ€æ•°ç»„çš„é•¿åº¦
void IncreaseSize(SeqList &L, int len) {
  int *p = L.data;
  L.data = (int *)malloc((L.MaxSize + len) * sizeof(int));
  for (int i = 0; i < L.length; i++) {
    L.data[i] = p[i]; // å°†æ•°æ®å¤åˆ¶åˆ°æ–°åŒºåŸŸ
  }
  L.MaxSize = L.MaxSize + len; // é¡ºåºè¡¨æœ€å¤§é•¿åº¦å¢åŠ  len
  free(p);                     // é‡Šæ”¾åŸæ¥çš„å†…å­˜ç©ºé—´
}
```

## 2.3 çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤ºã€é‡è¦ã€‘

### 2.3.1 å•é“¾è¡¨
```c++
#include <iostream>
using namespace std;

typedef struct LNode { // å®šä¹‰å•é“¾è¡¨ç»“ç‚¹ç±»å‹
  int data;            // æ•°æ®åŸŸï¼ŒElemTypeä¸ºå¯ä¿®æ”¹çš„dataå±æ€§å€¼
  struct LNode *next;  // æŒ‡é’ˆåŸŸ
} LNode, *LinkList;

// åˆå§‹åŒ–ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨
bool initLinkList(LinkList &L) {
  L = (LNode *)malloc(sizeof(LNode));
  if (L == NULL) // å¦‚æœåˆå§‹å¤´ç»“ç‚¹å†…å­˜åˆ†é…å¤±è´¥,åˆ™è¿”å›false
    return false;
  L->next = NULL;
  return true;
}

// ä½¿ç”¨å¤´æ’æ³•å»ºç«‹å•é“¾è¡¨(å¸¦å¤´ç»“ç‚¹)
LinkList createList_Head(LinkList &L) {
  LNode *s;
  int x;
  L = (LinkList)malloc(sizeof(LNode)); // åˆ›å»ºå¤´ç»“ç‚¹
  L->next = NULL;                      // åˆå§‹ä¸ºç©ºé“¾è¡¨
  while (cin >> x) {
    s = (LNode *)malloc(sizeof(LNode));
    s->data = x;
    s->next = L->next;
    L->next = s;
  }
  // è¾“å…¥çš„å€¼ä¸æ˜¯æ•°å€¼å‹æ•°æ®ï¼Œè·³å‡ºç¨‹åº
  if (cin.fail()) {
    cout << "éæ³•è¾“å…¥ï¼Œåˆ›å»ºå•é“¾è¡¨ç»“æŸ" << std::endl;
  }
  return L;
}

// ä½¿ç”¨å°¾æ’æ³•å»ºç«‹å•é“¾è¡¨(å¸¦å¤´ç»“ç‚¹)
LinkList createList_Tail(LinkList &L) {
  L = (LinkList)malloc(sizeof(LNode));
  LNode *s, *r = L;
  int x;
  while (cin >> x) {
    s = (LNode *)malloc(sizeof(LNode));
    s->data = x;
    r->next = s;
    r = s;  // r æŒ‡å‘æ–°çš„è¡¨å°¾ç»“ç‚¹
  }
  r->next = NULL;  // å°¾æŒ‡é’ˆæŒ‡å‘ç©º
  // è¾“å…¥çš„å€¼ä¸æ˜¯æ•°å€¼å‹æ•°æ®ï¼Œè·³å‡ºç¨‹åº
  if (cin.fail()) {
    cout << "éæ³•è¾“å…¥ï¼Œåˆ›å»ºå•é“¾è¡¨ç»“æŸ" << std::endl;
  }
  return L;
}

// æŒ‰ä½æŸ¥æ‰¾ï¼Œä½¿ç”¨ ä¸‹æ ‡ è¿”å› è¯¥å•é“¾è¡¨ç»“ç‚¹(å¸¦å¤´ç»“ç‚¹)
LNode *GetElem(LinkList L, int i) {
  if (i < 0)
    return NULL;
  int j = 0;    // jè¡¨ç¤ºæŒ‡å‘çš„ç¬¬å‡ ä¸ªç»“ç‚¹
  LNode *p = L; // p æŒ‡å‘ L çš„å¤´ç»“ç‚¹(ä¸å¸¦æ•°æ®)
  while (p && j < i) {
    p = p->next;
    j++;
  }
  return p;
}

// æŒ‰å€¼æŸ¥æ‰¾ï¼Œä½¿ç”¨ å€¼data è¿”å› è¯¥ç‚¹é“¾è¡¨ç»“ç‚¹
LNode *LocateElem(LinkList L, int e) {
  LNode *p = L->next;
  while (p != NULL && p->data != e) {
    p = p->next;
  }
  return p;
}

// æŒ‰ä½ç½®é¡ºåºæ’å…¥(å¸¦å¤´ç»“ç‚¹),å·²çŸ¥è¦æ’å…¥çš„ä½ç½®ä¸æ–°æ’å…¥çš„ç»“ç‚¹
LinkList InsertElem(LinkList &L, LNode *s, int n) {
  LNode *p = GetElem(L, n - 1);
  s->next = p->next;
  p->next = s;
  return L;
}

// æŒ‰ä½åºåˆ é™¤ç»“ç‚¹(å¸¦å¤´ç»“ç‚¹),å·²çŸ¥è¦åˆ é™¤çš„ä½ç½®
bool DeleteElem(LinkList &L, int &e, int n) {
  LNode *p = GetElem(L, n - 1);
  LNode *q = p->next;
  e = q->data;
  p->next = q->next;
  free(q);
  return L;
}

// åæ’æ“ä½œï¼Œåœ¨ p ç»“ç‚¹ä¹‹åæ’å…¥å…ƒç´  e
bool InsertNextNode(LNode *p, int e) {
  if (p == NULL)
    return false;
  LNode *s = (LNode *)malloc(sizeof(LNode));
  if (s == NULL)
    return false; // æ–°ç»“ç‚¹ s å†…å­˜åˆ†é…å¤±è´¥
  s->data = e;
  s->next = p->next;
  p->next = s;
  return true;
}

// å‰æ’æ“ä½œï¼šåœ¨ p ç»“ç‚¹ä¹‹å‰æ’å…¥å…ƒç´  e
bool InsertPriorNode(LNode *p, int e) {
  if (p == NULL)
    return false;
  LNode *s = (LNode *)malloc(sizeof(LNode));
  if (s == NULL)
    return false; // æ–°ç»“ç‚¹ s å†…å­˜åˆ†é…å¤±è´¥
  s->next = p->next;
  p->next = s;
  s->data = p->data;
  p->data = e;
  return true;
}

// åˆ é™¤ç»“ç‚¹
bool DeleteNode(LNode *p) {
  if (p == NULL)
    return false;
  LNode *q = p->next;
  p->data = q->data;
  p->next = q->next;
  free(q);
  return true;
}

// æ±‚è¡¨çš„é•¿åº¦
int Length(LinkList L) {
  int len = 0;
  LNode *p = L->next;
  while (p != NULL) {
    p = p->next;
    len++;
  }
  return len;
}

int main() {
  LinkList L;
  initLinkList(L);
  createList_Head(L);
  cout << L;
  return 0;
}
```

### 2.3.2 åŒé“¾è¡¨
```c++
#include <iostream>
using namespace std;

typedef struct DNode {        // å®šä¹‰åŒé“¾è¡¨ç»“ç‚¹ç±»å‹
  int data;                   // æ•°æ®åŸŸ
  struct DNode *prior, *next; // å‰é©±å’Œåé©±æŒ‡é’ˆ
} DNode, *DLinkList;

bool initDLinkList(DLinkList &L) {
  L = (DNode *)malloc(sizeof(DNode)); // åˆ†é…ä¸€ä¸ªå¤´ç»“ç‚¹
  if (L == NULL)
    return false;
  L->prior = NULL; // å¤´ç»“ç‚¹çš„prioræ°¸è¿œæŒ‡å‘NULL
  L->next = NULL;  // å¤´ç»“ç‚¹ä¹‹åæš‚æ—¶æ²¡æœ‰ç»“ç‚¹
  return true;
}

bool insertNextDNode(DNode *p, DNode *s) { // åœ¨PèŠ‚ç‚¹åæ’å…¥Sç»“ç‚¹
  if (p == NULL || s == NULL)
    return false;
  s->next = p->next;
  if (p->next != NULL) // å¦‚æœpæœ‰åç»§ç»“ç‚¹
    p->next->prior = s;
  s->prior = p;
  p->next = s;
  return true;
}

bool deleteNextDNode(DNode *p) { // åˆ é™¤pç»“ç‚¹çš„åç»§ç»“ç‚¹
  if (p == NULL)
    return false;
  DNode *q = p->next; // æ‰¾åˆ°pç»“ç‚¹çš„åç»§ç»“ç‚¹q
  if (q == NULL)
    return false; // pæ²¡æœ‰åç»§ç»“ç‚¹ï¼Œqä¸ºç©º
  p->next = q->next;
  if (q->next != NULL) // qä¸æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹
    q->next->prior = p;
  free(q); // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
  return true;
}

void DestroyDLinkList(DLinkList &L) { // å¾ªç¯é‡Šæ”¾å„ä¸ªæ•°æ®ç»“ç‚¹
  while (L->next != NULL)
    deleteNextDNode(L);
  free(L);
  L = NULL;
}

void checkAllDNode(DLinkList &L) {
  DNode *p = L->next;
  while (p != NULL) { // åå‘éå†
    p = p->next;
    cout << p->data << " ";
  }
  while (p != NULL) { // å‰å‘éå†
    p = p->prior;
    cout << p->data << " ";
  }
  while (p->prior != NULL) { // å‰å‘éå†(è·³è¿‡å¤´ç»“ç‚¹)
    p = p->prior;
    cout << p->data << " ";
  }
}

// check the DLinkList is empty or not
bool isEmptyDLinkList(DLinkList &L) { return L->next == NULL; }

void testDLinkList() {
  DLinkList L;
  initDLinkList(L);
  insertNextDNode(L, (DNode *)malloc(sizeof(DNode)));
  insertNextDNode(L->next, (DNode *)malloc(sizeof(DNode)));
  DestroyDLinkList(L);
}
```

# ç¬¬ä¸‰ç« â€”â€”æ ˆã€é˜Ÿåˆ—å’Œæ•°ç»„
## 3.1 æ ˆ
### 3.1.1 æ ˆçš„åŸºæœ¬æ¦‚å¿µ
### 3.1.2 æ ˆçš„é¡ºåºå­˜å‚¨ï¼ˆé¡ºåºæ ˆï¼‰ã€é‡è¦ã€‘

> nä¸ªä¸åŒå…ƒç´ è¿›æ ˆï¼Œå‡ºæ ˆå…ƒç´ ä¸åŒæ’åˆ—çš„ä¸ªæ•°ä¸º $\frac{1}{n+1}C^n_{2n}$ï¼Œä¸Šè¿°å…¬å¼æˆä¸ºå¡ç‰¹å…°æ•°

```c++
#include <iostream>
using namespace std;

#define MaxSize 10 // å®šä¹‰æ ˆä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct {
  int data[MaxSize]; // é™æ€æ•°æ®å­˜æ”¾æ ˆä¸­å…ƒç´ 
  int top;           // æ ˆé¡¶æŒ‡é’ˆ
} SqStack;

// åˆå§‹åŒ–æ ˆ
void InitStack(SqStack &S) {
  S.top = -1; // åˆå§‹åŒ–æ ˆé¡¶æŒ‡é’ˆ
}

// åˆ¤æ–­æ ˆç©ºä¸å¦
bool StackEmpty(SqStack S) {
  if (S.top == -1)
    return true; // æ ˆç©º
  else
    return false; // ä¸ç©º
}

// è¿›æ ˆ
bool Push(SqStack &S, int x) {
  if (S.top == MaxSize - 1) // æ ˆæ»¡
    return false;
  S.top = S.top + 1; // æŒ‡é’ˆ+1
  S.data[S.top] = x; // æ–°å…ƒç´ è¿›æ ˆ
  return true;
}

// å‡ºæ ˆ
bool Pop(SqStack &S, int &x) {
  if (S.top == -1)
    return false;    // æ ˆç©ºï¼ŒæŠ¥é”™
  x = S.data[S.top]; // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
  S.top = S.top - 1; // æŒ‡é’ˆ-1
  return true;
}

// è¯»æ ˆé¡¶æŒ‡é’ˆ
bool GetTop(SqStack S, int &x) {
  if (S.top == -1)
    return false;
  x = S.data[S.top]; // x è®°å½•æ ˆé¡¶å…ƒç´ 
  return true;
}
```

#### å…±äº«æ ˆ
```c++
#include <iostream>
using namespace std;

#define MaxSize 100 // å®šä¹‰æ ˆä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct {
  int data[MaxSize]; // é™æ€æ•°æ®å­˜æ”¾æ ˆä¸­å…ƒç´ 
  int top1;          // æ ˆé¡¶æŒ‡é’ˆ1
  int top2;          // æ ˆé¡¶æŒ‡é’ˆ2
} SqDouStack;

// åˆå§‹åŒ–æ ˆ
void InitStack(SqDouStack &S) {
  S.top1 = -1; // åˆå§‹åŒ–æ ˆé¡¶æŒ‡é’ˆ
  S.top2 = MaxSize;
}

// åˆ¤æ–­æ ˆç©º
bool StackEmpty(SqDouStack S) {
  if (S.top1 == -1 && S.top2 == MaxSize)
    return true; // æ ˆç©º
  else
    return false; // ä¸ç©º
}

// è¿›æ ˆ
bool Push(SqDouStack &S, int x, int StackNum) {
  if (S.top1 + 1 == S.top2) // æ ˆæ»¡
    return false;
  if (StackNum == 1) {
    S.top1 = S.top1 + 1; // 1æŒ‡é’ˆ+1
    S.data[S.top1] = x;  // æ–°å…ƒç´ è¿›æ ˆ1
  } else {
    S.top2 = S.top2 - 1; // 2æŒ‡é’ˆ-1
    S.data[S.top1] = x;  // æ–°å…ƒç´ è¿›æ ˆ2
  }
  return true;
}

// å‡ºæ ˆ
bool Pop(SqDouStack &S, int x, int StackNum) {
  if (StackNum == 1) {
    if (S.top1 == -1)
      return false;      // æ ˆç©ºï¼ŒæŠ¥é”™
    x = S.data[S.top1];  // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
    S.top1 = S.top1 - 1; // æŒ‡é’ˆ-1
    return true;
  } else {
    if (S.top2 == MaxSize)
      return false;      // æ ˆç©ºï¼ŒæŠ¥é”™
    x = S.data[S.top2];  // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
    S.top2 = S.top2 + 1; // æŒ‡é’ˆ-1
    return true;
  }
}

// è¯»æ ˆé¡¶æŒ‡é’ˆ
bool GetTop(SqDouStack S, int &x, int StackNum) {
  if (StackNum == 1) {
    if (S.top1 == -1)
      return false;
    x = S.data[S.top1]; // x è®°å½•æ ˆé¡¶å…ƒç´ 
    return true;
  } else {
    if (S.top2 == MaxSize)
      return false;
    x = S.data[S.top2]; // x è®°å½•æ ˆé¡¶å…ƒç´ 
    return true;
  }
}
```

### 3.1.3 æ ˆçš„é“¾å¼å­˜å‚¨ï¼ˆé“¾å¼æ ˆï¼‰ã€é‡è¦ã€‘
```c++
#include <iostream>
using namespace std;

typedef struct LinkNode {
  int data;
  struct LinkNode *next;
} *LiStack;

typedef struct LinkStack {
  LiStack top;
  int count;
} LinkStack;

bool Push(LinkStack &s, int x) {
  LiStack p = (LiStack)malloc(sizeof(LinkNode));
  p->data = x;
  p->next = s.top;
  s.top = p;
  s.count++;
  return true;
}

bool Pop(LinkStack &s, int &x) {
  if (s.top == NULL)
    return false;
  x = s.top->data;
  LinkNode *p = s.top;
  s.top = s.top->next;
  free(p);
  s.count--;
  return true;
}
```

### 3.1.4 æ ˆçš„åº”ç”¨
1. æ‹¬å·åŒ¹é…é—®é¢˜
```c++
#include <iostream>
using namespace std;

#define MaxSize 10
typedef struct {
  char data[MaxSize];
  int top;
} SqStack;

// åˆå§‹åŒ–æ ˆ
void InitStack(SqStack &S) { S.top = -1; }

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
bool StackEmpty(SqStack S) {
  if (S.top == -1)
    return true;
  else
    return false;
}

// æ–°å…ƒç´ å…¥æ ˆ
bool Push(SqStack &S, char x) {
  if (S.top == MaxSize - 1)
    return false;
  else {
    S.top++;
    S.data[S.top] = x;
    return true;
  }
}

// æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œç”¨xè¿”å›
bool Pop(SqStack &S, char &x) {
  if (S.top == -1)
    return false;
  else {
    x = S.data[S.top];
    S.top--;
    return true;
  }
}

bool bracketCheck(char str[], int length) {
  SqStack S;
  InitStack(S); // åˆå§‹åŒ–ä¸€ä¸ªæ ˆ
  for (int i = 0; i < length; i++) {
    if (str[i] == '(' || str[i] == '{' || str[i] == '[') {
      Push(S, str[i]); // æ‰«æåˆ°å·¦æ‹¬å·ï¼Œå…¥æ ˆæ“ä½œ
    } else {
      if (StackEmpty(S)) { // æ‰«æåˆ°å³æ‹¬å·ï¼Œç„¶è€Œæ ˆç©ºï¼ŒåŒ¹é…é”™è¯¯
        return false;
      }
      char topElem;
      Pop(S, topElem); // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
      if (str[i] == ')' && topElem != '(')
        return false;
      if (str[i] == ']' && topElem != '[')
        return false;
      if (str[i] == '}' && topElem != '{')
        return false;
    }
  }
  return StackEmpty(S); // æ£€ç´¢å®Œå…¨éƒ¨æ‹¬å·åï¼Œæ ˆç©ºè¯´æ˜åŒ¹é…æˆåŠŸ
}
```

2. ä¸‰ç§ç®—æœ¯è¡¨è¾¾å¼ï¼ˆè½¬æ¢åŠæ±‚å€¼ï¼‰
åç¼€è¡¨è¾¾å¼ = é€†æ³¢å…°è¡¨è¾¾å¼ã€**é‡è¦**ã€‘
å‰ç¼€è¡¨è¾¾å¼ = æ³¢å…°è¡¨è¾¾å¼

> åç¼€è¡¨è¾¾å¼ï¼ˆæ‰‹ç®—ï¼‰
> ã€ä¸­ç¼€è½¬åç¼€ã€‘
> â€œå·¦ä¼˜å…ˆâ€åŸåˆ™ï¼šåªè¦å·¦è¾¹çš„è¿ç®—ç¬¦èƒ½å…ˆè®¡ç®—ï¼Œå°±ä¼˜å…ˆç®—å·¦è¾¹çš„
> 
> åç¼€è¡¨è¾¾å¼ï¼ˆæœºç®—ï¼‰
>> â‘ ä»å·¦å¾€å³æ‰«æä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œç›´åˆ°å¤„ç†å®Œæ‰€æœ‰å…ƒç´ 
>> â‘¡è‹¥æ‰«æåˆ°æ“ä½œæ•°åˆ™å‹å…¥æ ˆï¼Œå¹¶å›åˆ°â‘ ï¼šå¦åˆ™æ‰§è¡Œâ‘¢
>> â‘¢è‹¥æ‰«æåˆ°è¿ç®—ç¬¦ï¼Œåˆ™å¼¹å‡ºä¸¤ä¸ªæ ˆé¡¶å…ƒç´ (<font color='red'>æ³¨æ„ï¼šå…ˆå‡ºæ ˆçš„æ˜¯â€œå³æ“ä½œæ•°â€</font>)ï¼Œæ‰§è¡Œç›¸åº”è¿ç®—ï¼Œè¿ç®—ç»“æœå‹å›æ ˆé¡¶ï¼Œå›åˆ°â‘ 
---
> å‰ç¼€è¡¨è¾¾å¼ï¼ˆæ‰‹ç®—ï¼‰
> ã€ä¸­ç¼€è½¬å‰ç¼€ã€‘
> â€œå³ä¼˜å…ˆâ€åŸåˆ™ï¼šåªè¦å³è¾¹çš„è¿ç®—ç¬¦èƒ½å…ˆè®¡ç®—ï¼Œå°±ä¼˜å…ˆç®—å³è¾¹çš„
> 
> å‰ç¼€è¡¨è¾¾å¼ï¼ˆæœºç®—ï¼‰
>> â‘ ä»å³å¾€å·¦æ‰«æä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œç›´åˆ°å¤„ç†å®Œæ‰€æœ‰å…ƒç´ 
>> â‘¡è‹¥æ‰«æåˆ°æ“ä½œæ•°åˆ™å‹å…¥æ ˆï¼Œå¹¶å›åˆ°â‘ ï¼šå¦åˆ™æ‰§è¡Œâ‘¢
>> â‘¢è‹¥æ‰«æåˆ°è¿ç®—ç¬¦ï¼Œåˆ™å¼¹å‡ºä¸¤ä¸ªæ ˆé¡¶å…ƒç´ (<font color='red'>æ³¨æ„ï¼šå…ˆå‡ºæ ˆçš„æ˜¯â€œå·¦æ“ä½œæ•°â€</font>)ï¼Œæ‰§è¡Œç›¸åº”è¿ç®—ï¼Œè¿ç®—ç»“æœå‹å›æ ˆé¡¶ï¼Œå›åˆ°â‘ 
---
> ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼´è¡¨è¾¾å¼ï¼ˆæœºç®—ï¼‰
> ä»å·¦åˆ°å³å¤„ç†å„ä¸ªå…ƒç´ ï¼Œç›´åˆ°æœ«å°¾ã€‚å¯èƒ½é‡åˆ°ä¸‰ç§æƒ…å†µï¼š
> â‘  é‡åˆ°æ“ä½œæ•°ã€‚ç›´æ¥åŠ å…¥åç¼€è¡¨è¾¾å¼ã€‚
> â‘¡ é‡åˆ°ç•Œé™ç¬¦ã€‚é‡åˆ°â€œï¼ˆâ€ç›´æ¥å…¥æ ˆï¼›é‡åˆ°â€œï¼‰â€åˆ™ä¾æ¬¡å¼¹å‡ºæ ˆå†…è¿ç®—ç¬¦å¹¶åŠ å…¥åç¼€è¡¨è¾¾å¼ï¼Œç›´åˆ°å¼¹å‡ºâ€œï¼ˆâ€ä¸ºæ­¢ã€‚æ³¨æ„ï¼šâ€œï¼ˆâ€ä¸åŠ å…¥åç¼€è¡¨è¾¾å¼ã€‚
> â‘¢ é‡åˆ°è¿ç®—ç¬¦ã€‚ä¾æ¬¡å¼¹å‡ºæ ˆä¸­ä¼˜å…ˆçº§é«˜äºæˆ–ç­‰äºå½“å‰è¿ç®—ç¬¦çš„æ‰€æœ‰è¿ç®—ç¬¦ï¼Œå¹¶åŠ å…¥åç¼€è¡¨è¾¾å¼ï¼Œ è‹¥ç¢°åˆ°â€œï¼ˆâ€æˆ–æ ˆç©ºåˆ™åœæ­¢ã€‚ä¹‹åå†æŠŠå½“å‰è¿ç®—ç¬¦å…¥æ ˆã€‚
> æŒ‰ä¸Šè¿°æ–¹æ³•å¤„ç†å®Œæ‰€æœ‰å­—ç¬¦åï¼Œå°†æ ˆä¸­å‰©ä½™è¿ç®—ç¬¦ä¾æ¬¡å¼¹å‡ºï¼Œå¹¶åŠ å…¥åç¼€è¡¨è¾¾å¼ã€‚

3. é€’å½’
```c++
#include<iostream>
using namespace std;

int Fib(int n){
    if(n==0)
        return 0;
    else if(n==1)
        return 1;
    else
        return Fib(n-1)+Fib(n-2);
}

int main(){
    int x=Fib(4);
    cout<<x<<"  å¥¥é‡Œç»™ï¼ï¼ï¼"<<endl;
    return 0;
}
```

## 3.2 é˜Ÿåˆ—
### 3.2.1 é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„
### 3.2.2 é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨ã€é‡è¦ã€‘

ä»¥ä¸‹Codeé‡‡ç”¨é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨ï¼Œä¸”ä½¿ç”¨å¾ªç¯é˜Ÿåˆ—å­˜å‚¨
ä¸ºäº†åŒºåˆ†é˜Ÿç©ºå’Œé˜Ÿæ»¡ï¼Œé‡‡å–å…¥é˜Ÿæ—¶**å°‘ç”¨ä¸€ä¸ªé˜Ÿåˆ—å•å…ƒ**
é˜Ÿåˆ—ç©ºçš„æ¡ä»¶ä¸º Q.front == Q.rear
é˜Ÿåˆ—æ»¡çš„æ¡ä»¶ä¸º (Q.rear+1) % MaxSize == Q.front
é˜Ÿåˆ—ä¸­å…ƒç´ çš„ä¸ªæ•° ï¼ˆrear + MaxSize - frontï¼‰% MaxSize

```c++
#include <iostream>
using namespace std;

#define MaxSize 10
typedef struct SqQueue {
  int data[MaxSize];
  int front, rear;
} SqQueue;

// åˆå§‹åŒ–é˜Ÿåˆ—
void InitQueue(SqQueue &Q) { Q.front = Q.rear = 0; }

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
bool QueueEmpty(SqQueue Q) {
  if (Q.front == Q.rear)
    return true;
  else
    return false;
}

// å…¥é˜Ÿï¼ˆé˜Ÿå°¾å…¥é˜Ÿï¼‰
bool EnQueue(SqQueue &Q, int x) {
  if ((Q.rear + 1) % MaxSize == Q.front) // åˆ¤æ–­é˜Ÿæ»¡
    return false;
  Q.data[Q.rear] = x;              // æ–°å…ƒç´ æ’å…¥é˜Ÿå°¾
  Q.rear = (Q.rear + 1) % MaxSize; // é˜Ÿå°¾æŒ‡é’ˆåŠ 1å–æ¨¡
  return true;
}

// å‡ºé˜Ÿï¼ˆé˜Ÿå¤´å‡ºé˜Ÿï¼‰
bool DeQueue(SqQueue &Q, int &x) {
  if (Q.front == Q.rear) // é˜Ÿç©ºåˆ™æŠ¥é”™
    return false;
  x = Q.data[Q.front];
  Q.front = (Q.front + 1) % MaxSize;
  return true;
}

// è·å¾—é˜Ÿå¤´å…ƒç´ çš„å€¼,ç”¨xè¿”å›
int GetHead(SqQueue Q, int &x) {
  if (Q.front == Q.rear)
    return false; // é˜Ÿç©ºåˆ™æŠ¥é”™
  x = Q.data[Q.front];
  return x;
}
```

### 3.2.3 é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨ã€é‡è¦ã€‘
```c++
#include <iostream>
using namespace std;

typedef struct LinkNode { // é˜Ÿåˆ—ç»“ç‚¹
  int data;
  struct LinkNode *next;
} LinkNode;

typedef struct {          // é“¾å¼é˜Ÿåˆ—
  LinkNode *front, *rear; // é˜Ÿå¤´å’Œé˜Ÿå°¾æŒ‡é’ˆ
} LinkQueue;

// åˆå§‹åŒ–é˜Ÿåˆ—(å¸¦å¤´ç»“ç‚¹)
void InitQueue(LinkQueue &Q) {
  // åˆå§‹åŒ–,front rear éƒ½æŒ‡å‘å¤´ç»“ç‚¹
  Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode));
  Q.front->next = NULL;
}

// åˆå§‹åŒ–é˜Ÿåˆ—ï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
void InitQueue_NoHead(LinkQueue &Q) {
  // åˆå§‹åŒ–,front rear éƒ½æŒ‡å‘NULL
  Q.front = Q.rear = NULL;
}

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º(å¸¦å¤´ç»“ç‚¹)
bool IsEmpty(LinkQueue Q) {
  if (Q.front == Q.rear)
    return true;
  else
    return false;
}

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
bool IsEmpty_NoHead(LinkQueue Q) {
  if (Q.front == NULL)
    return true;
  else
    return false;
}

// æ–°å…ƒç´ å…¥é˜Ÿï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
void EnQueue(LinkQueue &Q, int x) {
  LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));
  s->data = x;
  s->next = NULL;
  Q.rear->next = s; // æ–°ç»“ç‚¹æ’å…¥åˆ°rearä¹‹å
  Q.rear = s;       // ä¿®æ”¹é˜Ÿå°¾æŒ‡é’ˆ
}

// æ–°å…ƒç´ å…¥é˜Ÿï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
void EnQueue_NoHead(LinkQueue &Q, int x) {
  LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));
  s->data = x;
  s->next = NULL;
  if (Q.front == NULL) { // åœ¨ç©ºé˜Ÿåˆ—ä¸­æ’å…¥ç¬¬ä¸€ä¸ªå…ƒç´ 
    Q.front = s;
    Q.rear = s;
  } else {
    Q.rear->next = s; // æ–°ç»“ç‚¹æ’å…¥åˆ°rearç»“ç‚¹ä¹‹å
    Q.rear = s;       // ä¿®æ”¹rearé˜Ÿå°¾æŒ‡é’ˆ
  }
}

// é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
bool DeQueue(LinkQueue &Q, int &x) {
  if (Q.front == Q.rear) // é˜Ÿç©º
    return false;
  LinkNode *p = Q.front->next; // pæŒ‡å‘æ­¤æ¬¡å‡ºé˜Ÿçš„é˜Ÿå¤´ç»“ç‚¹
  x = p->data;                 // ç”¨ x è¿”å›é˜Ÿå¤´çš„æ•°æ®
  Q.front->next = p->next;     // ä¿®æ”¹å¤´ç»“ç‚¹çš„nextæŒ‡é’ˆ

  if (Q.rear == p)    // å¦‚æœæ˜¯æœ€åä¸€ä¸ªç»“ç‚¹å‡ºé˜Ÿ
    Q.rear = Q.front; // ä¿®æ”¹ rear æŒ‡é’ˆ
  free(p);            // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
  return true;
}

// é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
bool DeQueue_NoHead(LinkQueue &Q, int &x) {
  if (Q.front == NULL)
    return false;        // é˜Ÿç©º
  LinkNode *p = Q.front; // pæŒ‡å‘æ­¤æ¬¡å‡ºé˜Ÿçš„é˜Ÿå¤´ç»“ç‚¹
  x = p->data;           // ç”¨å˜é‡ x è¿”å›é˜Ÿå¤´çš„æ•°æ®
  Q.front = p->next;     // ä¿®æ”¹ front æŒ‡é’ˆ
  if (Q.rear == p) {     // å€˜è‹¥æ˜¯é˜Ÿä¸­æœ€åä¸€ä¸ªç»“ç‚¹å‡ºé˜Ÿ
    Q.front = NULL;      // front æŒ‡å‘ NULL
    Q.rear = NULL;       // rear æŒ‡å‘ NULL
  }
  free(p); // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
  return true;
}
```

### 3.2.4 åŒç«¯é˜Ÿåˆ—ï¼ˆä¸å—é™å’Œå—é™ï¼‰
1. åŒç«¯é˜Ÿåˆ—ï¼ˆä¸å—é™åˆ¶ï¼‰
    åŒç«¯é˜Ÿåˆ—æ˜¯æŒ‡å…è®¸ä¸¤ç«¯éƒ½å¯ä»¥è¿›è¡Œå…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œçš„é˜Ÿåˆ—  
    é˜Ÿåˆ—çš„ä¸¤ç«¯åˆ†åˆ«ç§°ä¸ºå‰ç«¯å’Œåç«¯ï¼Œä¸¤ç«¯éƒ½å¯ä»¥å…¥é˜Ÿå’Œå‡ºé˜Ÿ

2. è¾“å‡ºå—é™çš„åŒç«¯é˜Ÿåˆ—
    å…è®¸åœ¨ä¸€ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤ï¼Œä½†åœ¨å¦ä¸€ç«¯åªå…è®¸æ’å…¥çš„åŒç«¯é˜Ÿåˆ—

3. è¾“å…¥å—é™çš„åŒç«¯é˜Ÿåˆ—
    å…è®¸åœ¨ä¸€ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤ï¼Œä½†åœ¨å¦ä¸€ç«¯åªå…è®¸åˆ é™¤çš„åŒç«¯é˜Ÿåˆ—

### 3.2.5 é˜Ÿåˆ—çš„åº”ç”¨
1. æ ‘çš„å±‚æ¬¡éå†
2. å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†
3. æ“ä½œç³»ç»Ÿ FCFS(å…ˆæ¥å…ˆæœåŠ¡) ç¼“å†²åŒº

## 3.3 æ•°ç»„å’Œç‰¹æ®ŠçŸ©é˜µ
è¯¦æƒ…è§ XMind

# ç¬¬å››ç« â€”â€”ä¸²ã€ä¸è€ƒï¼Œå¯ç•¥è¿‡ã€‘
## 4.1 ä¸²çš„å®šä¹‰å’Œå®ç°
### ä¸²çš„é¡ºåºå­˜å‚¨ã€é‡è¦ã€‘
```c++
#include<iostream>
using namespace std;

#define MAXLEN 255
typedef struct SString{
    char ch[MAXLEN];
    int length;
};

typedef struct HString{
    char *ch;
    int length;
};

void initHString(HString &s){
    S.ch=(char *)malloc(MAXLEN*sizeof(char));
    S.length=0;
}

//èµ‹å€¼æ“ä½œï¼Œå°†ä¸²Tèµ‹å€¼ä¸ºchars
bool StrAssign(SString &T,chars){

}

//å¤åˆ¶æ“ä½œï¼Œå°†ä¸²Så¤åˆ¶å¾—åˆ°ä¸²T
bool StrCopy(){

}

//åˆ¤ç©ºæ“ä½œï¼ŒSç©ºä¸²è¿”å›TRUEï¼Œå¦åˆ™False
bool StrEmpty(){
    
}

//æ±‚ä¸²é•¿ï¼Œè¿”å›ä¸²çš„å…ƒç´ ä¸ªæ•°
bool StrLength(){
    
}

//æ±‚å­ä¸²ï¼Œç”¨Subè¿”å›ä¸²Sçš„ç¬¬posä¸ªå­—ç¬¦èµ·é•¿åº¦ä¸ºlençš„å­ä¸²
bool SubString(SString &Sub,SString S,int pos,int len){
    if(pos+len-1 > S.length)        //å­ä¸²
        return false;
    for(int i = pos;i<pos+len;i++)
        Sub.ch[i-pos+1] = S.ch[i];
    Sub.length = len;
    return true;
}

//æ¯”è¾ƒæ“ä½œ,è‹¥S>T,åˆ™è¿”å›å€¼>0;è‹¥S=T,åˆ™è¿”å›å€¼=0;è‹¥S<T,åˆ™è¿”å›å€¼<0
int StrCompare(SString S,SString T){
    for(int i=1; i<S.length && i<T.length; i++){
        if(S.ch[i]!=T.ch[i])
            return S.ch[i]-T.ch[i];
    }
    cout<<"å­—ç¬¦ä¸²é•¿åº¦ä¸ç›¸ç­‰,å…¶å·®å€¼ä¸º"<<S.length-T.length;
    return S.length-T.length;
}

//å®šä½æ“ä½œã€‚è‹¥ä¸»ä¸²Sä¸­å­˜åœ¨ä¸ä¸²Tå€¼ç›¸åŒçš„å­ä¸²ï¼Œåˆ™è¿”å›å®ƒåœ¨ä¸»ä¸²Sä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œå¦åˆ™å‡½æ•°å€¼ä¸º0
int Index(SString S,SString T){
    int i=1;
    SString sub;
    while(i<=S.length-T.length+1){
        SubString(sub,S,i,T.length);
        if(StrCompare(sub,T)!=0)
            ++i;
        else
            return i;
    }
    return 0;
}

//æ¸…ç©ºæ“ä½œï¼Œå°†Sæ¸…ç©ºä¸ºç©ºä¸²
bool ClearString(){
    
}

//é”€æ¯æ“ä½œï¼Œå›æ”¶å­˜å‚¨ç©ºé—´
bool DestoryString(){

}

//ä¸²è¿æ¥ï¼Œç”¨Tè¿”å›ç”±S1å’ŒS2è”ç»“è€Œæˆçš„æ–°ä¸²
bool Concat(){

}
```

### ä¸²çš„é“¾å¼å­˜å‚¨ã€é‡è¦ã€‘
```c++
#include<iostream>
using namespace std;

#define MAXLEN 255
typedef struct StringNode{
    char ch;        //æ¯ä¸ªç»“ç‚¹å­˜å‚¨1ä¸ªå­—ç¬¦ï¼Œå­˜å‚¨å¯†åº¦ä½ï¼Œæ¯ä¸ªå­—ç¬¦1Bï¼Œæ¯ä¸ªæŒ‡é’ˆ4B
    char ch[4];     //å­˜å‚¨å¯†åº¦æé«˜
    struct StringNode *next;
}StringNode,*String;

```

## 4.2 ä¸²çš„æ¨¡å¼åŒ¹é…

### 4.2.1 æœ´ç´ æ¨¡å¼åŒ¹é…ï¼ˆå®šä½æ“ä½œï¼‰

ä¸»ä¸²çš„æ‰«ææŒ‡é’ˆ i ç»å¸¸å›æº¯ï¼Œå¯¼è‡´æ—¶é—´å¼€é”€å¢åŠ ï¼Œ<font color='red'>æœ€åæ—¶é—´å¤æ‚åº¦ O ( n m ) </font>

```c++
int Index(SString S,SString T){
    int k=1;
    int i=k,j=1;
    while(i<=S.length&&j<=T.length){
        if(S.ch[i]==T.ch[j]){
            ++i;
            ++j;        //ç»§ç»­æ¯”è¾ƒåç»§å­—ç¬¦
        }else{
            k++;        //æ£€æŸ¥åä¸€ä¸ªå­—ç¬¦ä¸²
            i=k;
            j=1;
        }
        if(j>T.length)
            return k;
        else
            return 0;
    }
}
```

### 4.2.2 KMP

æ”¹è¿›æ€è·¯ï¼šå½“å­ä¸²å’Œæ¨¡å¼ä¸²ä¸åŒ¹é…æ—¶ï¼Œä¸»ä¸²æŒ‡é’ˆä¸å›æº¯ï¼Œåªæœ‰æ¨¡å¼ä¸²æŒ‡é’ˆå›æº¯ j = next [ j ]

<font color='red'>ç®—æ³•å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO ( n + m )</font>

```c++
int Index_KMP(SString S,SString T,int next[]){
    int i=1,j=1;
    while(i<=S.length&&j<=T.length){
        if(j==0 || S.ch[i]==T.ch[i]){
            ++i;
            ++j;
        }else{
            j=next[j];
        }
        if(j>T.length)
            return i-T.length;
        else
            return 0; 
    }
}
```
ğŸ’¡ nextæ•°ç»„ï¼šå½“æ¨¡å¼ä¸²çš„ç¬¬ j ä¸ªå­—ç¬¦åŒ¹é…å¤±è´¥æ—¶ï¼Œä»¤æ¨¡å¼ä¸²è·³åˆ° next [ j ] å†ç»§ç»­åŒ¹é…   
æ¨¡å¼ä¸²å‘å³ç§»åŠ¨çœ‹åŒ¹é…ç¨‹åº¦

> ä¸²çš„å‰ç¼€ï¼šåŒ…å«ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œä¸”ä¸åŒ…å«æœ€åä¸€ä¸ªå­—ç¬¦çš„å­ä¸²
ä¸²çš„åç¼€ï¼šåŒ…å«æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œä¸”ä¸åŒ…å«ç¬¬ä¸€ä¸ªå­—ç¬¦çš„å­ä¸²
> 

ğŸ’¡ å½“ç¬¬ j ä¸ªå­—ç¬¦åŒ¹é…å¤±è´¥ï¼Œç”±å‰ 1 ï½ j - 1 ä¸ªå­—ç¬¦ç»„æˆçš„ä¸²è®°ä¸º S ,åˆ™ï¼š  
next [ j ] = S çš„æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦ + 1  
>ç‰¹åˆ«çš„ï¼Œnext [ 1 ] = 0 ä¸” next [ 2 ] = 1


### 4.2.3 KMPç®—æ³•ä¼˜åŒ–â€”â€”nextvalæ•°ç»„

# ç¬¬äº”ç« â€”â€”æ ‘ä¸äºŒå‰æ ‘

## 5.1 æ ‘çš„åŸºæœ¬æ¦‚å¿µ
å¸¸è€ƒæ€§è´¨:
1. ç»“ç‚¹æ•°=æ€»åº¦æ•°+1
2. åº¦ä¸º$m$çš„æ ‘($m$å‰æ ‘)ç¬¬$i$å±‚è‡³å¤šæœ‰ $m^{i-1}$ä¸ªç»“ç‚¹ï¼ˆ$i>=1$ï¼‰
3. é«˜åº¦ä¸º$h$çš„$m$å‰æ ‘è‡³å¤šæœ‰$\frac{m^h-1}{m-1}$ä¸ªç»“ç‚¹
4. - é«˜åº¦$h$çš„$m$å‰æ ‘è‡³å°‘æœ‰$h$ä¸ªç»“ç‚¹ã€‚
   - é«˜åº¦ä¸º$h$ã€åº¦ä¸º$m$çš„æ ‘è‡³å°‘æœ‰$h+m-1$ä¸ªç»“ç‚¹ã€‚
5. å…·æœ‰$n$ä¸ªç»“ç‚¹çš„$m$å‰æ ‘çš„æœ€å°é«˜åº¦ä¸º$\lceil\log_m(n(m-1)+1)\rceil$


## 5.2 äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ
### 5.2.1 äºŒå‰æ ‘çš„å®šä¹‰åŠå…¶ä¸»è¦ç‰¹å¾
1. $$\begin{aligned}â‘  \quad n &=n_0+n_1+n_2    \\â‘¡ \quad n &= n_1+2n_2+1    \\â‘¡-â‘  \quad n_0&=n_2+1   \end{aligned}$$
2. $éç©ºäºŒå‰æ ‘ä¸Šç¬¬ i å±‚ä¸Šè‡³å¤šæœ‰ 2^{iâˆ’1} ä¸ªç»“ç‚¹ï¼ˆi â‰¥ 1ï¼‰\\[5px]$
3. $må‰æ ‘ç¬¬ i å±‚è‡³å¤šæœ‰ m^{i - 1}ä¸ªç»“ç‚¹\\[5px]$
4. $é«˜åº¦ä¸º h çš„ äºŒå‰æ ‘ è‡³å¤šæœ‰ 2^h - 1 ä¸ªç»“ç‚¹ï¼ˆæ»¡äºŒå‰æ ‘ï¼‰\\[5px]$
5. $é«˜åº¦ä¸º h çš„ må‰æ ‘ è‡³å¤šæœ‰ \frac{m^h - 1}{m -1}ä¸ªç»“ç‚¹ï¼ˆhâ‰¥1ï¼‰\\[5px]$
6. $$é«˜åº¦ä¸º h çš„ m å‰æ ‘ è‡³å°‘æœ‰hä¸ªç»“ç‚¹ \\ é«˜åº¦ä¸ºh ã€åº¦ä¸ºm çš„æ ‘è‡³å°‘æœ‰h+m-1ä¸ªç»“ç‚¹$$
7. $å…·æœ‰Nä¸ªï¼ˆN>0ï¼‰ç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„é«˜åº¦ä¸º \lceil log_{2}(N+1) \rceil æˆ– \lfloor log_{2}N \rfloor+1ã€‚\\[5px]$

### 5.2.2 äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„ã€éå†ã€é‡è¦ã€‘

1. é¡ºåºå­˜å‚¨(é€‚ç”¨äºå®Œå…¨äºŒå‰æ ‘)
```c++
#include <iostream>
#define MaxSize 100
struct TreeNode {
  int value;    // ç»“ç‚¹ä¸­çš„æ•°æ®å…ƒç´ 
  bool isEmpty; // ç»“ç‚¹æ˜¯å¦ä¸ºç©º
};

TreeNode t[MaxSize];

void initTree() { // åˆå§‹åŒ–
  for (int i = 0; i < MaxSize; i++) {
    t[i].isEmpty = true;
  }
};
```

2. é“¾å¼å­˜å‚¨ï¼ˆéå†ï¼‰
    - å…ˆåºéå†
    - ä¸­åºéå†
    - ååºéå†
    - é€’å½’ç®—æ³•å’Œéé€’å½’ç®—æ³•çš„è½¬æ¢
    - å±‚æ¬¡éå†
    - ç”±éå†åºåˆ—æ„é€ äºŒå‰æ ‘ï¼ˆå¿…é¡»ç”±ä¸­åºéå†åºåˆ—ï¼‰

$n$ä¸ªç»“ç‚¹çš„äºŒå‰é“¾è¡¨å…±æœ‰$n+1$ä¸ªç©ºé“¾åŸŸ

> ä¸‰ç§éå†ï¼ˆå…ˆåºä¸­åºååºï¼‰
```c++
#include <iostream>

struct ElemType {
  int value;
};

typedef struct BiTNode {
  ElemType data;                   // æ•°æ®åŸŸ
  struct BiTNode *lchild, *rchild; // å·¦å³å­©å­æŒ‡é’ˆ
  struct BiTNode *parent; // çˆ¶ç»“ç‚¹æŒ‡é’ˆ(æ–¹ä¾¿æŸ¥æ‰¾å½“å‰ç»“ç‚¹çš„çˆ¶ç»“ç‚¹)
} BiTNode, *BiTree;

void visit(BiTree T) { std::cout << T->data.value << std::endl; }

// å…ˆåºéå†
void PreOrder(BiTree T) {
  if (T != NULL) {
    visit(T);            // è®¿é—®æ ¹ç»“ç‚¹
    PreOrder(T->lchild); // é€’å½’éå†å·¦å­æ ‘
    PreOrder(T->rchild); // é€’å½’éå†å³å­æ ‘
  }
}

// ä¸­åºéå†
void InOrder(BiTree T) {
  if (T != NULL) {
    InOrder(T->lchild); // é€’å½’éå†å·¦å­æ ‘
    visit(T);           // è®¿é—®æ ¹ç»“ç‚¹
    InOrder(T->rchild); // é€’å½’éå†å³å­æ ‘
  }
}

// ååºéå†
void PostOrder(BiTree T) {
  if (T != NULL) {
    PostOrder(T->lchild); // é€’å½’éå†å·¦å­æ ‘
    PostOrder(T->rchild); // é€’å½’éå†å³å­æ ‘
    visit(T);             // è®¿é—®æ ¹ç»“ç‚¹
  }
}

int main() {
  // å®šä¹‰ä¸€æ£µç©ºæ ‘
  BiTree root = NULL;

  // æ’å…¥æ ¹ç»“ç‚¹ root
  root = (BiTree)malloc(sizeof(BiTNode));
  root->data = {1};
  root->lchild = NULL;
  root->rchild = NULL;

  // æ’å…¥æ–°ç»“ç‚¹ p
  BiTNode *p = (BiTNode *)malloc(sizeof(BiTNode));
  p->data = {2};
  p->lchild = NULL;
  p->rchild = NULL;

  // ä½œä¸ºæ ¹èŠ‚ç‚¹çš„å·¦å­©å­æ’å…¥ç»“ç‚¹ p
  root->lchild = p;
}

```

> å±‚åºéå†
```c++
#include <iostream>

// äºŒå‰æ ‘çš„ç»“ç‚¹ï¼ˆé“¾å¼å­˜å‚¨ï¼‰
typedef struct BiTNode {
  char data;                       // æ•°æ®åŸŸ
  struct BiTNode *lchild, *rchild; // å·¦å³å­©å­æŒ‡é’ˆ
} BiTNode, *BiTree;

// é“¾å¼é˜Ÿåˆ—ç»“ç‚¹
typedef struct LinkNode {
  BiTNode *data; // å­˜æŒ‡é’ˆè€Œä¸æ˜¯ç»“ç‚¹
  struct LinkNode *next;
} LinkNode;

typedef struct {
  LinkNode *front, *rear; // é˜Ÿå¤´é˜Ÿå°¾
} LinkQueue;

// å±‚åºéå†
void LevelOrder(BiTree T) {
  LinkQueue Q;
  InitQueue(Q); // åˆå§‹åŒ–è¾…åŠ©é˜Ÿåˆ—
  BiTree p;
  EnQueue(Q, T);        // å°†æ ¹ç»“ç‚¹å…¥é˜Ÿ
  while (!isEmpty(Q)) { // é˜Ÿåˆ—ä¸ç©ºåˆ™å¾ªç¯
    DeQueue(Q, p);      // é˜Ÿå¤´ç»“ç‚¹å‡ºé˜Ÿï¼ŒTèµ‹å€¼p
    visit(p);           // è®¿é—®å‡ºé˜Ÿç»“ç‚¹
    if (p->lchild != NULL)
      EnQueue(Q, p->lchild); // å·¦å­©å­å…¥é˜Ÿ
    if (p->rchild != NULL)
      EnQueue(Q, p->rchild); // å³å­©å­å…¥é˜Ÿ
  }
}
```

> ç”¨åœŸåŠæ³•æ‰¾åˆ°ä¸­åºå‰é©±

æ€è·¯ï¼š

ä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œé‡æ–°è¿›è¡Œä¸€æ¬¡ä¸­åºéå†ï¼ŒæŒ‡é’ˆ q è®°å½•å½“å‰è®¿é—®çš„ç»“ç‚¹ï¼ŒæŒ‡é’ˆ pre è®°å½•ä¸Šä¸€ä¸ªè¢«è®¿é—®çš„ç»“ç‚¹ 
â‘  å½“ $q==p$ æ—¶ï¼Œpre ä¸ºå‰é©±
â‘¡ å½“ $pre=p$ æ—¶ï¼Œq ä¸ºåç»§

```c++
#include <iostream>

// äºŒå‰æ ‘çš„ç»“ç‚¹ï¼ˆé“¾å¼å­˜å‚¨ï¼‰
typedef struct BiTNode {
  char data;                       // æ•°æ®åŸŸ
  struct BiTNode *lchild, *rchild; // å·¦å³å­©å­æŒ‡é’ˆ
} BiTNode, *BiTree;

// è¾…åŠ©çš„å…¨å±€å˜é‡ï¼Œç”¨äºæŸ¥æ‰¾ç»“ç‚¹pçš„å‰é©±
BiTNode *p;            // pæŒ‡å‘ç›®æ ‡ç»“ç‚¹
BiTNode *pre = NULL;   // æŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
BiTNode *final = NULL; // ç”¨äºè®°å½•æœ€ç»ˆç»“æœ

void visit(BiTNode *q) {
  if (q == p)    // å½“å‰è®¿é—®ç»“ç‚¹åˆšå¥½æ˜¯ç»“ç‚¹p
    final = pre; // æ‰¾åˆ°pçš„å‰é©±
  else
    pre = q; // preæŒ‡å‘å½“å‰è®¿é—®çš„ç»“ç‚¹
}

// ä¸­åºéå†
void InOrder(BiTree T) {
  if (T != NULL) {
    InOrder(T->lchild); // é€’å½’éå†å·¦å­æ ‘
    visit(T);           // è®¿é—®æ ¹ç»“ç‚¹
    InOrder(T->rchild); // é€’å½’éå†å³å­æ ‘
  }
}
```

## 5.3 çº¿ç´¢äºŒå‰æ ‘

### 5.3.1 çº¿ç´¢åŒ–äºŒå‰æ ‘

tag == 0 , è¡¨ç¤ºæŒ‡é’ˆæŒ‡å‘çš„æ˜¯å­©å­
tag == 1 , è¡¨ç¤ºæŒ‡é’ˆæŒ‡å‘çš„æ˜¯çº¿ç´¢

- ä¸­åºçº¿ç´¢åŒ–
```c++
#include <iostream>

typedef struct ElemType {
  int data;
} ElemType;

// çº¿ç´¢äºŒå‰æ ‘ç»“ç‚¹
typedef struct ThreadNode {
  ElemType data;
  struct ThreadNode *lchild, *rchild;
  int ltag, rtag; // å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
} ThreadNode, *ThreadTree;

// å…¨å±€å˜é‡ pre ï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;

void visit(ThreadNode *q) {
  if (q->lchild == NULL) { // å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
    q->lchild = pre;
    q->ltag = 1;
  }
  if (pre != NULL && pre->rchild == NULL) {
    pre->rchild = q; // å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
    pre->rtag = 1;
  }
  pre = q;
}

// ä¸­åºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void InThread(ThreadTree T) {
  if (T != NULL) {
    InThread(T->lchild);
    visit(T);
    InThread(T->rchild);
  }
}

// ä¸­åºçº¿ç´¢åŒ–äºŒå‰æ ‘Tï¼Œä¸»å‡½æ•°
void CreateInThread(ThreadTree T) {
  pre = NULL;
  if (T != NULL) {
    InThread(T);
    // æœ€åæ£€æŸ¥ pre çš„ rchild æ˜¯å¦ä¸º NULL,å¦‚æœæ˜¯,åˆ™ä»¤ rtag=1
    if (pre->rchild == NULL)
      pre->rtag = 1;
  }
}
```

- å…ˆåºçº¿ç´¢åŒ–
> å…ˆåºçº¿ç´¢åŒ– **æœ‰ä¸ªå‘**ï¼Œåœ¨å¤„ç†æ ¹ç»“ç‚¹ä¹‹åï¼Œå¤„ç†å·¦å­©å­ä¹‹å‰ï¼Œéœ€è¦åˆ¤æ–­æ”¹å½“å‰éå†ç»“ç‚¹çš„ **ltag** æ ‡å¿—æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸º0ï¼Œåˆ™lchildä¸æ˜¯å‰é©±çº¿ç´¢
>> ã€ç»¼ä¸Šæ˜¯ä¸ºäº†é¿å…é™·å…¥éå†çš„ **æ­»å¾ªç¯**ã€‘
```c++
#include <iostream>

typedef struct ThreadNode {
  int data;
  struct ThreadNode *lchild, *rchild;
  int ltag, rtag; // å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
} ThreadNode, *ThreadTree;

// å…¨å±€å˜é‡ pre ï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;

void visit(ThreadNode *q) {
  if (q->lchild == NULL) { // å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
    q->lchild = pre;
    q->ltag = 1;
  }
  if (pre != NULL && pre->rchild == NULL) {
    pre->rchild = q; // å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
    pre->rtag = 1;
  }
  pre = q;
}

// å…ˆåºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void PreThread(ThreadTree T) {
  if (T != NULL) {
    visit(T); // å…ˆå¤„ç†æ ¹ç»“ç‚¹
    if (T->ltag == 0) {
      PreThread(T->lchild); // å¦‚æœlchildä¸æ˜¯å‰é©±çº¿ç´¢,ç»§ç»­éå†å·¦å­æ ‘
    }
    PreThread(T->rchild);
  }
}

// å…ˆåºçº¿ç´¢åŒ–äºŒå‰æ ‘T
void CreatePreThread(ThreadTree T) {
  pre = NULL;      // preåˆå§‹ä¸ºNULL
  if (T != NULL) { // éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
    PreThread(T);
    if (pre->rchild == NULL)
      pre->rtag = 1; // å¤„ç†éå†çš„æœ€åä¸€ä¸ªç»“ç‚¹
  }
}
```

- ååºçº¿ç´¢åŒ–
```c++
#include <iostream>

typedef struct ThreadNode {
  int data;
  struct ThreadNode *lchild, *rchild;
  int ltag, rtag; // å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
} ThreadNode, *ThreadTree;

// å…¨å±€å˜é‡preï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;

void visit(ThreadNode *q) {
  if (q->lchild == NULL) { // å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
    q->lchild = pre;
    q->ltag = 1;
  }
  if (pre != NULL && pre->rchild == NULL) {
    pre->rchild = q; // å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
    pre->rtag = 1;
  }
  pre = q;
}

// ååºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void PostThread(ThreadTree T) {
  if (T != NULL) {
    PostThread(T->lchild); // ååºéå†å·¦å­æ ‘
    PostThread(T->rchild); // ååºéå†å³å­æ ‘
    visit(T);              // è®¿é—®æ ¹ç»“ç‚¹
  }
}

// ååºçº¿ç´¢åŒ–äºŒå‰æ ‘T
void CreatePostThread(ThreadTree T) {
  pre = NULL;      // preåˆå§‹åŒ–ä¸ºNULL
  if (T != NULL) { // éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
    PostThread(T); // åç»­çº¿ç´¢åŒ–äºŒå‰æ ‘
    if (pre->lchild == NULL) {
      pre->rtag = 1; // å¤„ç†éå†çš„æœ€åä¸€ä¸ªç»“ç‚¹
    }
  }
}
```

### 5.3.2 <font color='red'>çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±ï¼ˆåç»§ï¼‰[æ²¡æ•´ç†å®Œæ•´]</font>

> ä¸­åºçº¿ç´¢äºŒå‰æ ‘

- ä¸­åºçº¿ç´¢äºŒå‰æ ‘æ‰¾ä¸­åºåç»§
```c++
// æ‰¾åˆ°ä»¥Pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œç¬¬ä¸€ä¸ªè¢«ä¸­åºéå†çš„ç»“ç‚¹
ThreadNode *FirstNode(ThreadNode *p) {
  while (p->ltag == 0) // å¾ªç¯å¯»æ‰¾æœ€å·¦ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
    p = p->lchild;
  return p;
}

// åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„åç»§ç»“ç‚¹
ThreadNode *NextNode(ThreadNode *p) {
  if (p->rtag == 0) // å³å­æ ‘çš„æœ€å·¦ğŸ‘ˆä¸‹ç»“ç‚¹
    return FirstNode(p->rchild);
  else // rtag==1ï¼Œç›´æ¥è¿”å›åç»§çº¿ç´¢
    return p->rchild;
}

// å¯¹ä¸­åºçº¿ç´¢äºŒå‰æ ‘è¿›è¡Œä¸­åºéå†ï¼ˆåˆ©ç”¨çº¿ç´¢å®ç°çš„éé€’å½’ç®—æ³•ï¼‰
void InOrder(ThreadNode *T) {
  for (ThreadNode *p = FirstNode(T); p != NULL; p = NextNode(p))
    visit(p);
}
```

- ä¸­åºçº¿ç´¢äºŒå‰æ ‘æ‰¾ä¸­åºå‰é©±
```c++
// æ‰¾åˆ°ä»¥pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œæœ€åä¸€ä¸ªè¢«ä¸­åºéå†çš„ç»“ç‚¹
ThreadNode *LastNode(ThreadNode *p) {
  while (p->rtag == 0) // å¾ªç¯å¯»æ‰¾æœ€å³ğŸ‘‰ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
    p = p->rchild;
  return p;
}

// åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„å‰é©±ç»“ç‚¹
ThreadNode *PreNode(ThreadNode *p) {
  if (p->ltag == 0) // å·¦å­æ ‘çš„æœ€å³ä¸‹ç»“ç‚¹
    return LastNode(p->lchild);
  else // rtag==1ï¼Œç›´æ¥è¿”å›å‰é©±çº¿ç´¢
    return p->lchild;
}

// å¯¹ä¸­åºçº¿ç´¢äºŒå‰æ ‘è¿›è¡Œé€†å‘ä¸­åºéå†ï¼ˆåˆ©ç”¨çº¿ç´¢å®ç°çš„éé€’å½’ç®—æ³•ï¼‰
void RevInOrder(ThreadNode *T) {
  for (ThreadNode *p = LastNode(T); p != NULL; p = PreNode(p))
    visit(p);
}
```

---

> å…ˆåºçº¿ç´¢äºŒå‰æ ‘

- å…ˆåºçº¿ç´¢äºŒå‰æ ‘æ‰¾å…ˆåºå‰é©±
- å…ˆåºçº¿ç´¢äºŒå‰æ ‘æ‰¾å…ˆåºåç»§

---

> ååºçº¿ç´¢äºŒå‰æ ‘

- ååºçº¿ç´¢äºŒå‰æ ‘æ‰¾ååºå‰é©±
- ååºçº¿ç´¢äºŒå‰æ ‘ç€ååºåç»§

## 5.4 æ ‘ã€æ£®æ—

### 5.4.1 æ ‘çš„å­˜å‚¨ç»“æ„
- åŒäº²è¡¨ç¤ºæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰
```c++
#define MAX_TREE_SIZE 100           //æ ‘ä¸­æœ€å¤šç»“ç‚¹æ ‘

typedef struct{                     //æ ‘çš„ç»“ç‚¹å®šä¹‰
    ElemType data;                  //æ•°æ®å…ƒç´ 
    int parent;                     //åŒäº²ä½ç½®åŸŸ
}PTNode;

typedef struct{                     //æ ‘çš„ç»“æ„ç±»å‹
    PTNode nodes[MAX_TREE_SIZE];    //åŒäº²è¡¨ç¤º
    int n;                          //ç»“ç‚¹æ•°
}PTree;
```

- å­©å­è¡¨ç¤ºæ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰
```c++
struct CTNode{
    int child;                  //å­©å­ç»“ç‚¹åœ¨æ•°ç»„ä¸­çš„ä½ç½®
    struct CTNode *next;        //ä¸‹ä¸€ä¸ªå­©å­
};

typedef struct{
    ElemType data;
    struct CTNode *firstChild;  //ç¬¬ä¸€ä¸ªå­©å­
}CTBox;

typedef struct{
    CTBox nodes[MAX_TREE_SIZE];
    int n,r;
}CTree;
```

- å­©å­å…„å¼Ÿè¡¨ç¤ºæ³•ï¼ˆé“¾å¼å­˜å‚¨ï¼‰
```c++
typedef struct CSNode{
    ElemType data;                          //æ•°æ®åŸŸ
    struct CSNode *firstChild,*nextSibling; //ç¬¬ä¸€ä¸ªå­©å­å’Œå³å…„å¼ŸæŒ‡é’ˆ
}CSNode,*CSTree;
```
## 5.5 æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨
### 5.5.1 å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç 

# ç¬¬å…­ç« â€”â€”å›¾
## 6.1 å›¾çš„åŸºæœ¬æ¦‚å¿µ
## 6.2 å›¾çš„å­˜å‚¨åŠåŸºæœ¬æ“ä½œ
### 6.2.1 é‚»æ¥çŸ©é˜µæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰

> å¯¹äº **ä¸å¸¦æƒ** çš„æ— å‘å›¾ã€æœ‰å‘å›¾
```c++
#define MaxVertexNum 100                    //é¡¶ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
typedef struct{
    char Vex[MaxVertexNum];                 //é¡¶ç‚¹è¡¨
    int Edge[MaxVertexNum][MaxVertexNum];   //é‚»æ¥çŸ©é˜µï¼Œè¾¹è¡¨
    int vexnum,arcnum;                      //å›¾çš„å½“å‰é¡¶ç‚¹æ•°å’Œè¾¹æ•°/å¼§æ•°
}MGraph;
```
- æ€§è´¨

$è®¾å›¾Gçš„é‚»æ¥çŸ©é˜µä¸ºAï¼ˆçŸ©é˜µå…ƒç´ ä¸º 0/1ï¼‰ï¼Œåˆ™  A^n çš„å…ƒç´  A^n[i][j] \\ ç­‰äº ç”±é¡¶ç‚¹ i åˆ°é¡¶ç‚¹ j çš„é•¿åº¦ä¸º n çš„è·¯å¾„çš„æ•°ç›®$

> å¯¹äºå¸¦æƒå›¾ï¼ˆç½‘ï¼‰
```c++
#define MaxVertexNum 100                        //é¡¶ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
#define INFINITY æœ€å¤§çš„intå€¼                    //å®å®šä¹‰ å¸¸é‡ â€œæ— ç©·â€
typedef char VertexType;                        //é¡¶ç‚¹çš„æ•°æ®ç±»å‹
typedef int EdgeType;                           //å¸¦æƒå›¾ä¸­è¾¹ä¸Šæƒå€¼çš„æ•°æ®ç±»å‹
typedef struct{
    VertexType Vex[MaxVertexNum];               //é¡¶ç‚¹è¡¨
    EdgeType Edge[MaxVertexNum][MaxVertexNum];  //é‚»æ¥çŸ©é˜µï¼Œè¾¹çš„æƒå€¼è¡¨
    int vexnum,arcnum;                          //å›¾çš„å½“å‰é¡¶ç‚¹æ•°å’Œè¾¹æ•°/å¼§æ•°
}MGraph;
```

### 6.2.2 é‚»æ¥è¡¨æ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰
```c++
#define MaxVertexNum 100

//ç”¨é‚»æ¥è¡¨å­˜å‚¨çš„å›¾
typedef struct{
    AdjList vertices;
    int vexnum,arcnum;
}ALGraph;

//é¡¶ç‚¹
typedef struct VNode{
    VertexType data;        //é¡¶ç‚¹ä¿¡æ¯
    ArcNode *first;         //ç¬¬ä¸€æ¡è¾¹/å¼§
}VNode,AdjList[MaxVertexNum];

//â€œè¾¹/å¼§â€
typedef struct ArcNode{
    int adjvex;             //è¾¹/å¼§æŒ‡å‘å“ªä¸ªç»“ç‚¹
    struct ArcNode *next;   //æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
    //InfoType info;        //è¾¹æƒå€¼
}ArcNode;
```

## 6.3 å›¾çš„éå†
### 6.3.1 BFS å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•
```c++
#include <iostream>
using namespace std;

#define MaxVertexNum 100            //ç»“ç‚¹çš„æœ€å¤§ä¸ªæ•°
bool visited[MaxVertexNum];         //è®¿é—®æ ‡è®°æ•°ç»„

void BFSTraverse(Graph G){          //å¯¹å›¾Gè¿›è¡Œå¹¿åº¦ä¼˜å…ˆéå†
    for(int i=0;i<G.vexnum;i++){
        visited[i]=false;           //è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
    }
    InitQueue(Q);                   //åˆå§‹åŒ–è¾…åŠ©é˜Ÿåˆ—Q
    for(int i=0;i<G.vexnum;i++){    //ä»0å·é¡¶ç‚¹å¼€å§‹éå†
        if(!visited[i]){              //å¯¹æ¯ä¸ªè¿é€šåˆ†é‡è°ƒç”¨ä¸€æ¬¡BFSç®—æ³•
            BFS(G,i);               //è‹¥ç¬¬iä¸ªé¡¶ç‚¹æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ‰§è¡ŒBFS
        }
    }
}

//å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•
void BFS(Graph G,int v){            //ä»é¡¶ç‚¹vå‡ºå‘ï¼Œå¹¿åº¦ä¼˜å…ˆéå†å›¾G
    visit(v);                       //è®¿é—®åˆå§‹é¡¶ç‚¹v
    visited[v]=true;                //å¯¹é¡¶ç‚¹ v åšå·²è®¿é—®æ ‡è®°
    Enqueue(Q,v);                   //é¡¶ç‚¹vå…¥é˜Ÿåˆ—Q
    while(!isEmpty(Q)){             
        Dequeue(v);                 //é¡¶ç‚¹vå‡ºé˜Ÿåˆ—Q
        for(int w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){  //æ£€æµ‹vçš„æ‰€æœ‰é‚»æ¥ç‚¹
            if(!visited[w]){        //wä¸ºvçš„æœªè®¿é—®çš„é‚»æ¥é¡¶ç‚¹
                visit(w);           //è®¿é—®w
                visited[w]=true;      //å¯¹wåš å·²è®¿é—®æ ‡è®°
                Enqueue(Q,w);       //é¡¶ç‚¹wå…¥é˜Ÿåˆ—
            }
        }
    }
}

```

æ—¶é—´å¤æ‚åº¦ï¼š
1. é‚»æ¥çŸ©é˜µå­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ¯ä¸ªé¡¶ç‚¹çš„é‚»æ¥ç‚¹éƒ½éœ€è¦ $O(|V|)$ çš„æ—¶é—´ï¼Œæ€»å…±æœ‰ $|V|$ ä¸ªé¡¶ç‚¹
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|^2)$
2. é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ‰€æœ‰é¡¶ç‚¹çš„é‚»æ¥ç‚¹æ€»å…±éœ€è¦ $O(|E|)$ çš„æ—¶é—´
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|+|E|)$

### 6.3.2 DFS æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•
```c++
#define MaxVertexNum 100            //ç»“ç‚¹çš„æœ€å¤§ä¸ªæ•°
bool visited[MaxVertexNum];         //è®¿é—®æ ‡è®°æ•°ç»„

void DFSTraverse(Graph G){          //å¯¹å›¾Gè¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†
    for(int i=0;i<G.vexnum;i++){
        visited[i]=false;           //è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
    }
    for(int i=0;i<G.vexnum;i++){    //ä»0å·é¡¶ç‚¹å¼€å§‹éå†
        if(!visited[i]){            //å¯¹æ¯ä¸ªè¿é€šåˆ†é‡è°ƒç”¨ä¸€æ¬¡BFSç®—æ³•
            DFS(G,i);               //è‹¥ç¬¬iä¸ªé¡¶ç‚¹æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ‰§è¡ŒBFS
        }
    }
}

//æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•
void DFS(Graph G,int v){            //ä»é¡¶ç‚¹vå‡ºå‘ï¼Œæ·±åº¦ä¼˜å…ˆéå†å›¾G
    visit(v);                       //è®¿é—®åˆå§‹é¡¶ç‚¹v
    visited[v]=true;                //å¯¹é¡¶ç‚¹ v åšå·²è®¿é—®æ ‡è®°
    for(int w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){  //æ£€æµ‹vçš„æ‰€æœ‰é‚»æ¥ç‚¹
        if(!visited[w]){            //wä¸ºvçš„æœªè®¿é—®çš„é‚»æ¥é¡¶ç‚¹
            DFS(G,w);
        }
    }
}
```

æ—¶é—´å¤æ‚åº¦ï¼š
1. é‚»æ¥çŸ©é˜µå­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ¯ä¸ªé¡¶ç‚¹çš„é‚»æ¥ç‚¹éƒ½éœ€è¦ $O(|V|)$ çš„æ—¶é—´ï¼Œæ€»å…±æœ‰ $|V|$ ä¸ªé¡¶ç‚¹
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|^2)$
2. é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ‰€æœ‰é¡¶ç‚¹çš„é‚»æ¥ç‚¹æ€»å…±éœ€è¦ $O(|E|)$ çš„æ—¶é—´
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|+|E|)$

## 6.4åº”ç”¨
### 6.4.1 æœ€å°ç”Ÿæˆæ ‘
1. Primç®—æ³•
   ä»æŸä¸€ä¸ªé¡¶ç‚¹å¼€å§‹æ„å»ºç”Ÿæˆæ ‘ï¼›
   æ¯æ¬¡å°†ä»£ä»·æœ€å°çš„æ–°é¡¶ç‚¹çº³å…¥ç”Ÿæˆæ ‘ï¼Œç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½çº³å…¥ä¸ºæ­¢ï¼›
2. Kruskalç®—æ³•
   æ¯æ¬¡é€‰æ‹©ä¸€æ¡æƒå€¼æœ€å°çš„è¾¹ï¼Œä½¿è¿™æ¡è¾¹çš„ä¸¤å¤´è¿é€šï¼ˆåŸæœ¬å·²ç»è¿é€šçš„å°±ä¸é€‰ï¼‰ï¼›
   çŸ¥é“æ‰€æœ‰ç»“ç‚¹éƒ½è¿é€šï¼›

### 6.4.2 æœ€çŸ­è·¯å¾„

> å•æºæœ€çŸ­è·¯å¾„
1. BFS æ±‚å•æºæœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰
```c++
void BFS_MIN_Distance(Graph G,int u){
    //d[i] è¡¨ç¤ºä» u åˆ° i ç»“ç‚¹çš„æœ€çŸ­è·¯å¾„
    for(int i=0;i<G.vexnum;i++){
        d[i] = âˆ;                   //åˆå§‹åŒ–è·¯å¾„é•¿åº¦
        path[i] = -1;               //æœ€çŸ­è·¯å¾„ä»å“ªä¸ªé¡¶ç‚¹è¿‡æ¥
    }
    d[u] = 0;
    visited[u] = true;
    EnQueue(Q,u);
    while(!isEmpty(Q)){             //BFSä¸»è¿‡ç¨‹
        DeQueue(Q,u)                //é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿ
        for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u)){
            if(!visited[w]){        //w ä¸º u å°šæœªè®¿é—®çš„é‚»æ¥ç»“ç‚¹
                d[w] = d[u] + 1;    //è·¯å¾„é•¿åº¦+1
                path[w] = u;        //æœ€çŸ­è·¯å¾„åº”å½“ä» u åˆ° w
                visited[w] = true;  //è®¾ç½®å·²è®¿é—®æ ‡è®°
                EnQueue(Q,w);       //é¡¶ç‚¹ w å…¥é˜Ÿ
            }
        }
    }
}
```

2. Dijkstraç®—æ³• ï¼ˆè¿ªæ°æ–¯ç‰¹æ‹‰â€”â€”å¸¦æƒå›¾ã€æ— æƒå›¾ï¼‰

final[] ï¼šåˆå§‹åŒ–ä¸ºfalseï¼Œå¾ªç¯éå†æ‰€æœ‰ç»“ç‚¹ï¼Œæ‰¾åˆ°è¿˜æ²¡ç¡®å®šæœ€çŸ­è·¯å¾„ï¼Œä¸” dist æœ€å°çš„é¡¶ç‚¹ $V_i$ ,ä½¿å¾— final[i]=true
dist[] ï¼šè®°å½•äº†ä»æºç‚¹ $V_0$ åˆ°å…¶ä»–å„é¡¶ç‚¹å½“å‰çš„æœ€çŸ­è·¯å¾„é•¿åº¦
path[] ï¼špath[i]è¡¨ç¤ºä»æºç‚¹åˆ°é¡¶ç‚¹iä¹‹é—´çš„æœ€çŸ­è·¯å¾„çš„å‰é©±ç»“ç‚¹ï¼Œåˆå§‹åŒ–ä¸º -1


> å„ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·ç¦»

Floydç®—æ³• 

åˆå§‹åŒ–çŸ©é˜µ
![](/pictures/Floyd-V0.png)
![](/pictures/Floyd-V1.png)

$$
\begin{aligned}
& è‹¥ A^{(k-1)}[i][j] > A^{(k-1)}[i][k] + A^{(k-1)}[k][j] \\
& åˆ™ A^{(k)}[i][j] = A^{(k-1)}[i][k] + A^{(k-1)}[k][j]  \\
& path^{(k)}[i][j]=k  \\
& å¦åˆ™ A^{(k)} å’Œ path^{(k)} ä¿æŒåŸå€¼
\end{aligned}
$$

```c++
// å‡†å¤‡å·¥ä½œï¼Œæ ¹æ®å›¾çš„ä¿¡æ¯åˆå§‹åŒ–çŸ©é˜µ A å’Œ pathï¼ˆå¦‚ä¸Šå›¾ï¼‰
for(int k=0;k<n;k++){                   //è€ƒè™‘ä»¥ Vk ä½œä¸ºä¸­è½¬ç‚¹
    for(int i=0;i<n;i++){               //éå†æ•´ä¸ªçŸ©é˜µï¼Œiä¸ºè¡Œå·ï¼Œjä¸ºåˆ—å·
        for(int j=0;j<n;j++){
            if(A[i][j]>A[i][k]+A[k][j]){//ä»¥ Vk ä¸ºä¸­è½¬ç‚¹çš„è·¯å¾„æ›´çŸ­
                A[i][j]=A[i][k]+A[k][j];//æ›´æ–°æœ€çŸ­è·¯å¾„é•¿åº¦
                path[i][j]=k;           //ä¸­è½¬ç‚¹
            }
        }
    }
}
```

$$
æ—¶é—´å¤æ‚åº¦ O(|V|^3) \\
ç©ºé—´å¤æ‚åº¦ O(|V|^2)
$$

### 6.4.3 æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰æè¿°è¡¨è¾¾å¼

### 6.4.4 æ‹“æ‰‘æ’åº(é€†æ‹“æ‰‘æ’åº)
AOVç½‘ï¼šç”¨DAGå›¾è¡¨ç¤ºä¸€ä¸ªå·¥ç¨‹ï¼Œå…¶é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨ï¼Œç”¨æœ‰å‘è¾¹ $<V_i,V_j>$ è¡¨ç¤ºæ´»åŠ¨ $V_i$ å¿…é¡»å…ˆäºæ´»åŠ¨ $V_j$ çš„è¿™æ ·ä¸€ç§å…³ç³»ï¼Œåˆ™å°†è¿™ç§æœ‰å‘å›¾ç§°ä¸ºé¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨çš„ç½‘ç»œï¼Œè®°ä¸ºAOVç½‘ã€‚

æ‹“æ‰‘æ’åºç®—æ³•ï¼š
1. ä»AOVç½‘ä¸­é€‰æ‹©ä¸€ä¸ªå…¥åº¦ä¸º0çš„é¡¶ç‚¹è¾“å‡º
2. åˆ å»æ­¤é¡¶ç‚¹ï¼Œå¹¶åˆ é™¤ä»¥æ­¤é¡¶ç‚¹ä¸ºå¼§å°¾çš„å¼§
3. é‡å¤æ­¥éª¤ç›´åˆ°è¾“å‡ºå›¾ä¸­å…¨éƒ¨é¡¶ç‚¹ï¼Œæˆ–è€…æ‰¾ä¸åˆ°å…¥åº¦ä¸º0çš„é¡¶ç‚¹ä¸ºæ­¢ã€åè€…è¡¨ç¤ºè¯¥å›¾ä¸æ˜¯DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ã€‘

```c++
#define MaxVertexNum 100    //å›¾ä¸­é¡¶ç‚¹çš„æœ€å¤§æ•°ç›®

typedef struct ArcNode{     //è¾¹è¡¨ç»“ç‚¹
    int adjvex;             //è¯¥å¼§æ‰€æŒ‡å‘çš„é¡¶ç‚¹çš„ä½ç½®
    struct ArcNode *nextArc;//æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
    //InfoType info;       //ç½‘çš„è¾¹æƒå€¼
}ArcNode;

typedef struct VNode{       //é¡¶ç‚¹è¡¨ç»“ç‚¹
    VertexType data;        //é¡¶ç‚¹ä¿¡æ¯
    ArcNode *firstArc;      //æŒ‡å‘ç¬¬ä¸€æ¡ä¾é™„äºè¯¥é¡¶ç‚¹çš„å¼§çš„æŒ‡é’ˆ
}VNode,AdjList[MaxVertexNum];

typedef struct{
    AdjList vertices;       //é‚»æ¥è¡¨
    int vexnum,arcnum;      //å›¾çš„é¡¶ç‚¹æ•°å’Œå¼§æ•°
}Graph;                     //Graph æ˜¯ä»¥é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ç±»å‹

bool TopologicalSort(Graph G){
    InitStack(S);           //åˆå§‹åŒ–æ ˆ
    for(int i=0;i<G.vexnum;i++){
        if(indegree[i]==0)  //degreeæ•°ç»„è®°å½•å½“å‰é¡¶ç‚¹çš„å…¥åº¦
            Push(S,i);      //å°†æ‰€æœ‰å…¥åº¦ä¸º0çš„é¡¶ç‚¹å…¥æ ˆ
    }
    int count=0;            //è®¡æ•°ï¼Œè®°å½•å½“å‰å·²ç»è¾“å‡ºçš„é¡¶ç‚¹æ•°
    while(!isEmpty(S)){
        Pop(S,i);           //æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
        print[count++]=i;   //printæ•°ç»„è®°å½•æ‹“æ‰‘åºåˆ—ï¼Œè¾“å‡ºé¡¶ç‚¹i
        for(p=G.vertices[i].firstArc; p ; p = p->nextArc ){ //å°†æ‰€æœ‰iæŒ‡å‘çš„é¡¶ç‚¹çš„å…¥åº¦å‡1ï¼Œå¹¶ä¸”å°†å…¥åº¦ä¸º0çš„é¡¶ç‚¹å‹å…¥æ ˆS
            v = p -> adjvex;    
            if(!(--indegree[v]))
                Push(S,v);  //å…¥åº¦ä¸º0ï¼Œåˆ™å…¥æ ˆ
        }
    }

    if(count < G.vexnum)
        return false;       //æ’åºå¤±è´¥ï¼Œæœ‰å‘å›¾ä¸­æœ‰å›è·¯
    else
        return true;        //æ‹“æ‰‘æ’åºæˆåŠŸ
}
```

é€†æ‹“æ‰‘æ’åºç®—æ³•ï¼š
1. ä»AOVç½‘ä¸­é€‰æ‹©ä¸€ä¸ªå‡ºåº¦ä¸º0çš„é¡¶ç‚¹è¾“å‡º
2. åˆ å»æ­¤é¡¶ç‚¹ï¼Œå¹¶åˆ é™¤ä»¥æ­¤é¡¶ç‚¹ä¸ºå¼§å¤´çš„å¼§
3. é‡å¤æ­¥éª¤ç›´åˆ°è¾“å‡ºå›¾ä¸­å…¨éƒ¨é¡¶ç‚¹ï¼Œæˆ–è€…æ‰¾ä¸åˆ°å‡ºåº¦ä¸º0çš„é¡¶ç‚¹ä¸ºæ­¢ã€åè€…è¡¨ç¤ºè¯¥å›¾ä¸æ˜¯DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ã€‘

1. é€†é‚»æ¥è¡¨

2. DFSç®—æ³•
```c++
#define MaxVertexNum 100            //ç»“ç‚¹çš„æœ€å¤§ä¸ªæ•°
bool visited[MaxVertexNum];         //è®¿é—®æ ‡è®°æ•°ç»„

void DFSTraverse(Graph G){          //å¯¹å›¾Gè¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†
    for(int i=0;i<G.vexnum;i++){
        visited[i]=false;           //è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
    }
    for(int i=0;i<G.vexnum;i++){    //ä»0å·é¡¶ç‚¹å¼€å§‹éå†
        if(!visited[i]){              //å¯¹æ¯ä¸ªè¿é€šåˆ†é‡è°ƒç”¨ä¸€æ¬¡BFSç®—æ³•
            DFS(G,i);               //è‹¥ç¬¬iä¸ªé¡¶ç‚¹æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ‰§è¡ŒBFS
        }
    }
}

//æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•
void DFS(Graph G,int v){            //ä»é¡¶ç‚¹vå‡ºå‘ï¼Œæ·±åº¦ä¼˜å…ˆéå†å›¾G
    visit(v);                       //è®¿é—®åˆå§‹é¡¶ç‚¹v
    visited[v]=true;                //å¯¹é¡¶ç‚¹ v åšå·²è®¿é—®æ ‡è®°
    for(int w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){  //æ£€æµ‹vçš„æ‰€æœ‰é‚»æ¥ç‚¹
        if(!visited[w]){            //wä¸ºvçš„æœªè®¿é—®çš„é‚»æ¥é¡¶ç‚¹
            DFS(G,w);
        }
    }
    print(v);                       //è¾“å‡ºé¡¶ç‚¹
}
```

### 6.4.5 å…³é”®è·¯å¾„
AOEç½‘ï¼šåœ¨å¸¦æƒæœ‰å‘å›¾ä¸­ï¼Œä»¥é¡¶ç‚¹ä»£è¡¨äº‹ä»¶ï¼Œä»¥æœ‰å‘è¾¹è¡¨ç¤ºæ´»åŠ¨ï¼Œä»¥è¾¹ä¸Šçš„æƒå€¼è¡¨ç¤ºå®Œæˆè¯¥æ´»åŠ¨çš„å¼€é”€ï¼ˆæ—¶é—´ï¼‰ï¼Œç§°ä¹‹ä¸ºç”¨è¾¹è¡¨ç¤ºæ´»åŠ¨çš„ç½‘ç»œã€‚

# ç¬¬ä¸ƒç« â€”â€”æŸ¥æ‰¾

## 7.1 æŸ¥æ‰¾çš„åŸºæœ¬æ¦‚å¿µ

## 7.2 é¡ºåºã€æŠ˜åŠã€åˆ†å—
### 7.2.1 é¡ºåºæŸ¥æ‰¾

```c++
typedef struct{         //æŸ¥æ‰¾è¡¨çš„æ•°æ®ç»“æ„ï¼ˆé¡ºåºè¡¨ï¼‰
    ElemType *elem;     //åŠ¨æ€æ•°æ®åŸºå€
    int TableLen;       //è¡¨çš„é•¿åº¦
}SSTable;

//é¡ºåºæŸ¥æ‰¾_éå“¨å…µ
int Search_Seq(SSTable ST,ElemType key){
    int i;
    for(i=0;i<ST.TableLen && ST.elem[i]!=key;i++){  //æŸ¥æ‰¾æˆåŠŸï¼Œåˆ™è¿”å›å…ƒç´ ä¸‹æ ‡ï¼›æŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™è¿”å›-1
        return i==ST.Table?-1:i;
    }
}

//é¡ºåºæŸ¥æ‰¾_å“¨å…µï¼Œæ•°æ®ä»ä¸‹æ ‡1å¼€å§‹å­˜å‚¨
int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0]=key;                          //å“¨å…µ   
    int i;
    for(i=ST.TableLen;ST.elem[i]!=key;--i){  //ä»åå¾€å‰æŸ¥æ‰¾
        return i;//æŸ¥æ‰¾æˆåŠŸï¼Œåˆ™è¿”å›å…ƒç´ ä¸‹æ ‡ï¼›æŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™è¿”å›0
    }
}
```

### 7.2.2 æŠ˜åŠæŸ¥æ‰¾
åˆç§°äºŒåˆ†æŸ¥æ‰¾ï¼Œä»…é€‚ç”¨äº <font color='red'>æœ‰åº</font> çš„ <font color='red'>é¡ºåºè¡¨</font>

$å…·æœ‰nä¸ª (n>0) ç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„é«˜åº¦ä¸º \log_2{(n+1)} æˆ– \log_2{n}+1$

$æ—¶é—´å¤æ‚åº¦ \log_{2}{n}$

```c++
typedef struct{         //æŸ¥æ‰¾è¡¨çš„æ•°æ®ç»“æ„ï¼ˆé¡ºåºè¡¨ï¼‰
    ElemType *elem;     //åŠ¨æ€æ•°æ®åŸºå€
    int TableLen;       //è¡¨çš„é•¿åº¦
}SSTable;

int Binary_Search(SSTable L,ElemType key){
    int low=0,high=L.TableLen-1,mid;
    while(low<=high){
        mid=(low+high)/2;       //å–ä¸­é—´ä½ç½®
        if(L.elem[mid]==key)
            return mid;         //æŸ¥æ‰¾æˆåŠŸåˆ™è¿”å›æ‰€åœ¨ä½ç½®
        else if(L.ele[mid]>key)
            high = mid - 1;     //ä»å‰åŠéƒ¨åˆ†ç»§ç»­æŸ¥æ‰¾
        else
            low = mid + 1;      //ä»ååŠéƒ¨åˆ†ç»§ç»­æŸ¥æ‰¾
    }
    return -1;                  //æŸ¥æ‰¾å¤±è´¥ï¼Œè¿”å› -1
}
```

### 7.2.3 åˆ†å—æŸ¥æ‰¾
```c++
//ç´¢å¼•è¡¨
typedef struct{
    ElemType maxValue;  //æ¯ä¸ªåˆ†å—çš„æœ€å¤§å…³é”®å­—
    int low,high;       //å­˜å‚¨ç©ºé—´çš„ç´¢å¼•ä¸‹æ ‡èŒƒå›´
}Index;

//é¡ºåºè¡¨å®é™…å­˜å‚¨çš„å…ƒç´ 
ElemType List[100];
```
å‡è®¾ï¼Œé•¿åº¦ä¸º n çš„æŸ¥æ‰¾è¡¨è¢«å‡åŒ€åœ°åˆ†ä¸º b å—ï¼Œæ¯å— s ä¸ªå…ƒç´ 
åˆ†å—æŸ¥æ‰¾çš„å¹³å‡æŸ¥æ‰¾é•¿åº¦ä¸º $ASL_{åˆ†å—æŸ¥æ‰¾}=ASL_{ç´¢å¼•æŸ¥æ‰¾}+ASL_{å—å†…æŸ¥æ‰¾}$
â‘  ç”¨ <font color='blue'>é¡ºåº</font> æŸ¥æ‰¾ç´¢å¼•è¡¨
$$
\begin{aligned}
n &=b*s   \\[5px]
ASL_{åˆ†å—æŸ¥æ‰¾} &=ASL_{ç´¢å¼•é¡ºåº}+ASL_{å—å†…é¡ºåº}    \\[5px] 
ASL_{ç´¢å¼•é¡ºåº} &=\frac{1+2+ \dots +b}{b}=\frac{b+1}{2}    \\[5px]
ASL_{å—å†…é¡ºåº} &=\frac{1+2+ \dots +s}{s}=\frac{s+1}{2}
\end{aligned}
$$

$$
\begin{aligned}
    ASL &=\frac{b+1}{2}+\frac{s+1}{2} \\[5px]
        &=\frac{\frac{n}{s}+1}{2}+\frac{s+1}{2} \\[5px]
        &=\frac{s^2+2s+n}{2s},å½“s=\sqrt{n}æ—¶ï¼ŒASL_{æœ€å°}=\sqrt{n}+1
\end{aligned}
$$

â‘¡ ç”¨ <font color='blue'>æŠ˜åŠ</font> æŸ¥æ‰¾ç´¢å¼•è¡¨
$$ASL=\lceil \log_{2}{(b+1)} \rceil+\frac{s+1}{2}$$

## 7.3 æ ‘å‹æŸ¥æ‰¾
### 7.3.1 äºŒå‰æ’åºæ ‘ï¼ˆäºŒå‰æœç´¢æ ‘BSTï¼‰
å»ºç«‹ã€æŸ¥æ‰¾ã€æ’å…¥ç­‰ç›¸å…³æ“ä½œ
```c++
//äºŒå‰æ’åºæ ‘ç»“ç‚¹
typedef struct BSTNode{
    int key;
    struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree;

//åœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾å€¼ä¸º key çš„ç»“ç‚¹
BSTNode *BST_Search(BSTree T,int key){
    while(T!=NULL && key != T->key){    //è‹¥æ ‘ç©ºæˆ–ç­‰äºæ ¹ç»“ç‚¹å€¼ï¼Œåˆ™ç»“æŸå¾ªç¯
        if(key < (T->key))
            T=T->lchild;                //å°äºï¼Œåˆ™åœ¨å·¦å­æ ‘ä¸ŠæŸ¥æ‰¾
        else
            T=T->rchild;                //å¤§äºï¼Œåˆ™åœ¨å³å­æ ‘ä¸ŠæŸ¥æ‰¾
    }
    return T;
}

//åœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾å€¼ä¸º key çš„ç»“ç‚¹ï¼ˆé€’å½’å®ç°ï¼‰
BSTNode *BSTSearch(BSTree T,int key){
    if(T==NULL)
        return NULL;    //æŸ¥æ‰¾å¤±è´¥
    if(key==T->key)
        return T;          //æŸ¥æ‰¾æˆåŠŸ
    else if(key < T->key)
        return BSTSearch(T->lchild,key);    //åœ¨å·¦å­æ ‘ä¸­æŸ¥æ‰¾
    else
        return BSTSearch(T->rchild,key);    //åœ¨å³å­æ ‘ä¸­æŸ¥æ‰¾
}

//åœ¨äºŒå‰æ’åºæ ‘æ’å…¥å…³é”®å­—ä¸º k çš„æ–°ç»“ç‚¹ï¼ˆé€’å½’å®ç°ï¼‰
int BST_Insert(BSTree &T,int k){
    if(T==NULL){                            //åŸæ ‘ä¸ºç©ºï¼Œæ–°æ’å…¥çš„ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹
        T=(BSTree)malloc(sizeof(BSTNode));
        T->key = k;
        T->lchild=T->rchild=NULL;
        return 1;                               //è¿”å› 1 ï¼Œæ’å…¥æˆåŠŸ
    }
    else if(k==T->key)                    //æ ‘ä¸­å­˜åœ¨ç›¸åŒå…³é”®å­—çš„ç»“ç‚¹ï¼Œæ’å…¥å¤±è´¥ï¼Œè¿”å› 0
        return 0;
    else if( k < T->key)                   //æ’å…¥åˆ° T çš„å·¦å­æ ‘ 
        return BST_Insert(T->lchild,k);
    else                                        //æ’å…¥åˆ° T çš„å³å­æ ‘
        return BST_Insert(T->rchild,k);
}

//æŒ‰ç…§ str[] ä¸­çš„å…³é”®å­—åºåˆ—å»ºç«‹äºŒå‰æ’åºæ ‘
void Create_BST(BSTree &T,int str[],int n){
    T=NULL;                    //åˆå§‹åŒ– T ä¸ºç©ºæ ‘
    int i=0;
    while(i<n){                  //ä¾æ¬¡å°†æ¯ä¸ªå…³é”®å­—æ’å…¥åˆ°äºŒå‰æ’åºæ ‘ä¸­
        BST_Insert(T,str[i]);
        i++;
    }
}
```
### 7.3.2 å¹³è¡¡äºŒå‰æ ‘
```c++
#include<iostream>
using namespace std;
typedef struct AVLNode{
    int key;        //ç»“ç‚¹å…³é”®è¯
    int balance;    //å¹³è¡¡å› å­
    struct AVLNode *lchild,*rchild;
}AVLNode,*AVLTree
```

## 7.4 Bæ ‘å’ŒB+æ ‘

```c++
//5å‰æ’åºæ ‘çš„ç»“ç‚¹å®šä¹‰
struct Node{
    ElemType keys[4];       //æœ€å¤š4ä¸ªå…³é”®å­—
    struct Node *child[5];  //æœ€å¤š5ä¸ªå­©å­
    int num;                //ç»“ç‚¹ä¸­æœ‰å‡ ä¸ªå…³é”®å­—
}
```

> mé˜¶Bæ ‘çš„æ ¸å¿ƒç‰¹æ€§
> 1. æ ¹ç»“ç‚¹çš„å­æ ‘æ•° âˆˆ [ 2 , m ],å…³é”®å­—ä¸ªæ•°âˆˆ[1 , m-1]
>       å…¶ä»–å­æ ‘çš„å­æ ‘æ•° âˆˆ $[ \lceil m/2 \rceil ,m]$,å…³é”®å­—ä¸ªæ•°âˆˆ$[ \lceil m/2 \rceil-1 ,m-1]$
> 2. å¯¹ä»»ä¸€ç»“ç‚¹ï¼Œå…¶æ‰€æœ‰å­æ ‘çš„é«˜åº¦ç›¸åŒ
> 3. å…³é”®å­—çš„å€¼ï¼šå­æ ‘0 < å…³é”®å­—1 < å­æ ‘1 < å…³é”®å­—2 ...

<font size=5px>å¦‚ä½•ä¿è¯æŸ¥æ‰¾æ•ˆç‡</font>

ç­–ç•¥1ï¼šmå‰æŸ¥æ‰¾æ ‘ä¸­ï¼Œè§„å®š <font color='red'>é™¤äº†æ ¹ç»“ç‚¹å¤–</font>ï¼Œä»»ä½•ç»“ç‚¹è‡³å°‘æœ‰$\color{red}{\lceil m/2 \rceil}$ä¸ªåˆ†å‰ï¼Œå³è‡³å°‘å«æœ‰ $\color{red}{\lceil m/2 \rceil-1}$ ä¸ªå…³é”®å­—
&emsp;exampleï¼š
&emsp;å¯¹äº5å‰æ’åºæ ‘ï¼Œé™¤äº†æ ¹ç»“ç‚¹å¤–ï¼Œä»»ä½•ç»“ç‚¹éƒ½è‡³å°‘æœ‰3ä¸ªåˆ†æ”¯ï¼Œ2ä¸ªå…³é”®å­—

ç­–ç•¥2ï¼šmå‰æŸ¥æ‰¾æ ‘ä¸­ï¼Œè§„å®šå¯¹äºä»»ä½•ä¸€ä¸ªç»“ç‚¹ï¼Œå…¶æ‰€æœ‰å­æ ‘çš„é«˜åº¦éƒ½è¦ç›¸åŒ

æ‰€æœ‰éå¶èŠ‚ç‚¹çš„ç»“æ„å¦‚ä¸‹ï¼š

$$
K_i ä»£è¡¨ç»“ç‚¹çš„å…³é”®å­—    \\[5px]
P_i ä»£è¡¨æŒ‡å‘å­æ ‘æ ¹ç»“ç‚¹çš„æŒ‡é’ˆ    \\[5px]
\begin{array}{|c|c|c|c|c|c|c|c|c|}
 n & P_0 & K_1 & P_1 & K_2 & P_2 & \dots & K_n & P_n 
\end{array}
$$

## 7.5 æ•£åˆ—è¡¨ï¼ˆå“ˆå¸Œè¡¨ï¼‰
æ„é€ æ–¹æ³•ï¼š
1. é™¤ç•™ä½™æ•°æ³• $\quad H(key)=key\mod{p}$
2. ç›´æ¥å®šå€æ³• $\quad H(key)=key \quad æˆ–è€… \quad H(key)=a*key+b \quad$ è®¡ç®—ç®€å•ï¼Œä¸ä¼šäº§ç”Ÿå†²çªï¼Œé€‚ç”¨äºå…³é”®å­—åˆ†å¸ƒåŸºæœ¬è¿ç»­çš„æƒ…å†µ
3. æ•°å­—åˆ†ææ³•  &emsp; é€‰å–æ•°ç åˆ†å¸ƒè¾ƒä¸ºå‡åŒ€çš„è‹¥å¹²ä½ä½œä¸ºæ•£åˆ—åœ°å€ã€æ¯”å¦‚æ‰‹æœºå·ã€‘
4. å¹³æ–¹å–ä¸­æ³•  &emsp; å–å…³é”®å­—çš„å¹³æ–¹å€¼çš„ä¸­é—´å‡ ä½ä½œä¸ºæ•£åˆ—åœ°å€

è§£å†³å†²çªçš„æ–¹æ³•ï¼š
1. å¼€æ”¾å®šå€æ³•
   1. çº¿æ€§æ¢æµ‹æ³•
   2. å¹³æ–¹æ¢æµ‹æ³•
   3. ä¼ªéšæœºåºåˆ—æ³•
   4. å†æ•£åˆ—æ³•
2. æ‹‰é“¾æ³•


# ç¬¬å…«ç« â€”â€”æ’åº
## 8.1 æ’å…¥æ’åº
1. ç›´æ¥æ’å…¥æ’åºï¼ˆå“¨å…µä¸å¦ï¼‰
2. æŠ˜åŠæ’å…¥æ’åº
3. å¸Œå°”æ’åº
```c++
//ç›´æ¥æ’å…¥æ’åº
void InsertSort(int A[],int n){
    int i,j,temp;
    for(i=0;i<n;i++){       //å°†å„å…ƒç´ æ’å…¥å·²æ’å¥½åºçš„åºåˆ—ä¸­
        temp=A[i];          //è‹¥A[i]å…³é”®å­—å°äºå‰é©±
        for(j=i-1;j>=0 && A[j]>temp;--j){   //æ£€æŸ¥æ‰€æœ‰å‰é¢å·²æ’å¥½åºçš„å…ƒç´ 
            A[j+1]=A[j];    //æ‰€æœ‰å¤§äºtempä¹Ÿå°±æ˜¯A[i]çš„å…ƒç´ éƒ½å¾€åæŒªä½
        }
        A[j+1]=temp;        //å¤åˆ¶åˆ°æ’å…¥ä½ç½®
    }
}

//ç›´æ¥æ’å…¥æ’åºï¼ˆå¸¦å“¨å…µï¼‰æ•°ç»„å­˜å‚¨ä»ä¸‹æ ‡1å¼€å§‹
void InsertSort(int A[],int n){
    int i,j;
    for(i=2;i<n;i++){
        if(A[i]<A[i-1]){
            A[0]=A[i];
            for(j=i-1;A[0]<A[j];--j){
                A[j+1]=A[j];
            }
            A[j+1]=A[0];
        }
    }
}

//æŠ˜åŠæ’å…¥æ’åº
void InsertSort(int A[],int n){
    int i,j,low,high,mid;
    for(i=2;i<=n;i++){          //ä¾æ¬¡å°†A[2]~A[n]æ’å…¥å‰é¢çš„å·²æ’åºåºåˆ—
        A[0]=A[i];              //å°†A[i]æš‚å­˜åˆ°A[0]
        low=1;
        high=i-1;               //è®¾ç½®æŠ˜åŠæŸ¥æ‰¾çš„èŒƒå›´
        while(low<=high){       //æŠ˜åŠæŸ¥æ‰¾ï¼ˆé€’å¢æœ‰åºåºåˆ—ï¼‰
            mid=(low+high)/2;
            if(A[mid]>A[0])
                high = mid-1;
            else
                low = mid+1;
        }
        for(j=i-1;j>=high+1;--j){
            A[j+1]=A[j];        //ç»Ÿä¸€åç§»å…ƒç´ ï¼Œç©ºå‡ºæ’å…¥ä½ç½®
        }
        A[high+1]=A[0];         //æ’å…¥æ“ä½œ
    }
}

//å¸Œå°”æ’åº
void ShellSort(int A[],int n){
    int d,i,j;              //A[0]åªæ˜¯æš‚å­˜å•å…ƒï¼Œä¸æ˜¯å“¨å…µï¼Œå½“j<=0æ—¶ï¼Œæ’å…¥ä½ç½®å·²åˆ°
    for(d=n/2;d>=1;d=d/2){  //æ­¥é•¿å˜åŒ–
        for(i=d+1;i<=n;i++){
            if(A[i]<A[i-d]){//éœ€å°†A[i]æ’å…¥æœ‰åºå¢é‡å­è¡¨
                A[0]=A[i];  //æš‚å­˜A[0]
                for(j=i-d;j>0&&A[0]<A[j];j-=d){
                    A[j+d]=A[j];    //è®°å½•åç§»ï¼Œå¯»æ‰¾æ’å…¥ä½ç½®
                }
                A[j+d]=A[0];//æ’å…¥
            }
        }
    }
}
```

## 8.2 äº¤æ¢æ’åº
1. å†’æ³¡æ’åº
2. å¿«é€Ÿæ’åº

```c++
//å†’æ³¡æ’åº
void swap(int& a,int &b){
    int temp = a;
    a = b;
    b = temp;
}

void BubbleSort(int A[],int n){
    for(int i=0;i<n-1;i++){
        bool flag=false;            //è¡¨ç¤ºæœ¬è¶Ÿå†’æ³¡æ˜¯å¦å‘ç”Ÿäº¤æ¢çš„æ ‡å¿—
        for(int j=n-1;j>i;j--){     //ä¸€è¶Ÿå†’æ³¡è¿‡ç¨‹
            if(A[j-1]>A[j]){        //è‹¥ä¸ºé€†åº
                swap(A[j-1],A[j])
                flag=true;
            }
            if(flag==false)         //æœ¬è¶Ÿéå†åæ²¡æœ‰å‘ç”Ÿäº¤æ¢ï¼Œè¯´æ˜è¡¨å·²ç»æœ‰åº
                return;
        }
    }
}

//å¿«é€Ÿæ’åº
void QuickSort(int A[],int low,int high){
    if(low<high){                           //é€’å½’è·³å‡ºçš„æ¡ä»¶
        int pivotpos=Partition(A,low,high); //åˆ’åˆ†
        QuickSort(A,low,pivotpos-1);        //åˆ’åˆ†å·¦å­è¡¨
        QuickSort(A,pivotpos+1,high);       //åˆ’åˆ†å³å­è¡¨
    }
}

int Partition(int A[],int low,int high){
    int pivot=A[low];                           //ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºæ¢è½´
    while(low<high){                            //ç”¨lowã€highæœç´¢æ¢è½´çš„æœ€ç»ˆä½ç½®
        while(low<high&&A[high]>=pivot) --high;
        A[low]=A[high];                         //æ¯”æ¢è½´å°çš„å…ƒç´ ç§»åŠ¨åˆ°å·¦ç«¯
        while(low<high&&A[low]<=pivot) ++low;
        A[high]=A[low];                         //æ¯”æ¢è½´å¤§çš„å…ƒç´ ç§»åŠ¨åˆ°å³ä¾§
    }
    A[low]=pivot;                               //æ¢è½´å…ƒç´ å­˜æ”¾åˆ°æœ€ç»ˆä½ç½®
    return low;                                 //è¿”å›å­˜æ”¾æ¢è½´çš„æœ€ç»ˆä½ç½®
}
```

## 8.3 é€‰æ‹©æ’åº
1. ç®€å•é€‰æ‹©æ’åº
2. æ¨æ’åº

```c++
//ç®€å•é€‰æ‹©æ’åº
void SelectSort(int A[],int n){
    for(int i=0;i<n-1;i++){         //ä¸€å…±è¿›è¡Œn-1è¶Ÿ
        int min=i;                  //è®°å½•æœ€å°å…ƒç´ ä½ç½®
        for(int j=i+1;j<n;j++){     //åœ¨A[i...n-1]ä¸­é€‰æ‹©æœ€å°çš„å…ƒç´ 
            if(A[j]<A[min]) min=j;  //æ›´æ–°æœ€å°å…ƒç´ ä½ç½®
        }
        if(min!=i)
            swap(A[i],A[min]);      //å°è£…äº¤æ¢å…ƒç´ 
    }
}

//å †æ’åº

//å»ºç«‹å¤§æ ¹å †
void BuildMaxHeap(int A[],int len){
    for(int i=len/2;i>0;i--)        //ä»åå¾€å‰è°ƒæ•´æ‰€æœ‰éç»ˆç«¯ç»“ç‚¹
        HeadAdject(A,i,len);
}

//å°†ä»¥kä¸ºæ ¹çš„å­æ ‘è°ƒæ•´ä¸ºå¤§æ ¹å †
void HeadAdjust(int A[],int k,int len){
    A[0]=A[k];                      //A[0]æš‚å­˜å­æ ‘çš„æ ¹ç»“ç‚¹
    for(int i=2*k;i<=len;i*=2){     //æ²¿ç€keyè¾ƒå¤§çš„ç»“ç‚¹å¾€ä¸‹ç­›é€‰
        if(i<len && A[i]<A[i+1])
            i++;                    //å–keyè¾ƒå¤§çš„ç»“ç‚¹å­ç»“ç‚¹çš„ä¸‹æ ‡
        if(A[0]>A[i])               //ç­›é€‰ç»“æŸ
            break;
        else{
            A[k]=A[i];              //å°†A[i]è°ƒæ•´åˆ°åŒäº²ç»“ç‚¹ä¸Š
            k=i;                    //ä¿®æ”¹kå€¼ï¼Œä»¥ä¾¿ç»§ç»­å‘ä¸‹ç­›é€‰
        }
    }
    A[k]=A[0];                      //è¢«ç­›é€‰çš„å€¼æ”¾å…¥æœ€ç»ˆä½ç½®
}

void HeapSort(int A[],int len){
    BuildMaxHeap(A,len);        //åˆå§‹å»ºå †
    for(int i=len;i>1;i--){     //n-1è¶Ÿçš„äº¤æ¢å’Œå»ºå †è¿‡ç¨‹
        swap(A[i],A[1]);        //å †é¡¶å…ƒç´ å’Œå †åº•å…ƒç´ äº¤æ¢
        HeadAdjust(A,1,i-1);    //å‰©ä½™å¾…æ’åºå…ƒç´ æ•´ç†æˆå †
    }
}
```

## 8.4 å½’å¹¶æ’åºå’ŒåŸºæ•°æ’åº
### 8.4.1 å½’å¹¶æ’åº
```c++
#include <iostream>
using namespace std;

int *B=(int *)malloc(n*sizeof(int));    //è¾…åŠ©æ•°ç»„B

//A[low...mid] A[mid+1...high]å„è‡ªæœ‰åºï¼Œå°†ä¸¤éƒ¨åˆ†å½’å¹¶
void Merge(int A[],int low,int mid,int high){
    int i,j,k;
    for(k=low;k<=high;k++)
        B[k]=A[k];                      //å°†Aä¸­æ‰€æœ‰å…ƒç´ å¤åˆ¶åˆ°Bä¸­
    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
        if(B[i]<=B[j])
            A[k]=B[i++];                //å°†è¾ƒå°å€¼å¤åˆ¶åˆ°Aä¸­
        else
            A[k]=B[j++];
    }
    while(i<=mid) A[k++]=B[i++];
    while(j<=high) A[k++]=B[j++];
}

void MergeSort(int A[],int low,int high){
    if(low<high){
        int mid=(low+high)/2;       //ä»ä¸­é—´åˆ’åˆ†
        MergeSort(A,low,mid);       //å¯¹å·¦åŠéƒ¨åˆ†å½’å¹¶æ’åº
        MergeSort(A,mid+1,high);    //å¯¹å³åŠéƒ¨åˆ†å½’å¹¶æ’åº
        Merge(A,low,mid,high);      //å½’å¹¶
    }
}
```
### 8.4.2 åŸºæ•°æ’åº
æ“…é•¿è§£å†³çš„é—®é¢˜ï¼š
1. æ•°æ®å…ƒç´ çš„å…³é”®å­—å¯ä»¥æ–¹ä¾¿åœ°æ‹†åˆ†ä¸ºdç»„ï¼Œä¸”dè¾ƒå°
2. æ¯ç»„å…³é”®å­—çš„å–å€¼èŒƒå›´ä¸å¤§ï¼Œå³rè¾ƒå°
3. æ•°æ®å…ƒç´ ä¸ªæ•°nè¾ƒå¤§

## 8.5 å†…éƒ¨æ’åºç®—æ³•çš„æ¯”è¾ƒ
