- [ç¬¬ä¸€ç« â€”â€”ç»ªè®º](#ç¬¬ä¸€ç« ç»ªè®º)
- [ç¬¬äºŒç« â€”â€”çº¿æ€§è¡¨](#ç¬¬äºŒç« çº¿æ€§è¡¨)
  - [2.1 çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ](#21-çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ)
  - [2.2 çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º](#22-çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º)
  - [2.3 çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º](#23-çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º)
    - [2.3.1 å•é“¾è¡¨](#231-å•é“¾è¡¨)
    - [2.3.2 åŒé“¾è¡¨](#232-åŒé“¾è¡¨)
- [ç¬¬ä¸‰ç« â€”â€”æ ˆã€é˜Ÿåˆ—å’Œæ•°ç»„](#ç¬¬ä¸‰ç« æ ˆé˜Ÿåˆ—å’Œæ•°ç»„)
  - [3.1 æ ˆ](#31-æ ˆ)
    - [3.1.1 æ ˆçš„åŸºæœ¬æ¦‚å¿µ](#311-æ ˆçš„åŸºæœ¬æ¦‚å¿µ)
    - [3.1.2 æ ˆçš„é¡ºåºå­˜å‚¨ï¼ˆé¡ºåºæ ˆï¼‰](#312-æ ˆçš„é¡ºåºå­˜å‚¨é¡ºåºæ ˆ)
      - [å…±äº«æ ˆ](#å…±äº«æ ˆ)
    - [3.1.3 æ ˆçš„é“¾å¼å­˜å‚¨ï¼ˆé“¾å¼æ ˆï¼‰](#313-æ ˆçš„é“¾å¼å­˜å‚¨é“¾å¼æ ˆ)
    - [3.1.4 æ ˆçš„åº”ç”¨](#314-æ ˆçš„åº”ç”¨)
  - [3.2 é˜Ÿåˆ—](#32-é˜Ÿåˆ—)
    - [3.2.1 é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„](#321-é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„)
    - [3.2.2 é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨](#322-é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨)
    - [3.2.3 é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨](#323-é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨)
    - [3.2.4 åŒç«¯é˜Ÿåˆ—ï¼ˆä¸å—é™å’Œå—é™ï¼‰](#324-åŒç«¯é˜Ÿåˆ—ä¸å—é™å’Œå—é™)
    - [3.2.5 é˜Ÿåˆ—çš„åº”ç”¨](#325-é˜Ÿåˆ—çš„åº”ç”¨)
  - [3.3 æ•°ç»„å’Œç‰¹æ®ŠçŸ©é˜µ](#33-æ•°ç»„å’Œç‰¹æ®ŠçŸ©é˜µ)
- [ç¬¬å››ç« â€”â€”ä¸²](#ç¬¬å››ç« ä¸²)
  - [4.1 ä¸²çš„å®šä¹‰å’Œå®ç°](#41-ä¸²çš„å®šä¹‰å’Œå®ç°)
    - [ä¸²çš„é¡ºåºå­˜å‚¨](#ä¸²çš„é¡ºåºå­˜å‚¨)
    - [ä¸²çš„é“¾å¼å­˜å‚¨](#ä¸²çš„é“¾å¼å­˜å‚¨)
  - [4.2 ä¸²çš„æ¨¡å¼åŒ¹é…](#42-ä¸²çš„æ¨¡å¼åŒ¹é…)
    - [4.2.1 æœ´ç´ æ¨¡å¼åŒ¹é…ï¼ˆå®šä½æ“ä½œï¼‰](#421-æœ´ç´ æ¨¡å¼åŒ¹é…å®šä½æ“ä½œ)
    - [4.2.2 KMP](#422-kmp)
    - [4.2.3 KMPç®—æ³•ä¼˜åŒ–â€”â€”nextvalæ•°ç»„](#423-kmpç®—æ³•ä¼˜åŒ–nextvalæ•°ç»„)
- [ç¬¬äº”ç« â€”â€”æ ‘å’ŒäºŒå‰æ ‘](#ç¬¬äº”ç« æ ‘å’ŒäºŒå‰æ ‘)
  - [5.1 æ ‘çš„åŸºæœ¬æ¦‚å¿µ](#51-æ ‘çš„åŸºæœ¬æ¦‚å¿µ)
  - [5.2 äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ](#52-äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ)
    - [5.2.1 äºŒå‰æ ‘çš„å®šä¹‰åŠå…¶ä¸»è¦ç‰¹å¾](#521-äºŒå‰æ ‘çš„å®šä¹‰åŠå…¶ä¸»è¦ç‰¹å¾)
    - [5.2.2 äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„ã€éå†](#522-äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„éå†)
  - [5.3 çº¿ç´¢äºŒå‰æ ‘](#53-çº¿ç´¢äºŒå‰æ ‘)
    - [5.3.1 çº¿ç´¢åŒ–äºŒå‰æ ‘](#531-çº¿ç´¢åŒ–äºŒå‰æ ‘)
    - [5.3.2 çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±ï¼ˆåç»§ï¼‰](#532-çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±åç»§)
  - [5.4 æ ‘ã€æ£®æ—](#54-æ ‘æ£®æ—)
    - [5.4.1 æ ‘çš„å­˜å‚¨ç»“æ„](#541-æ ‘çš„å­˜å‚¨ç»“æ„)
  - [5.5 æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨](#55-æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨)
    - [5.5.1 å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç ](#551-å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç )
- [ç¬¬å…­ç« â€”â€”å›¾](#ç¬¬å…­ç« å›¾)
  - [6.1 å›¾çš„åŸºæœ¬æ¦‚å¿µ](#61-å›¾çš„åŸºæœ¬æ¦‚å¿µ)
  - [6.2 å›¾çš„å­˜å‚¨åŠåŸºæœ¬æ“ä½œ](#62-å›¾çš„å­˜å‚¨åŠåŸºæœ¬æ“ä½œ)
    - [6.2.1 é‚»æ¥çŸ©é˜µæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰](#621-é‚»æ¥çŸ©é˜µæ³•é¡ºåºå­˜å‚¨)
    - [6.2.2 é‚»æ¥è¡¨æ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰](#622-é‚»æ¥è¡¨æ³•é¡ºåºé“¾å¼å­˜å‚¨)
  - [6.3 å›¾çš„éå†](#63-å›¾çš„éå†)
    - [6.3.1 BFS å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•](#631-bfs-å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•)
    - [6.3.2 DFS æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•](#632-dfs-æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•)
  - [6.4åº”ç”¨](#64åº”ç”¨)
    - [6.4.1 æœ€å°ç”Ÿæˆæ ‘](#641-æœ€å°ç”Ÿæˆæ ‘)
    - [6.4.2 æœ€çŸ­è·¯å¾„](#642-æœ€çŸ­è·¯å¾„)
    - [6.4.3 æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰æè¿°è¡¨è¾¾å¼](#643-æœ‰å‘æ— ç¯å›¾dagæè¿°è¡¨è¾¾å¼)
    - [6.4.4 æ‹“æ‰‘æ’åº(é€†æ‹“æ‰‘æ’åº)](#644-æ‹“æ‰‘æ’åºé€†æ‹“æ‰‘æ’åº)
    - [6.4.5 å…³é”®è·¯å¾„](#645-å…³é”®è·¯å¾„)
- [ç¬¬ä¸ƒç« â€”â€”æŸ¥æ‰¾](#ç¬¬ä¸ƒç« æŸ¥æ‰¾)
  - [7.1 æŸ¥æ‰¾çš„åŸºæœ¬æ¦‚å¿µ](#71-æŸ¥æ‰¾çš„åŸºæœ¬æ¦‚å¿µ)
  - [7.2 é¡ºåºã€æŠ˜åŠã€åˆ†å—](#72-é¡ºåºæŠ˜åŠåˆ†å—)
    - [7.2.1 é¡ºåºæŸ¥æ‰¾](#721-é¡ºåºæŸ¥æ‰¾)
    - [7.2.2 æŠ˜åŠæŸ¥æ‰¾](#722-æŠ˜åŠæŸ¥æ‰¾)
    - [7.2.3 åˆ†å—æŸ¥æ‰¾](#723-åˆ†å—æŸ¥æ‰¾)
  - [7.3 æ ‘å‹æŸ¥æ‰¾](#73-æ ‘å‹æŸ¥æ‰¾)
    - [7.3.1 äºŒå‰æ’åºæ ‘ï¼ˆäºŒå‰æœç´¢æ ‘BSTï¼‰](#731-äºŒå‰æ’åºæ ‘äºŒå‰æœç´¢æ ‘bst)
    - [7.3.2 å¹³è¡¡äºŒå‰æ ‘](#732-å¹³è¡¡äºŒå‰æ ‘)
  - [7.4 Bæ ‘å’ŒB+æ ‘](#74-bæ ‘å’Œbæ ‘)
  - [7.5 æ•£åˆ—è¡¨ï¼ˆå“ˆå¸Œè¡¨ï¼‰](#75-æ•£åˆ—è¡¨å“ˆå¸Œè¡¨)
- [ç¬¬å…«ç« â€”â€”æ’åº](#ç¬¬å…«ç« æ’åº)
  - [8.1 æ’å…¥æ’åº](#81-æ’å…¥æ’åº)
  - [8.2 äº¤æ¢æ’åº](#82-äº¤æ¢æ’åº)
  - [8.3 é€‰æ‹©æ’åº](#83-é€‰æ‹©æ’åº)
  - [8.4 å½’å¹¶æ’åº](#84-å½’å¹¶æ’åº)
  - [8.5 åŸºæ•°æ’åº](#85-åŸºæ•°æ’åº)

# ç¬¬ä¸€ç« â€”â€”ç»ªè®º

# ç¬¬äºŒç« â€”â€”çº¿æ€§è¡¨
## 2.1 çº¿æ€§è¡¨çš„å®šä¹‰å’ŒåŸºæœ¬æ“ä½œ
## 2.2 çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º
## 2.3 çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º
### 2.3.1 å•é“¾è¡¨
```c++
#include <iostream>
using namespace std;

typedef struct LNode{   //å®šä¹‰å•é“¾è¡¨ç»“ç‚¹ç±»å‹
    ElemType data;      //æ•°æ®åŸŸ
    struct LNode *next; //æŒ‡é’ˆåŸŸ
}LNode,*LinkList;

LinkList createList_Head(LinkList &L){  //ä½¿ç”¨å¤´æ’æ³•å»ºç«‹å•é“¾è¡¨
    LNode *s;
    int x;
    L=(LinkList)malloc(sizeof(LNode));  //åˆ›å»ºå¤´ç»“ç‚¹
    L->next=NULL;                       //åˆå§‹ä¸ºç©ºé“¾è¡¨
    cin>>x;
    while (x!=9999)
    {
        s=(LNode*)malloc(sizeof(LNode));
        s->data=x;
        s->next=L->next;
        L->next=s;
        cin>>x;
    }
    return L;
}

LNode *GetElem(LinkList L,int i){   //ä½¿ç”¨ ä¸‹æ ‡ è¿”å› è¯¥å•é“¾è¡¨ç»“ç‚¹
    int j=1;
    LNode *p=L->next;
    if(i==0)
        return L;
    if(i<1)
        return NULL;
    while(p&&j<i){
        p=p->next;
        j++;
    }
    return p;
}

LNode *LocateElem(LinkList L,int e){//ä½¿ç”¨ å€¼data è¿”å› è¯¥ç‚¹é“¾è¡¨ç»“ç‚¹
    LNode *p=L->next;
    while(p!=NULL&&p->data!=e)
    {
        p=p->next;
    }
    return p;
}

LinkList InsertElem(LinkList &L,LNode *s,int n){
    LNode *p=GetElem(L,n-1);
    s->next=p->next;
    p->next=s;
    return L;
}

int main(){
    LinkList L;
    createList_Head(L);
    cout<<L;
    return 0;
}
```

### 2.3.2 åŒé“¾è¡¨
```c++
#include <iostream>
using namespace std;

typedef struct DNode{           //å®šä¹‰åŒé“¾è¡¨ç»“ç‚¹ç±»å‹
    ElemType data;              //æ•°æ®åŸŸ
    struct DNode *prior,*next;  //å‰é©±å’Œåé©±æŒ‡é’ˆ
}DNode,*DLinkList;

bool initDLinkList(DLinkList &L){
    L = (DNode*)malloc(sizeof(DNode));//åˆ†é…ä¸€ä¸ªå¤´ç»“ç‚¹
    if(L==NULL)
        return false;
    L->piror=NULL;                    //å¤´ç»“ç‚¹çš„piroræ°¸è¿œæŒ‡å‘NULL
    L->next=NUll;                     //å¤´ç»“ç‚¹ä¹‹åæš‚æ—¶æ²¡æœ‰ç»“ç‚¹
    return true;
}

bool insertNextDNode(DNode *p,DNode *s){ //åœ¨PèŠ‚ç‚¹åæ’å…¥Sç»“ç‚¹
    if(p==NULL || s==NULL)
        return false;
    s->next=p->next;
    if(p->next != NULL)                  //å¦‚æœpæœ‰åç»§ç»“ç‚¹
        p->next->prior=s;
    s->prior=p;    
    p->next=s;
    return true;
}

bool deleteNextDNode(DNode *p){ //åˆ é™¤pç»“ç‚¹çš„åç»§ç»“ç‚¹ 
    if(p==NULL) return false;
    DNode *q=p->next;           //æ‰¾åˆ°pç»“ç‚¹çš„åç»§ç»“ç‚¹q
    if(q==NULL) return false;   //pæ²¡æœ‰åç»§ç»“ç‚¹ï¼Œqä¸ºç©º
    p->next=q->next;            
    if(q->next!=NULL)           //qä¸æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹
        q->next->prior=p;       
    free(q);                    //é‡Šæ”¾ç»“ç‚¹ç©ºé—´
    return true;
}

void DestroyDLinkList(DLinkList &L){    //å¾ªç¯é‡Šæ”¾å„ä¸ªæ•°æ®ç»“ç‚¹
    while(L->next!=NULL)
        deleteNextDNode(L);
    free(L);
    L=NULL;
}

void checkAllDNode(){
    while(p!=NULL){         //åå‘éå†
        p=p->next;
    }
    while(p!=NULL){         //å‰å‘éå†
        p=p->prior;
    }
    while(p->prior!=NULL){  //å‰å‘éå†ï¼ˆè·³è¿‡å¤´ç»“ç‚¹ï¼‰
        p=p->prior;
    }
}

void testDLinkList(){
    DLinkList L;
    initDLinkList(L);
    ......
}
```

# ç¬¬ä¸‰ç« â€”â€”æ ˆã€é˜Ÿåˆ—å’Œæ•°ç»„
## 3.1 æ ˆ
### 3.1.1 æ ˆçš„åŸºæœ¬æ¦‚å¿µ
### 3.1.2 æ ˆçš„é¡ºåºå­˜å‚¨ï¼ˆé¡ºåºæ ˆï¼‰
```c++
#include <iostream>
using namespace std;

#define MaxSize 10      //å®šä¹‰æ ˆä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct{
    int data[MaxSize];  //é™æ€æ•°æ®å­˜æ”¾æ ˆä¸­å…ƒç´ 
    int top;            //æ ˆé¡¶æŒ‡é’ˆ
}SqStack;

void InitStack(SqStack &S){
    S.top = -1;             //åˆå§‹åŒ–æ ˆé¡¶æŒ‡é’ˆ
}

bool StackEmpty(SqStack S){ //åˆ¤æ–­æ ˆç©º
    if(S.top == -1)
        return true;        //æ ˆç©º
    else
        return false;       //ä¸ç©º
}

bool Push(SqStack &S,int x){//è¿›æ ˆ
    if(S.top == MaxSize-1)  //æ ˆæ»¡
        return false;
    S.top = S.top + 1 ;     //æŒ‡é’ˆ+1
    S.data[S.top] = x;      //æ–°å…ƒç´ è¿›æ ˆ
    return true;
}

bool Pop(SqStack &S,int x){ //å‡ºæ ˆ
    if(S.top == -1)
        return false;       //æ ˆç©ºï¼ŒæŠ¥é”™
    x = S.data[S.top];      //æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
    S.top = S.top - 1;      //æŒ‡é’ˆ-1
    return true;
}

//è¯»æ ˆé¡¶æŒ‡é’ˆ
bool GetTop(SqStack S,int &x){
    if(S.top == -1)
        return false;
    x = S.data[S.top];      //x è®°å½•æ ˆé¡¶å…ƒç´ 
    return true;
}
```

#### å…±äº«æ ˆ
```c++
#include <iostream>
using namespace std;

#define MaxSize 100     //å®šä¹‰æ ˆä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct{
    int data[MaxSize];  //é™æ€æ•°æ®å­˜æ”¾æ ˆä¸­å…ƒç´ 
    int top1;           //æ ˆé¡¶æŒ‡é’ˆ1
    int top2;           //æ ˆé¡¶æŒ‡é’ˆ2
}SqDouStack;

void InitStack(SqDouStack &S){
    S.top1 = -1;             //åˆå§‹åŒ–æ ˆé¡¶æŒ‡é’ˆ
    S.top2 = MaxSize;
}

bool StackEmpty(SqDouStack S){ //åˆ¤æ–­æ ˆç©º
    if(S.top1 == -1 && S.top2 == MaxSize)
        return true;        //æ ˆç©º
    else
        return false;       //ä¸ç©º
}

bool Push(SqDouStack &S,int x,int StackNum){//è¿›æ ˆ
    if(S.top1 + 1 == S.top2)  //æ ˆæ»¡
        return false;
    if(StackNum == 1){
        S.top1 = S.top1 + 1;     //1æŒ‡é’ˆ+1
        S.data[S.top1] = x;      //æ–°å…ƒç´ è¿›æ ˆ1
    }
    else{
        S.top2 = S.top2 - 1;     //2æŒ‡é’ˆ-1
        S.data[S.top1] = x;      //æ–°å…ƒç´ è¿›æ ˆ2      
    }
    return true;
}

bool Pop(SqDouStack &S,int x,int StackNum){ //å‡ºæ ˆ
    if(StackNum == 1){
        if(S.top1 == -1)
            return false;       //æ ˆç©ºï¼ŒæŠ¥é”™
        x = S.data[S.top1];      //æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
        S.top1 = S.top1 - 1;      //æŒ‡é’ˆ-1
        return true;
    }
    else{
        if(S.top2 == MaxSize)
            return false;       //æ ˆç©ºï¼ŒæŠ¥é”™
        x = S.data[S.top2];      //æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
        S.top2 = S.top2 + 1;      //æŒ‡é’ˆ-1
        return true;
    }
}

//è¯»æ ˆé¡¶æŒ‡é’ˆ
bool GetTop(SqDouStack S,int &x,int StackNum){
    if(StackNum == 1){
        if(S.top1 == -1)
            return false;
        x = S.data[S.top1];      //x è®°å½•æ ˆé¡¶å…ƒç´ 
        return true;
    }
    else{
        if(S.top2 == MaxSize)
            return false;
        x = S.data[S.top2];      //x è®°å½•æ ˆé¡¶å…ƒç´ 
        return true;
    }

}
```

### 3.1.3 æ ˆçš„é“¾å¼å­˜å‚¨ï¼ˆé“¾å¼æ ˆï¼‰
```c++
#include <iostream>
using namespace std;

typedef struct Linknode{
    ElemType data;
    struct Linknode *next;
}*LiStack;

typedef struct LinkStack{
    LiStack top;
    int count;
}LinkStack;

bool Push(LinkStack *s, int x){
    LiStack p = (LiStack)malloc(sizeof(SNode));
    p -> data = x;
    p -> next = s -> top;
    s -> top = p;
    S -> count ++;
    return true; 
}

bool Pop(LinkStack *s, int& x){
    if(s -> top == NULL)
        return false;
    x = s->top->data;
    SLink p = s->top;
    s -> top = s->top->next;
    free(p);
    s->count--;
    return true;
}
```

### 3.1.4 æ ˆçš„åº”ç”¨
1. æ‹¬å·åŒ¹é…é—®é¢˜
```c++
#include <iostream>
using namespace std;

#define MaxSize 10
typedef struct{
    char data[MaxSize];
    int top;
}SqStack;

// åˆå§‹åŒ–æ ˆ
void InitStack(SqStack &S)

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
bool StackEmpty(SqStack S)

// æ–°å…ƒç´ å…¥æ ˆ
bool Push(SqStack &S,char x)

// æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œç”¨xè¿”å›
bool Pop(SqStack &S,char &x)

bool bracketCheck(char str[],int length){
    SqStack S;
    InitStack(S);                   // åˆå§‹åŒ–ä¸€ä¸ªæ ˆ
    for(int i=0;i<length;i++){
        if(str[i]=='(' || str[i]=='{' ||str[i]=='['){
            Push(S,str[i])          // æ‰«æåˆ°å·¦æ‹¬å·ï¼Œå…¥æ ˆæ“ä½œ
        }else{
            if(StackEmpty(S)){      // æ‰«æåˆ°å³æ‹¬å·ï¼Œç„¶è€Œæ ˆç©ºï¼ŒåŒ¹é…é”™è¯¯
                return false;
            }

            char topElem;
            Pop(S,topElem);         // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
            if(str[i]==')' && topElem!='(')
                return false;
            if(str[i]==']' && topElem!='[')
                return false;
            if(str[i]=='}' && topElem!='{')
                return false;
        }
    }
    return StackEmpty(S);           // æ£€ç´¢å®Œå…¨éƒ¨æ‹¬å·åï¼Œæ ˆç©ºè¯´æ˜åŒ¹é…æˆåŠŸ
}
```

2. åç¼€è¡¨è¾¾å¼
è®¡ç®—æœºè®¡ç®—æ­¥éª¤æ˜æ™°

3. é€’å½’
```c++
#include<iostream>
using namespace std;

int Fib(int n){
    if(n==0)
        return 0;
    else if(n==1)
        return 1;
    else
        return Fib(n-1)+Fib(n-2);
}

int main(){
    int x=Fib(4);
    cout<<x<<"  å¥¥é‡Œç»™ï¼ï¼ï¼"<<endl;
    return 0;
}
```

## 3.2 é˜Ÿåˆ—
### 3.2.1 é˜Ÿåˆ—çš„åŸºæœ¬ç»“æ„
### 3.2.2 é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨

```c++
#include <iostream>
using namespace std;
#define MaxSize 10

/**
ä»¥ä¸‹Codeé‡‡ç”¨é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨ï¼Œä¸”ä½¿ç”¨å¾ªç¯é˜Ÿåˆ—å­˜å‚¨
ä¸ºäº†åŒºåˆ†é˜Ÿç©ºå’Œé˜Ÿæ»¡ï¼Œé‡‡å–å…¥é˜Ÿæ—¶å°‘ç”¨ä¸€ä¸ªé˜Ÿåˆ—å•å…ƒ
æ­¤æ—¶é˜Ÿåˆ—ç©ºçš„æ¡ä»¶ä¸º Q.front == Q.rear
é˜Ÿåˆ—æ»¡çš„æ¡ä»¶ä¸º (Q.rear+1)%MaxSize == Q.front
 */

typedef struct SqQuene{
    int data[MaxSize];
    int front,rear;
}SqQueue;

//åˆå§‹åŒ–é˜Ÿåˆ—
void InitQueue(SqQuene& Q){
    Q.front = Q.rear = 0;
}

//åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
bool QueueEmpty(SqQuene Q){
    if(Q.front == Q.rear)
        return true;
    else
        return false;
}

//å…¥é˜Ÿ
bool EnQueue(SqQuene &Q,int x){
    if((Q.rear+1)%MaxSize == Q.front) //åˆ¤æ–­é˜Ÿæ»¡
        return false;
    Q.data[Q.rear] = x;               //æ–°å…ƒç´ æ’å…¥é˜Ÿå°¾
    Q.rear = (Q.rear + 1)%MaxSize;    //é˜Ÿå°¾æŒ‡é’ˆåŠ 1å–æ¨¡
    return true;
}

//å‡ºé˜Ÿ
bool DeQueue(SqQuene &Q,int &x){
    if(Q.front==Q.rear)         //é˜Ÿç©ºåˆ™æŠ¥é”™
        return false;
    x = Q.data[Q.front];
    Q.front=(Q.front + 1)%MaxSize;
    return true;
}

//è·å¾—é˜Ÿå¤´å…ƒç´ çš„å€¼,ç”¨xè¿”å›
int GetHead(SqQuene Q,int& x){
    if(Q.front == Q.rear)
        return;       //é˜Ÿç©ºåˆ™æŠ¥é”™
    x = Q.data[Q.front];
    return x;
}
```

### 3.2.3 é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨
```c++
#include <iostream>
using namespace std;

typedef struct LinkNode{    //é˜Ÿåˆ—ç»“ç‚¹
    int data;
    struct LinkNode *next;
}LinkNode;

typedef struct{             //é“¾å¼é˜Ÿåˆ—
    LinkNode *front,*rear;  //é˜Ÿå¤´å’Œé˜Ÿå°¾æŒ‡é’ˆ
}LinkQueue;

// åˆå§‹åŒ–é˜Ÿåˆ—(å¸¦å¤´ç»“ç‚¹)
void InitQueue(LinkQueue &Q){
    // åˆå§‹åŒ–,front rear éƒ½æŒ‡å‘å¤´ç»“ç‚¹
    Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode));
    Q.front->next = NULL;
}

// åˆå§‹åŒ–é˜Ÿåˆ—ï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
void InitQueue(LinkQueue &Q){
    // åˆå§‹åŒ–,front rear éƒ½æŒ‡å‘NULL
    Q.front = Q.rear = NULL;
}

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º(å¸¦å¤´ç»“ç‚¹)
bool IsEmpty(LinkQueue Q){
    if(Q.front == Q.rear)
        return true;
    else
        return false;
}

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
bool IsEmpty(LinkQueue Q){
    if(Q.front == NULL)
        return true;
    else
        return false;
}

// æ–°å…ƒç´ å…¥é˜Ÿï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
void EnQueue(LinkQueue &Q,int x){
    LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
    s->data = x;
    s->next = NULL;
    Q.rear->next = s;   //æ–°ç»“ç‚¹æ’å…¥åˆ°rearä¹‹å
    Q.rear = s;         //ä¿®æ”¹é˜Ÿå°¾æŒ‡é’ˆ
}

// æ–°å…ƒç´ å…¥é˜Ÿï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
void EnQueue(LinkQueue &Q,int x){
    LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode));
    s->data = x;
    s->next = NULL;
    if(Q.front==NULL){      //åœ¨ç©ºé˜Ÿåˆ—ä¸­æ’å…¥ç¬¬ä¸€ä¸ªå…ƒç´ 
        Q.front = s;
        Q.rear = s;
    }else{
        Q.rear->next = s;   //æ–°ç»“ç‚¹æ’å…¥åˆ°rearç»“ç‚¹ä¹‹å
        Q.rear = s;         //ä¿®æ”¹rearé˜Ÿå°¾æŒ‡é’ˆ
    }
}

// é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
bool DeQueue(LinkQueue& Q,int& x){
    if(Q.front == Q.rear)       // é˜Ÿç©º
        return false;
    LinkNode *p = Q.front->next;// pæŒ‡å‘æ­¤æ¬¡å‡ºé˜Ÿçš„é˜Ÿå¤´ç»“ç‚¹
    x = p->data;                // ç”¨ x è¿”å›é˜Ÿå¤´çš„æ•°æ®
    Q.front->next = p->next;    // ä¿®æ”¹å¤´ç»“ç‚¹çš„nextæŒ‡é’ˆ

    if(Q.rear == p)             // å¦‚æœæ˜¯æœ€åä¸€ä¸ªç»“ç‚¹å‡ºé˜Ÿ
        Q.rear = Q.front;       // ä¿®æ”¹ rear æŒ‡é’ˆ 
    free(p);                    // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
    return true;
}

// é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
bool DeQueue(LinkQueue& Q,int& x){
    if(Q.front == NULL)
        return false;       // é˜Ÿç©º
    LinkNode *p = Q.front;  // pæŒ‡å‘æ­¤æ¬¡å‡ºé˜Ÿçš„é˜Ÿå¤´ç»“ç‚¹
    x = p->data;            // ç”¨å˜é‡ x è¿”å›é˜Ÿå¤´çš„æ•°æ®
    Q.front = p->next;      // ä¿®æ”¹ front æŒ‡é’ˆ
    if(Q.rear == p){        // å€˜è‹¥æ˜¯é˜Ÿä¸­æœ€åä¸€ä¸ªç»“ç‚¹å‡ºé˜Ÿ
        Q.front = NULL;     // front æŒ‡å‘ NULL
        Q.rear = NULL;      // rear æŒ‡å‘ NULL
    }
    free(p);                // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
    return true;
}

```

### 3.2.4 åŒç«¯é˜Ÿåˆ—ï¼ˆä¸å—é™å’Œå—é™ï¼‰
1. åŒç«¯é˜Ÿåˆ—ï¼ˆä¸å—é™åˆ¶ï¼‰
    åŒç«¯é˜Ÿåˆ—æ˜¯æŒ‡å…è®¸ä¸¤ç«¯éƒ½å¯ä»¥è¿›è¡Œå…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œçš„é˜Ÿåˆ—  
    é˜Ÿåˆ—çš„ä¸¤ç«¯åˆ†åˆ«ç§°ä¸ºå‰ç«¯å’Œåç«¯ï¼Œä¸¤ç«¯éƒ½å¯ä»¥å…¥é˜Ÿå’Œå‡ºé˜Ÿ

2. è¾“å‡ºå—é™çš„åŒç«¯é˜Ÿåˆ—
    å…è®¸åœ¨ä¸€ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤ï¼Œä½†åœ¨å¦ä¸€ç«¯åªå…è®¸æ’å…¥çš„åŒç«¯é˜Ÿåˆ—

3. è¾“å…¥å—é™çš„åŒç«¯é˜Ÿåˆ—
    å…è®¸åœ¨ä¸€ç«¯è¿›è¡Œæ’å…¥å’Œåˆ é™¤ï¼Œä½†åœ¨å¦ä¸€ç«¯åªå…è®¸åˆ é™¤çš„åŒç«¯é˜Ÿåˆ—

### 3.2.5 é˜Ÿåˆ—çš„åº”ç”¨
1. æ ‘çš„å±‚æ¬¡éå†
2. å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†
3. æ“ä½œç³»ç»Ÿ FCFS(å…ˆæ¥å…ˆæœåŠ¡) ç¼“å†²åŒº

## 3.3 æ•°ç»„å’Œç‰¹æ®ŠçŸ©é˜µ
è¯¦æƒ…è§ XMind

# ç¬¬å››ç« â€”â€”ä¸²
## 4.1 ä¸²çš„å®šä¹‰å’Œå®ç°
### ä¸²çš„é¡ºåºå­˜å‚¨
```c++
#include<iostream>
using namespace std;

#define MAXLEN 255
typedef struct SString{
    char ch[MAXLEN];
    int length;
};

typedef struct HString{
    char *ch;
    int length;
};

void initHString(HString &s){
    S.ch=(char *)malloc(MAXLEN*sizeof(char));
    S.length=0;
}

//èµ‹å€¼æ“ä½œï¼Œå°†ä¸²Tèµ‹å€¼ä¸ºchars
bool StrAssign(SString &T,chars){

}

//å¤åˆ¶æ“ä½œï¼Œå°†ä¸²Så¤åˆ¶å¾—åˆ°ä¸²T
bool StrCopy(){

}

//åˆ¤ç©ºæ“ä½œï¼ŒSç©ºä¸²è¿”å›TRUEï¼Œå¦åˆ™False
bool StrEmpty(){
    
}

//æ±‚ä¸²é•¿ï¼Œè¿”å›ä¸²çš„å…ƒç´ ä¸ªæ•°
bool StrLength(){
    
}

//æ±‚å­ä¸²ï¼Œç”¨Subè¿”å›ä¸²Sçš„ç¬¬posä¸ªå­—ç¬¦èµ·é•¿åº¦ä¸ºlençš„å­ä¸²
bool SubString(SString &Sub,SString S,int pos,int len){
    if(pos+len-1 > S.length)        //å­ä¸²
        return false;
    for(int i = pos;i<pos+len;i++)
        Sub.ch[i-pos+1] = S.ch[i];
    Sub.length = len;
    return true;
}

//æ¯”è¾ƒæ“ä½œ,è‹¥S>T,åˆ™è¿”å›å€¼>0;è‹¥S=T,åˆ™è¿”å›å€¼=0;è‹¥S<T,åˆ™è¿”å›å€¼<0
int StrCompare(SString S,SString T){
    for(int i=1; i<S.length && i<T.length; i++){
        if(S.ch[i]!=T.ch[i])
            return S.ch[i]-T.ch[i];
    }
    cout<<"å­—ç¬¦ä¸²é•¿åº¦ä¸ç›¸ç­‰,å…¶å·®å€¼ä¸º"<<S.length-T.length;
    return S.length-T.length;
}

//å®šä½æ“ä½œã€‚è‹¥ä¸»ä¸²Sä¸­å­˜åœ¨ä¸ä¸²Tå€¼ç›¸åŒçš„å­ä¸²ï¼Œåˆ™è¿”å›å®ƒåœ¨ä¸»ä¸²Sä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œå¦åˆ™å‡½æ•°å€¼ä¸º0
int Index(SString S,SString T){
    int i=1;
    SString sub;
    while(i<=S.length-T.length+1){
        SubString(sub,S,i,T.length);
        if(StrCompare(sub,T)!=0)
            ++i;
        else
            return i;
    }
    return 0;
}

//æ¸…ç©ºæ“ä½œï¼Œå°†Sæ¸…ç©ºä¸ºç©ºä¸²
bool ClearString(){
    
}

//é”€æ¯æ“ä½œï¼Œå›æ”¶å­˜å‚¨ç©ºé—´
bool DestoryString(){

}

//ä¸²è¿æ¥ï¼Œç”¨Tè¿”å›ç”±S1å’ŒS2è”ç»“è€Œæˆçš„æ–°ä¸²
bool Concat(){

}
```

### ä¸²çš„é“¾å¼å­˜å‚¨
```c++
#include<iostream>
using namespace std;

#define MAXLEN 255
typedef struct StringNode{
    char ch;        //æ¯ä¸ªç»“ç‚¹å­˜å‚¨1ä¸ªå­—ç¬¦ï¼Œå­˜å‚¨å¯†åº¦ä½ï¼Œæ¯ä¸ªå­—ç¬¦1Bï¼Œæ¯ä¸ªæŒ‡é’ˆ4B
    char ch[4];     //å­˜å‚¨å¯†åº¦æé«˜
    struct StringNode *next;
}StringNode,*String;

```

## 4.2 ä¸²çš„æ¨¡å¼åŒ¹é…

### 4.2.1 æœ´ç´ æ¨¡å¼åŒ¹é…ï¼ˆå®šä½æ“ä½œï¼‰

ä¸»ä¸²çš„æ‰«ææŒ‡é’ˆ i ç»å¸¸å›æº¯ï¼Œå¯¼è‡´æ—¶é—´å¼€é”€å¢åŠ ï¼Œ<font color='red'>æœ€åæ—¶é—´å¤æ‚åº¦ O ( n m ) </font>

```c++
int Index(SString S,SString T){
    int k=1;
    int i=k,j=1;
    while(i<=S.length&&j<=T.length){
        if(S.ch[i]==T.ch[j]){
            ++i;
            ++j;        //ç»§ç»­æ¯”è¾ƒåç»§å­—ç¬¦
        }else{
            k++;        //æ£€æŸ¥åä¸€ä¸ªå­—ç¬¦ä¸²
            i=k;
            j=1;
        }
        if(j>T.length)
            return k;
        else
            return 0;
    }
}
```

### 4.2.2 KMP

æ”¹è¿›æ€è·¯ï¼šå½“å­ä¸²å’Œæ¨¡å¼ä¸²ä¸åŒ¹é…æ—¶ï¼Œä¸»ä¸²æŒ‡é’ˆä¸å›æº¯ï¼Œåªæœ‰æ¨¡å¼ä¸²æŒ‡é’ˆå›æº¯ j = next [ j ]

<font color='red'>ç®—æ³•å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO ( n + m )</font>

```c++
int Index_KMP(SString S,SString T,int next[]){
    int i=1,j=1;
    while(i<=S.length&&j<=T.length){
        if(j==0 || S.ch[i]==T.ch[i]){
            ++i;
            ++j;
        }else{
            j=next[j];
        }
        if(j>T.length)
            return i-T.length;
        else
            return 0; 
    }
}
```
ğŸ’¡ nextæ•°ç»„ï¼šå½“æ¨¡å¼ä¸²çš„ç¬¬ j ä¸ªå­—ç¬¦åŒ¹é…å¤±è´¥æ—¶ï¼Œä»¤æ¨¡å¼ä¸²è·³åˆ° next [ j ] å†ç»§ç»­åŒ¹é…   
æ¨¡å¼ä¸²å‘å³ç§»åŠ¨çœ‹åŒ¹é…ç¨‹åº¦

> ä¸²çš„å‰ç¼€ï¼šåŒ…å«ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œä¸”ä¸åŒ…å«æœ€åä¸€ä¸ªå­—ç¬¦çš„å­ä¸²
ä¸²çš„åç¼€ï¼šåŒ…å«æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œä¸”ä¸åŒ…å«ç¬¬ä¸€ä¸ªå­—ç¬¦çš„å­ä¸²
> 

ğŸ’¡ å½“ç¬¬ j ä¸ªå­—ç¬¦åŒ¹é…å¤±è´¥ï¼Œç”±å‰ 1 ï½ j - 1 ä¸ªå­—ç¬¦ç»„æˆçš„ä¸²è®°ä¸º S ,åˆ™ï¼š  
next [ j ] = S çš„æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦ + 1  
>ç‰¹åˆ«çš„ï¼Œnext [ 1 ] = 0 ä¸” next [ 2 ] = 1


### 4.2.3 KMPç®—æ³•ä¼˜åŒ–â€”â€”nextvalæ•°ç»„

# ç¬¬äº”ç« â€”â€”æ ‘å’ŒäºŒå‰æ ‘

## 5.1 æ ‘çš„åŸºæœ¬æ¦‚å¿µ

## 5.2 äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ
### 5.2.1 äºŒå‰æ ‘çš„å®šä¹‰åŠå…¶ä¸»è¦ç‰¹å¾
1. $$\begin{aligned}â‘  \quad n &=n_0+n_1+n_2    \\â‘¡ \quad n &= n_1+2n_2+1    \\â‘¡-â‘  \quad n_0&=n_2+1   \end{aligned}$$
2. $éç©ºäºŒå‰æ ‘ä¸Šç¬¬ i å±‚ä¸Šè‡³å¤šæœ‰ 2^{iâˆ’1} ä¸ªç»“ç‚¹ï¼ˆi â‰¥ 1ï¼‰\\[5px]$
3. $må‰æ ‘ç¬¬ i å±‚è‡³å¤šæœ‰ m^{i - 1}ä¸ªç»“ç‚¹\\[5px]$
4. $é«˜åº¦ä¸º h çš„ äºŒå‰æ ‘ è‡³å¤šæœ‰ 2^h - 1 ä¸ªç»“ç‚¹ï¼ˆæ»¡äºŒå‰æ ‘ï¼‰\\[5px]$
5. $é«˜åº¦ä¸º h çš„ må‰æ ‘ è‡³å¤šæœ‰ \frac{m^h - 1}{m -1}ä¸ªç»“ç‚¹ï¼ˆhâ‰¥1ï¼‰\\[5px]$
6. $$é«˜åº¦ä¸º h çš„ m å‰æ ‘ è‡³å°‘æœ‰hä¸ªç»“ç‚¹ \\ é«˜åº¦ä¸ºh ã€åº¦ä¸ºm çš„æ ‘è‡³å°‘æœ‰h+m-1ä¸ªç»“ç‚¹$$
7. $å…·æœ‰Nä¸ªï¼ˆN>0ï¼‰ç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„é«˜åº¦ä¸º \lceil log_{2}(N+1) \rceil æˆ– \lfloor log_{2}N \rfloor+1ã€‚\\[5px]$

### 5.2.2 äºŒå‰æ ‘çš„å­˜å‚¨ç»“æ„ã€éå†

1. é¡ºåºå­˜å‚¨
```c++
#include<iostream>
#define MaxSize 100
struct TreeNode{
    ElemType value; //ç»“ç‚¹ä¸­çš„æ•°æ®å…ƒç´ 
    bool isEmpty;   //ç»“ç‚¹æ˜¯å¦ä¸ºç©º
};

TreeNode t[MaxSize];

void initTree{      //åˆå§‹åŒ–
    for(int i=0;i<MaxSize;i++){
        t[i].isEmpty=true;
    }
}
```

2. é“¾å¼å­˜å‚¨ï¼ˆéå†ï¼‰
    - å…ˆåºéå†
    - ä¸­åºéå†
    - ååºéå†
    - é€’å½’ç®—æ³•å’Œéé€’å½’ç®—æ³•çš„è½¬æ¢
    - å±‚æ¬¡éå†
    - ç”±éå†åºåˆ—æ„é€ äºŒå‰æ ‘ï¼ˆå¿…é¡»ç”±ä¸­åºéå†åºåˆ—ï¼‰

> ä¸‰ç§éå†ï¼ˆå…ˆåºä¸­åºååºï¼‰
```c++
#include <iostream>

struct ElemType{
    int value;
};

typedef struct BiTNode{
    ElemType data;                  //æ•°æ®åŸŸ
    struct BiTNode *lchild,*rchild; //å·¦å³å­©å­æŒ‡é’ˆ
    struct BiTNode *parent;         //çˆ¶ç»“ç‚¹æŒ‡é’ˆ
}BiTNode,*BiTree;

BiTree root = NULL;

root = (BiTree)malloc(sizeof(BiTNode));
root -> data ={1};
root -> lchild = NULL;
root -> rchild = NULL;

// å…ˆåºéå†
void PreOrder(BiTree T){
    if(T != NULL){
        visit(T);           //è®¿é—®æ ¹ç»“ç‚¹
        PreOrder(T->lchild);//é€’å½’éå†å·¦å­æ ‘
        PreOrder(T->rchild);//é€’å½’éå†å³å­æ ‘
    }
}

//ä¸­åºéå†
void InOrder(BiTree T){
    if(T != NULL){
        InOrder(T->lchild);//é€’å½’éå†å·¦å­æ ‘
        visit(T);           //è®¿é—®æ ¹ç»“ç‚¹
        InOrder(T->rchild);//é€’å½’éå†å³å­æ ‘
    }
}

//ååºéå†
void PostOrder(BiTree T){
    if(T != NULL){
        PostOrder(T->lchild);//é€’å½’éå†å·¦å­æ ‘
        PostOrder(T->rchild);//é€’å½’éå†å³å­æ ‘
        visit(T);           //è®¿é—®æ ¹ç»“ç‚¹       
    }
}
```

> å±‚æ¬¡éå†
```c++
#include<iostream>
using namespace std;

//äºŒå‰æ ‘çš„ç»“ç‚¹ï¼ˆé“¾å¼å­˜å‚¨ï¼‰
typedef struct BiTNode{
    char data;                  //æ•°æ®åŸŸ
    struct BiTNode *lchild,*rchild; //å·¦å³å­©å­æŒ‡é’ˆ
}BiTNode,*BiTree;

//é“¾å¼é˜Ÿåˆ—ç»“ç‚¹
typedef struct LinkNode{
    BiTNode *data;              //å­˜æŒ‡é’ˆè€Œä¸æ˜¯ç»“ç‚¹
    struct LinkNode *next;
}LinkNode;

typedef struct{
    LinkNode *front,*rear;      //é˜Ÿå¤´é˜Ÿå°¾
}LinkQueue;

// å±‚åºéå†
void LevelOrder(BiTree T){
    LinkQueue Q;
    InitQueue(Q);               //åˆå§‹åŒ–è¾…åŠ©é˜Ÿåˆ—
    BiTree p;
    EnQueue(Q,T);               //å°†æ ¹ç»“ç‚¹å…¥é˜Ÿ
    while(!IsEmpty(Q)){         //é˜Ÿåˆ—ä¸ç©ºåˆ™å¾ªç¯
        DeQueue(Q,p);           //é˜Ÿå¤´ç»“ç‚¹å‡ºé˜Ÿï¼ŒTèµ‹å€¼p
        visit(p);               //è®¿é—®å‡ºé˜Ÿç»“ç‚¹
        if(p->lchild!=NULL)
            EnQueue(Q,p->lchild);//å·¦å­©å­å…¥é˜Ÿ
        if(p->rchild!=NULL)
            EnQueue(Q,p->rchild);//å³å­©å­å…¥é˜Ÿ
    }
}
```

## 5.3 çº¿ç´¢äºŒå‰æ ‘

### 5.3.1 çº¿ç´¢åŒ–äºŒå‰æ ‘
- ç”¨åœŸåŠæ³•æ‰¾åˆ°ä¸­åºå‰é©±
```c++
#include <iostream>
using namespace std;

//ä¸­åºéå†
void InOrder(BiTree T){
    if(T!=NULL){
        InOrder(T->lchild); //é€’å½’éå†å·¦å­æ ‘
        visit(T);           //è®¿é—®æ ¹ç»“ç‚¹
        InOrder(T->rchild); //é€’å½’éå†å³å­æ ‘
    }
}

void visit(BiTNode *q){
    if(q==p)            //å½“å‰è®¿é—®ç»“ç‚¹åˆšå¥½æ˜¯ç»“ç‚¹p
        final = pre;    //æ‰¾åˆ°pçš„å‰é©±
    else
        pre = q;        //preæŒ‡å‘å½“å‰è®¿é—®çš„ç»“ç‚¹
}

//è¾…åŠ©çš„å…¨å±€å˜é‡ï¼Œç”¨äºæŸ¥æ‰¾ç»“ç‚¹pçš„å‰é©±
BiTNode *p;         //pæŒ‡å‘ç›®æ ‡ç»“ç‚¹
BiTNode *pre=NULL;  //æŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
BiTNode *final=NULL;//ç”¨äºè®°å½•æœ€ç»ˆç»“æœ

```

- ä¸­åºçº¿ç´¢åŒ–
```c++
#include <iostream>
using namespace std;

typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;      //å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
}ThreadNode,*ThreadTree;

void InThread(ThreadTree T){
    if(T!=NULL){
        InThread(T->lchild);
        visit(T);
        InThread(T->rchild);
    }
}

void visit(ThreadNode *q){
    if(q->lchild == NULL){  //å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL && pre->rchild == NULL){
        pre->rchild = q;    //å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
        pre->rtag = 1;
    }
    pre = q;
}

//å…¨å±€å˜é‡ pre ï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;

```

- å…ˆåºçº¿ç´¢åŒ–
> å…ˆåºçº¿ç´¢åŒ– **æœ‰ä¸ªå‘**ï¼Œåœ¨å¤„ç†æ ¹ç»“ç‚¹ä¹‹åï¼Œå¤„ç†å·¦å­©å­ä¹‹å‰ï¼Œéœ€è¦åˆ¤æ–­æ”¹å½“å‰éå†ç»“ç‚¹çš„ **ltag** æ ‡å¿—æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸º0ï¼Œåˆ™lchildä¸æ˜¯å‰é©±çº¿ç´¢
>> ã€ç»¼ä¸Šæ˜¯ä¸ºäº†é¿å…é™·å…¥éå†çš„ **æ­»å¾ªç¯**ã€‘
```c++
#include <iostream>
using namespace std;

typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;      //å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
}ThreadNode,*ThreadTree;

//å…ˆåºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void PreThread(ThreadTree T){
    if(T!=NULL){
        visit(T);               //å…ˆå¤„ç†æ ¹ç»“ç‚¹
        if(T->ltag == 0){
            PreThread(T->lchild);//å¦‚æœlchildä¸æ˜¯å‰é©±çº¿ç´¢
        }
        PreThread(T->rchild);
    }
}

void visit(ThreadNode *q){
    if(q->lchild == NULL){      //å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL && pre->rchild == NULL){
        pre->rchild = q;        //å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
        pre->rtag = 1;
    }
    pre = q;
}

//å…¨å±€å˜é‡ pre ï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;
```

- ååºçº¿ç´¢åŒ–
```c++
#include <iostream>
using namespace std;

//å…¨å±€å˜é‡preï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre=NULL;

//ååºçº¿ç´¢åŒ–äºŒå‰æ ‘T
void CreatePostThread(ThreadTree T){
    pre=NULL;                   //preåˆå§‹åŒ–ä¸ºNULL
    if(T!=NULL){                //éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
        PostThread(T);          //åç»­çº¿ç´¢åŒ–äºŒå‰æ ‘
        if(pre->lchild==NULL){
            pre->rtag=1;        //å¤„ç†éå†çš„æœ€åä¸€ä¸ªç»“ç‚¹
        }
    }
}

//ååºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void PostThread(ThreadTree T){
    if(T!=NULL){
        PostThread(T->lchild);  //ååºéå†å·¦å­æ ‘
        PostThread(T->rchild);  //ååºéå†å³å­æ ‘
        visit(T);               //è®¿é—®æ ¹ç»“ç‚¹
    }
}

void visit(ThreadNode *q){
    if(q->lchild==NULL){        //å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
        q->lchild = pre;
        q->ltag=1;
    }
    if(pre!=NULL && p->rchild==NULL){
        pre->rchild = q;        //å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
        pre -> rtag = 1;
    } 
    pre = q;
}
```

### 5.3.2 çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±ï¼ˆåç»§ï¼‰

- ä¸­åºçº¿ç´¢äºŒå‰æ ‘æ‰¾ä¸­åºåç»§
```c++
//æ‰¾åˆ°ä»¥Pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œç¬¬ä¸€ä¸ªè¢«ä¸­åºéå†çš„ç»“ç‚¹
ThreadNode *FirstNode(ThreadNode *p){
    while(p->ltag==0)       //å¾ªç¯å¯»æ‰¾æœ€å·¦ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
        p=p->lchild;
    return p;
}

//åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„åç»§ç»“ç‚¹
ThreadNode *NextNode(ThreadNode *p){
    id(p->rtag==0)          //å³å­æ ‘çš„æœ€å·¦ğŸ‘ˆä¸‹ç»“ç‚¹
        return FirstNode(p->rchild);
    else                    //rtag==1ï¼Œç›´æ¥è¿”å›åç»§çº¿ç´¢
        return p->rchild;
}

//å¯¹ä¸­åºçº¿ç´¢äºŒå‰æ ‘è¿›è¡Œä¸­åºéå†ï¼ˆåˆ©ç”¨çº¿ç´¢å®ç°çš„éé€’å½’ç®—æ³•ï¼‰
void InOrder(ThreadNode *T){
    for(ThreadNode *p=FirstNode(T);p!=NULL;p=NextNode(p))
        visit(p);
}
```

- ä¸­åºçº¿ç´¢äºŒå‰æ ‘æ‰¾ä¸­åºå‰é©±
```c++
//æ‰¾åˆ°ä»¥pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œæœ€åä¸€ä¸ªè¢«ä¸­åºéå†çš„ç»“ç‚¹
ThreadNode *LastNode(ThreadNode *p){
    while(p->rtag==0)       //å¾ªç¯å¯»æ‰¾æœ€å³ğŸ‘‰ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
        p=p->rchild;
    return p;
}

//åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„å‰é©±ç»“ç‚¹
ThreadNode *PreNode(ThreadNode *p){
    id(p->ltag==0)          //å·¦å­æ ‘çš„æœ€å³ä¸‹ç»“ç‚¹
        return FirstNode(p->lchild);
    else                    //rtag==1ï¼Œç›´æ¥è¿”å›å‰é©±çº¿ç´¢
        return p->lchild;
}

//å¯¹ä¸­åºçº¿ç´¢äºŒå‰æ ‘è¿›è¡Œé€†å‘ä¸­åºéå†ï¼ˆåˆ©ç”¨çº¿ç´¢å®ç°çš„éé€’å½’ç®—æ³•ï¼‰
void RevInOrder(ThreadNode *T){
    for(ThreadNode *p=LastNode(T);p!=NULL;p=PreNode(p))
        visit(p);
}
```

## 5.4 æ ‘ã€æ£®æ—

### 5.4.1 æ ‘çš„å­˜å‚¨ç»“æ„
- åŒäº²è¡¨ç¤ºæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰
```c++
#define MAX_TREE_SIZE 100           //æ ‘ä¸­æœ€å¤šç»“ç‚¹æ ‘

typedef struct{                     //æ ‘çš„ç»“ç‚¹å®šä¹‰
    ElemType data;                  //æ•°æ®å…ƒç´ 
    int parent;                     //åŒäº²ä½ç½®åŸŸ
}PTNode;

typedef struct{                     //æ ‘çš„ç»“æ„ç±»å‹
    PTNode nodes[MAX_TREE_SIZE];    //åŒäº²è¡¨ç¤º
    int n;                          //ç»“ç‚¹æ•°
}PTree;
```

- å­©å­è¡¨ç¤ºæ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰
```c++
struct CTNode{
    int child;                  //å­©å­ç»“ç‚¹åœ¨æ•°ç»„ä¸­çš„ä½ç½®
    struct CTNode *next;        //ä¸‹ä¸€ä¸ªå­©å­
};

typedef struct{
    ElemType data;
    struct CTNode *firstChild;  //ç¬¬ä¸€ä¸ªå­©å­
}CTBox;

typedef struct{
    CTBox nodes[MAX_TREE_SIZE];
    int n,r;
}CTree;
```

- å­©å­å…„å¼Ÿè¡¨ç¤ºæ³•ï¼ˆé“¾å¼å­˜å‚¨ï¼‰
```c++
typedef struct CSNode{
    ElemType data;                          //æ•°æ®åŸŸ
    struct CSNode *firstChild,*nextSibling; //ç¬¬ä¸€ä¸ªå­©å­å’Œå³å…„å¼ŸæŒ‡é’ˆ
}CSNode,*CSTree;
```
## 5.5 æ ‘ä¸äºŒå‰æ ‘çš„åº”ç”¨
### 5.5.1 å“ˆå¤«æ›¼æ ‘å’Œå“ˆå¤«æ›¼ç¼–ç 

# ç¬¬å…­ç« â€”â€”å›¾
## 6.1 å›¾çš„åŸºæœ¬æ¦‚å¿µ
## 6.2 å›¾çš„å­˜å‚¨åŠåŸºæœ¬æ“ä½œ
### 6.2.1 é‚»æ¥çŸ©é˜µæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰

> å¯¹äº **ä¸å¸¦æƒ** çš„æ— å‘å›¾ã€æœ‰å‘å›¾
```c++
#define MaxVertexNum 100                    //é¡¶ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
typedef struct{
    char Vex[MaxVertexNum];                 //é¡¶ç‚¹è¡¨
    int Edge[MaxVertexNum][MaxVertexNum];   //é‚»æ¥çŸ©é˜µï¼Œè¾¹è¡¨
    int vexnum,arcnum;                      //å›¾çš„å½“å‰é¡¶ç‚¹æ•°å’Œè¾¹æ•°/å¼§æ•°
}MGraph;
```
- æ€§è´¨

$è®¾å›¾Gçš„é‚»æ¥çŸ©é˜µä¸ºAï¼ˆçŸ©é˜µå…ƒç´ ä¸º 0/1ï¼‰ï¼Œåˆ™  A^n çš„å…ƒç´  A^n[i][j] \\ ç­‰äº ç”±é¡¶ç‚¹ i åˆ°é¡¶ç‚¹ j çš„é•¿åº¦ä¸º n çš„è·¯å¾„çš„æ•°ç›®$

> å¯¹äºå¸¦æƒå›¾ï¼ˆç½‘ï¼‰
```c++
#define MaxVertexNum 100                        //é¡¶ç‚¹æ•°ç›®çš„æœ€å¤§å€¼
#define INFINITY æœ€å¤§çš„intå€¼                    //å®å®šä¹‰ å¸¸é‡ â€œæ— ç©·â€
typedef char VertexType;                        //é¡¶ç‚¹çš„æ•°æ®ç±»å‹
typedef int EdgeType;                           //å¸¦æƒå›¾ä¸­è¾¹ä¸Šæƒå€¼çš„æ•°æ®ç±»å‹
typedef struct{
    VertexType Vex[MaxVertexNum];               //é¡¶ç‚¹è¡¨
    EdgeType Edge[MaxVertexNum][MaxVertexNum];  //é‚»æ¥çŸ©é˜µï¼Œè¾¹çš„æƒå€¼è¡¨
    int vexnum,arcnum;                          //å›¾çš„å½“å‰é¡¶ç‚¹æ•°å’Œè¾¹æ•°/å¼§æ•°
}MGraph;
```

### 6.2.2 é‚»æ¥è¡¨æ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰
```c++
#define MaxVertexNum 100

//ç”¨é‚»æ¥è¡¨å­˜å‚¨çš„å›¾
typedef struct{
    AdjList vertices;
    int vexnum,arcnum;
}ALGraph;

//é¡¶ç‚¹
typedef struct VNode{
    VertexType data;        //é¡¶ç‚¹ä¿¡æ¯
    ArcNode *first;         //ç¬¬ä¸€æ¡è¾¹/å¼§
}VNode,AdjList[MaxVertexNum];

//â€œè¾¹/å¼§â€
typedef struct ArcNode{
    int adjvex;             //è¾¹/å¼§æŒ‡å‘å“ªä¸ªç»“ç‚¹
    struct ArcNode *next;   //æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
    //InfoType info;        //è¾¹æƒå€¼
}ArcNode;
```

## 6.3 å›¾çš„éå†
### 6.3.1 BFS å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•
```c++
#include <iostream>
using namespace std;

#define MaxVertexNum 100            //ç»“ç‚¹çš„æœ€å¤§ä¸ªæ•°
bool visited[MaxVertexNum];         //è®¿é—®æ ‡è®°æ•°ç»„

void BFSTraverse(Graph G){          //å¯¹å›¾Gè¿›è¡Œå¹¿åº¦ä¼˜å…ˆéå†
    for(int i=0;i<G.vexnum;i++){
        visited[i]=false;           //è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
    }
    InitQueue(Q);                   //åˆå§‹åŒ–è¾…åŠ©é˜Ÿåˆ—Q
    for(int i=0;i<G.vexnum;i++){    //ä»0å·é¡¶ç‚¹å¼€å§‹éå†
        if(!visited[i]){              //å¯¹æ¯ä¸ªè¿é€šåˆ†é‡è°ƒç”¨ä¸€æ¬¡BFSç®—æ³•
            BFS(G,i);               //è‹¥ç¬¬iä¸ªé¡¶ç‚¹æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ‰§è¡ŒBFS
        }
    }
}

//å¹¿åº¦ä¼˜å…ˆéå†ç®—æ³•
void BFS(Graph G,int v){            //ä»é¡¶ç‚¹vå‡ºå‘ï¼Œå¹¿åº¦ä¼˜å…ˆéå†å›¾G
    visit(v);                       //è®¿é—®åˆå§‹é¡¶ç‚¹v
    visited[v]=true;                //å¯¹é¡¶ç‚¹ v åšå·²è®¿é—®æ ‡è®°
    Enqueue(Q,v);                   //é¡¶ç‚¹vå…¥é˜Ÿåˆ—Q
    while(!isEmpty(Q)){             
        Dequeue(v);                 //é¡¶ç‚¹vå‡ºé˜Ÿåˆ—Q
        for(int w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){  //æ£€æµ‹vçš„æ‰€æœ‰é‚»æ¥ç‚¹
            if(!visited[w]){        //wä¸ºvçš„æœªè®¿é—®çš„é‚»æ¥é¡¶ç‚¹
                visit(w);           //è®¿é—®w
                visited[w]=true;      //å¯¹wåš å·²è®¿é—®æ ‡è®°
                Enqueue(Q,w);       //é¡¶ç‚¹wå…¥é˜Ÿåˆ—
            }
        }
    }
}

```

æ—¶é—´å¤æ‚åº¦ï¼š
1. é‚»æ¥çŸ©é˜µå­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ¯ä¸ªé¡¶ç‚¹çš„é‚»æ¥ç‚¹éƒ½éœ€è¦ $O(|V|)$ çš„æ—¶é—´ï¼Œæ€»å…±æœ‰ $|V|$ ä¸ªé¡¶ç‚¹
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|^2)$
2. é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ‰€æœ‰é¡¶ç‚¹çš„é‚»æ¥ç‚¹æ€»å…±éœ€è¦ $O(|E|)$ çš„æ—¶é—´
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|+|E|)$

### 6.3.2 DFS æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•
```c++
#define MaxVertexNum 100            //ç»“ç‚¹çš„æœ€å¤§ä¸ªæ•°
bool visited[MaxVertexNum];         //è®¿é—®æ ‡è®°æ•°ç»„

void DFSTraverse(Graph G){          //å¯¹å›¾Gè¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†
    for(int i=0;i<G.vexnum;i++){
        visited[i]=false;           //è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
    }
    for(int i=0;i<G.vexnum;i++){    //ä»0å·é¡¶ç‚¹å¼€å§‹éå†
        if(!visited[i]){            //å¯¹æ¯ä¸ªè¿é€šåˆ†é‡è°ƒç”¨ä¸€æ¬¡BFSç®—æ³•
            DFS(G,i);               //è‹¥ç¬¬iä¸ªé¡¶ç‚¹æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ‰§è¡ŒBFS
        }
    }
}

//æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•
void DFS(Graph G,int v){            //ä»é¡¶ç‚¹vå‡ºå‘ï¼Œæ·±åº¦ä¼˜å…ˆéå†å›¾G
    visit(v);                       //è®¿é—®åˆå§‹é¡¶ç‚¹v
    visited[v]=true;                //å¯¹é¡¶ç‚¹ v åšå·²è®¿é—®æ ‡è®°
    for(int w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){  //æ£€æµ‹vçš„æ‰€æœ‰é‚»æ¥ç‚¹
        if(!visited[w]){            //wä¸ºvçš„æœªè®¿é—®çš„é‚»æ¥é¡¶ç‚¹
            DFS(G,w);
        }
    }
}
```

æ—¶é—´å¤æ‚åº¦ï¼š
1. é‚»æ¥çŸ©é˜µå­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ¯ä¸ªé¡¶ç‚¹çš„é‚»æ¥ç‚¹éƒ½éœ€è¦ $O(|V|)$ çš„æ—¶é—´ï¼Œæ€»å…±æœ‰ $|V|$ ä¸ªé¡¶ç‚¹
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|^2)$
2. é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ï¼š
   è®¿é—® $|V|$ ä¸ªé¡¶ç‚¹éœ€è¦ $O(|V|)$ çš„æ—¶é—´
   æŸ¥æ‰¾æ‰€æœ‰é¡¶ç‚¹çš„é‚»æ¥ç‚¹æ€»å…±éœ€è¦ $O(|E|)$ çš„æ—¶é—´
   æ€»çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|+|E|)$

## 6.4åº”ç”¨
### 6.4.1 æœ€å°ç”Ÿæˆæ ‘
1. Primç®—æ³•
2. Kruskalç®—æ³•

### 6.4.2 æœ€çŸ­è·¯å¾„

> å•æºæœ€çŸ­è·¯å¾„
1. BFS æ±‚æ— æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„
```c++
void BFS_MIN_Distance(Graph G,int u){
    //d[i] è¡¨ç¤ºä» u åˆ° i ç»“ç‚¹çš„æœ€çŸ­è·¯å¾„
    for(int i=0;i<G.vexnum;i++){
        d[i] = âˆ;                   //åˆå§‹åŒ–è·¯å¾„é•¿åº¦
        path[i] = -1;               //æœ€çŸ­è·¯å¾„ä»å“ªä¸ªé¡¶ç‚¹è¿‡æ¥
    }
    d[u] = 0;
    visited[u] = true;
    EnQueue(Q,u);
    while(!isEmpty(Q)){             //BFSä¸»è¿‡ç¨‹
        DeQueue(Q,u)                //é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿ
        for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u)){
            if(!visited[w]){        //w ä¸º u å°šæœªè®¿é—®çš„é‚»æ¥ç»“ç‚¹
                d[w] = d[u] + 1;    //è·¯å¾„é•¿åº¦+1
                path[w] = u;        //æœ€çŸ­è·¯å¾„åº”å½“ä» u åˆ° w
                visited[w] = true;  //è®¾ç½®å·²è®¿é—®æ ‡è®°
                EnQueue(Q,w);       //é¡¶ç‚¹ w å…¥é˜Ÿ
            }
        }
    }
}
```

2. Dijkstraç®—æ³• ï¼ˆè¿ªæ°æ–¯ç‰¹æ‹‰â€”â€”å¸¦æƒå›¾ï¼‰

> å„ä¸ªé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­è·ç¦»

Floydç®—æ³• 
![](/pictures/Floyd.png)

$$
\begin{aligned}
& è‹¥ A^{(k-1)}[i][j] > A^{(k-1)}[i][k] + A^{(k-1)}[k][j] \\
& åˆ™ A^{(k)}[i][j] = A^{(k-1)}[i][k] + A^{(k-1)}[k][j]  \\
& path^{(k)}[i][j]=k  \\
& å¦åˆ™ A^{(k)} å’Œ path^{(k)} ä¿æŒåŸå€¼
\end{aligned}
$$

```c++
// å‡†å¤‡å·¥ä½œï¼Œæ ¹æ®å›¾çš„ä¿¡æ¯åˆå§‹åŒ–çŸ©é˜µ A å’Œ pathï¼ˆå¦‚ä¸Šå›¾ï¼‰
for(int k=0;k<n;k++){                   //è€ƒè™‘ä»¥ Vk ä½œä¸ºä¸­è½¬ç‚¹
    for(int i=0;i<n;i++){               //éå†æ•´ä¸ªçŸ©é˜µï¼Œiä¸ºè¡Œå·ï¼Œjä¸ºåˆ—å·
        for(int j=0;j<n;j++){
            if(A[i][j]>A[i][k]+A[k][j]){//ä»¥ Vk ä¸ºä¸­è½¬ç‚¹çš„è·¯å¾„æ›´çŸ­
                A[i][j]=A[i][k]+A[k][j];//æ›´æ–°æœ€çŸ­è·¯å¾„é•¿åº¦
                path[i][j]=k;           //ä¸­è½¬ç‚¹
            }
        }
    }
}
```

$$
æ—¶é—´å¤æ‚åº¦ O(|V|^3) \\
ç©ºé—´å¤æ‚åº¦ O(|V|^2)
$$

### 6.4.3 æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰æè¿°è¡¨è¾¾å¼

### 6.4.4 æ‹“æ‰‘æ’åº(é€†æ‹“æ‰‘æ’åº)
AOVç½‘ï¼šç”¨DAGå›¾è¡¨ç¤ºä¸€ä¸ªå·¥ç¨‹ï¼Œå…¶é¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨ï¼Œç”¨æœ‰å‘è¾¹ $<V_i,V_j>$ è¡¨ç¤ºæ´»åŠ¨ $V_i$ å¿…é¡»å…ˆäºæ´»åŠ¨ $V_j$ çš„è¿™æ ·ä¸€ç§å…³ç³»ï¼Œåˆ™å°†è¿™ç§æœ‰å‘å›¾ç§°ä¸ºé¡¶ç‚¹è¡¨ç¤ºæ´»åŠ¨çš„ç½‘ç»œï¼Œè®°ä¸ºAOVç½‘ã€‚

æ‹“æ‰‘æ’åºç®—æ³•ï¼š
1. ä»AOVç½‘ä¸­é€‰æ‹©ä¸€ä¸ªå…¥åº¦ä¸º0çš„é¡¶ç‚¹è¾“å‡º
2. åˆ å»æ­¤é¡¶ç‚¹ï¼Œå¹¶åˆ é™¤ä»¥æ­¤é¡¶ç‚¹ä¸ºå¼§å°¾çš„å¼§
3. é‡å¤æ­¥éª¤ç›´åˆ°è¾“å‡ºå›¾ä¸­å…¨éƒ¨é¡¶ç‚¹ï¼Œæˆ–è€…æ‰¾ä¸åˆ°å…¥åº¦ä¸º0çš„é¡¶ç‚¹ä¸ºæ­¢ã€åè€…è¡¨ç¤ºè¯¥å›¾ä¸æ˜¯DAGï¼ˆæœ‰å‘æ— ç¯å›¾ï¼‰ã€‘

```c++
#define MaxVertexNum 100    //å›¾ä¸­é¡¶ç‚¹çš„æœ€å¤§æ•°ç›®

typedef struct ArcNode{     //è¾¹è¡¨ç»“ç‚¹
    int adjvex;             //è¯¥å¼§æ‰€æŒ‡å‘çš„é¡¶ç‚¹çš„ä½ç½®
    struct ArcNode *nextarc;//æŒ‡å‘ä¸‹ä¸€æ¡å¼§çš„æŒ‡é’ˆ
    //InfoType info;        //ç½‘çš„è¾¹æƒå€¼
}ArcNode;

typedef struct VNode{       //é¡¶ç‚¹è¡¨ç»“ç‚¹
    VertexType data;        //é¡¶ç‚¹ä¿¡æ¯
    ArcNode *firstArc;      //æŒ‡å‘ç¬¬ä¸€æ¡ä¾é™„äºè¯¥é¡¶ç‚¹çš„å¼§çš„æŒ‡é’ˆ
}VNode,AdjList[MaxVertexNum];

typedef struct{
    AdjList vertices;       //é‚»æ¥è¡¨
    int vexnum,arcnum;      //å›¾çš„é¡¶ç‚¹æ•°å’Œå¼§æ•°
}Graph;                     //Graph æ˜¯ä»¥é‚»æ¥è¡¨å­˜å‚¨çš„å›¾ç±»å‹

bool TopologicalSort(Graph G){
    InitStack(S);           //åˆå§‹åŒ–æ ˆ
    for(int i=0;i<G.vexnum;i++){
        if(indegree[i]==0)  //degreeæ•°ç»„è®°å½•å½“å‰é¡¶ç‚¹çš„å…¥åº¦
            Push(S,i);      //å°†æ‰€æœ‰å…¥åº¦ä¸º0çš„é¡¶ç‚¹å…¥æ ˆ
    }
    int count=0;            //è®¡æ•°ï¼Œè®°å½•å½“å‰å·²ç»è¾“å‡ºçš„é¡¶ç‚¹æ•°
    while(!isEmpty(S)){
        Pop(S,i);           //æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
        print[count++]=i;   //printæ•°ç»„è®°å½•æ‹“æ‰‘åºåˆ—ï¼Œè¾“å‡ºé¡¶ç‚¹i
        for(p=G.vertices[i].firstarc; p ; p = p->nextarc ){ //å°†æ‰€æœ‰iæŒ‡å‘çš„é¡¶ç‚¹çš„å…¥åº¦å‡1ï¼Œå¹¶ä¸”å°†å…¥åº¦ä¸º0çš„é¡¶ç‚¹å‹å…¥æ ˆS
            v = p -> adjvex;    
            if(!(--indegree[v]))
                Push(S,v);  //å…¥åº¦ä¸º0ï¼Œåˆ™å…¥æ ˆ
        }
    }

    if(count < G.vexnum)
        return false;       //æ’åºå¤±è´¥ï¼Œæœ‰å‘å›¾ä¸­æœ‰å›è·¯
    else
        return true;        //æ‹“æ‰‘æ’åºæˆåŠŸ
}
```

é€†æ‹“æ‰‘æ’åºç®—æ³•ï¼š
1. é€†é‚»æ¥è¡¨

2. DFSç®—æ³•
```c++
#define MaxVertexNum 100            //ç»“ç‚¹çš„æœ€å¤§ä¸ªæ•°
bool visited[MaxVertexNum];         //è®¿é—®æ ‡è®°æ•°ç»„

void DFSTraverse(Graph G){          //å¯¹å›¾Gè¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†
    for(int i=0;i<G.vexnum;i++){
        visited[i]=false;           //è®¿é—®æ ‡è®°æ•°ç»„åˆå§‹åŒ–
    }
    for(int i=0;i<G.vexnum;i++){    //ä»0å·é¡¶ç‚¹å¼€å§‹éå†
        if(!visited[i]){              //å¯¹æ¯ä¸ªè¿é€šåˆ†é‡è°ƒç”¨ä¸€æ¬¡BFSç®—æ³•
            DFS(G,i);               //è‹¥ç¬¬iä¸ªé¡¶ç‚¹æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ‰§è¡ŒBFS
        }
    }
}

//æ·±åº¦ä¼˜å…ˆéå†ç®—æ³•
void DFS(Graph G,int v){            //ä»é¡¶ç‚¹vå‡ºå‘ï¼Œæ·±åº¦ä¼˜å…ˆéå†å›¾G
    visit(v);                       //è®¿é—®åˆå§‹é¡¶ç‚¹v
    visited[v]=true;                //å¯¹é¡¶ç‚¹ v åšå·²è®¿é—®æ ‡è®°
    for(int w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){  //æ£€æµ‹vçš„æ‰€æœ‰é‚»æ¥ç‚¹
        if(!visited[w]){            //wä¸ºvçš„æœªè®¿é—®çš„é‚»æ¥é¡¶ç‚¹
            DFS(G,w);
        }
    }
    print(v);                       //è¾“å‡ºé¡¶ç‚¹
}
```

### 6.4.5 å…³é”®è·¯å¾„
AOEç½‘ï¼šåœ¨å¸¦æƒæœ‰å‘å›¾ä¸­ï¼Œä»¥é¡¶ç‚¹ä»£è¡¨äº‹ä»¶ï¼Œä»¥æœ‰å‘è¾¹è¡¨ç¤ºæ´»åŠ¨ï¼Œä»¥è¾¹ä¸Šçš„æƒå€¼è¡¨ç¤ºå®Œæˆè¯¥æ´»åŠ¨çš„å¼€é”€ï¼ˆæ—¶é—´ï¼‰ï¼Œç§°ä¹‹ä¸ºç”¨è¾¹è¡¨ç¤ºæ´»åŠ¨çš„ç½‘ç»œã€‚

# ç¬¬ä¸ƒç« â€”â€”æŸ¥æ‰¾

## 7.1 æŸ¥æ‰¾çš„åŸºæœ¬æ¦‚å¿µ

## 7.2 é¡ºåºã€æŠ˜åŠã€åˆ†å—
### 7.2.1 é¡ºåºæŸ¥æ‰¾

```c++
typedef struct{         //æŸ¥æ‰¾è¡¨çš„æ•°æ®ç»“æ„ï¼ˆé¡ºåºè¡¨ï¼‰
    ElemType *elem;     //åŠ¨æ€æ•°æ®åŸºå€
    int TableLen;       //è¡¨çš„é•¿åº¦
}SSTable;

//é¡ºåºæŸ¥æ‰¾_éå“¨å…µ
int Search_Seq(SSTable ST,ElemType key){
    int i;
    for(i=0;i<ST.TableLen && ST.elem[i]!=key;i++){  //æŸ¥æ‰¾æˆåŠŸï¼Œåˆ™è¿”å›å…ƒç´ ä¸‹æ ‡ï¼›æŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™è¿”å›-1
        return i==ST.Table?-1:i;
    }
}

//é¡ºåºæŸ¥æ‰¾_å“¨å…µï¼Œæ•°æ®ä»ä¸‹æ ‡1å¼€å§‹å­˜å‚¨
int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0]=key;                          //å“¨å…µ   
    int i;
    for(i=ST.TableLen;ST.elem[i]!=key;--i){  //ä»åå¾€å‰æŸ¥æ‰¾
        return i;//æŸ¥æ‰¾æˆåŠŸï¼Œåˆ™è¿”å›å…ƒç´ ä¸‹æ ‡ï¼›æŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™è¿”å›0
    }
}
```

### 7.2.2 æŠ˜åŠæŸ¥æ‰¾
åˆç§°äºŒåˆ†æŸ¥æ‰¾ï¼Œä»…é€‚ç”¨äº <font color='red'>æœ‰åº</font> çš„ <font color='red'>é¡ºåºè¡¨</font>

$å…·æœ‰ n ä¸ª(n>0)ç»“ç‚¹çš„å®Œå…¨äºŒå‰æ ‘çš„é«˜åº¦
ä¸º \log_2{(n+1)} æˆ– \log_2{n}+1ã€‚$

$æ—¶é—´å¤æ‚åº¦ \log_{2}{n}$

```c++
typedef struct{         //æŸ¥æ‰¾è¡¨çš„æ•°æ®ç»“æ„ï¼ˆé¡ºåºè¡¨ï¼‰
    ElemType *elem;     //åŠ¨æ€æ•°æ®åŸºå€
    int TableLen;       //è¡¨çš„é•¿åº¦
}SSTable;

int Binary_Search(SSTable L,ElemType key){
    int low=0,high=L.TableLen-1,mid;
    while(low<=high){
        mid=(low+high)/2;       //å–ä¸­é—´ä½ç½®
        if(L.elem[mid]==key)
            return mid;         //æŸ¥æ‰¾æˆåŠŸåˆ™è¿”å›æ‰€åœ¨ä½ç½®
        else if(L.ele[mid]>key)
            high = mid - 1;     //ä»å‰åŠéƒ¨åˆ†ç»§ç»­æŸ¥æ‰¾
        else
            low = mid + 1;      //ä»ååŠéƒ¨åˆ†ç»§ç»­æŸ¥æ‰¾
    }
    return -1;                  //æŸ¥æ‰¾å¤±è´¥ï¼Œè¿”å› -1
}
```

### 7.2.3 åˆ†å—æŸ¥æ‰¾
```c++
//ç´¢å¼•è¡¨
typedef struct{
    ElemType maxValue;
    int low,high;
}Index;

//é¡ºåºè¡¨å®é™…å­˜å‚¨çš„å…ƒç´ 
ElemType List[100];
```
å‡è®¾ï¼Œé•¿åº¦ä¸º n çš„æŸ¥æ‰¾è¡¨è¢«å‡åŒ€åœ°åˆ†ä¸º b å—ï¼Œæ¯å— s ä¸ªå…ƒç´ 
åˆ†å—æŸ¥æ‰¾çš„å¹³å‡æŸ¥æ‰¾é•¿åº¦ä¸º $ASL_{åˆ†å—æŸ¥æ‰¾}=ASL_{ç´¢å¼•æŸ¥æ‰¾}+ASL_{å—å†…æŸ¥æ‰¾}$
â‘  ç”¨ <font color='blue'>é¡ºåº</font> æŸ¥æ‰¾ç´¢å¼•è¡¨
$$
\begin{aligned}
n &=b*s   \\[5px]
ASL_{åˆ†å—æŸ¥æ‰¾} &=ASL_{ç´¢å¼•é¡ºåº}+ASL_{å—å†…é¡ºåº}    \\[5px] 
ASL_{ç´¢å¼•é¡ºåº} &=\frac{1+2+ \dots +b}{b}=\frac{b+1}{2}    \\[5px]
ASL_{å—å†…é¡ºåº} &=\frac{1+2+ \dots +s}{s}=\frac{s+1}{2}
\end{aligned}
$$

$$
\begin{aligned}
    ASL &=\frac{b+1}{2}+\frac{s+1}{2} \\[5px]
        &=\frac{\frac{n}{s}+1}{2}+\frac{s+1}{2} \\[5px]
        &=\frac{s^2+2s+n}{2s},å½“s=\sqrt{n}æ—¶ï¼ŒASL_{æœ€å°}=\sqrt{n}+1
\end{aligned}
$$

â‘¡ ç”¨ <font color='blue'>æŠ˜åŠ</font> æŸ¥æ‰¾ç´¢å¼•è¡¨
$$ASL=\lceil \log_{2}{(b+1)} \rceil+\frac{s+1}{2}$$

## 7.3 æ ‘å‹æŸ¥æ‰¾
### 7.3.1 äºŒå‰æ’åºæ ‘ï¼ˆäºŒå‰æœç´¢æ ‘BSTï¼‰
å»ºç«‹ã€æŸ¥æ‰¾ã€æ’å…¥ç­‰ç›¸å…³æ“ä½œ
```c++
//äºŒå‰æ’åºæ ‘ç»“ç‚¹
typedef struct BSTNode{
    int key;
    struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree;

//åœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾å€¼ä¸º key çš„ç»“ç‚¹
BSTNode *BST_Search(BSTree T,int key){
    while(T!=NULL && key != T->key){    //è‹¥æ ‘ç©ºæˆ–ç­‰äºæ ¹ç»“ç‚¹å€¼ï¼Œåˆ™ç»“æŸå¾ªç¯
        if(key < (T->key))
            T=T->lchild;                //å°äºï¼Œåˆ™åœ¨å·¦å­æ ‘ä¸ŠæŸ¥æ‰¾
        else
            T=T->rchild;                //å¤§äºï¼Œåˆ™åœ¨å³å­æ ‘ä¸ŠæŸ¥æ‰¾
    }
    return T;
}

//åœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾å€¼ä¸º key çš„ç»“ç‚¹ï¼ˆé€’å½’å®ç°ï¼‰
BSTNode *BSTSearch(BSTree T,int key){
    if(T==NULL)
        return NULL;    //æŸ¥æ‰¾å¤±è´¥
    if(key==T->key)
        return T;          //æŸ¥æ‰¾æˆåŠŸ
    else if(key < T->key)
        return BSTSearch(T->lchild,key);    //åœ¨å·¦å­æ ‘ä¸­æŸ¥æ‰¾
    else
        return BSTSearch(T->rchild,key);    //åœ¨å³å­æ ‘ä¸­æŸ¥æ‰¾
}

//åœ¨äºŒå‰æ’åºæ ‘æ’å…¥å…³é”®å­—ä¸º k çš„æ–°ç»“ç‚¹ï¼ˆé€’å½’å®ç°ï¼‰
int BST_Insert(BSTree &T,int k){
    if(T==NULL){                            //åŸæ ‘ä¸ºç©ºï¼Œæ–°æ’å…¥çš„ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹
        T=(BSTree)malloc(sizeof(BSTNode));
        T->key = k;
        T->lchild=T->rchild=NULL;
        return 1;                               //è¿”å› 1 ï¼Œæ’å…¥æˆåŠŸ
    }
    else if(k==T->key)                    //æ ‘ä¸­å­˜åœ¨ç›¸åŒå…³é”®å­—çš„ç»“ç‚¹ï¼Œæ’å…¥å¤±è´¥ï¼Œè¿”å› 0
        return 0;
    else if( k < T->key)                   //æ’å…¥åˆ° T çš„å·¦å­æ ‘ 
        return BST_Insert(T->lchild,k);
    else                                        //æ’å…¥åˆ° T çš„å³å­æ ‘
        return BST_Insert(T->rchild,k);
}

//æŒ‰ç…§ str[] ä¸­çš„å…³é”®å­—åºåˆ—å»ºç«‹äºŒå‰æ’åºæ ‘
void Create_BST(BSTree &T,int str[],int n){
    T=NULL;                    //åˆå§‹åŒ– T ä¸ºç©ºæ ‘
    int i=0;
    while(i<n){                  //ä¾æ¬¡å°†æ¯ä¸ªå…³é”®å­—æ’å…¥åˆ°äºŒå‰æ’åºæ ‘ä¸­
        BST_Insert(T,str[i]);
        i++;
    }
}
```
### 7.3.2 å¹³è¡¡äºŒå‰æ ‘
```c++
#include<iostream>
using namespace std;
typedef struct AVLNode{
    int key;        //ç»“ç‚¹å…³é”®è¯
    int balance;    //å¹³è¡¡å› å­
    struct AVLNode *lchild,*rchild;
}AVLNode,*AVLTree
```

## 7.4 Bæ ‘å’ŒB+æ ‘

<font size=5px>å¦‚ä½•ä¿è¯æŸ¥æ‰¾æ•ˆç‡</font>

ç­–ç•¥1ï¼šmå‰æŸ¥æ‰¾æ ‘ä¸­ï¼Œè§„å®š <font color='red'>é™¤äº†æ ¹ç»“ç‚¹å¤–</font>ï¼Œä»»ä½•ç»“ç‚¹è‡³å°‘æœ‰$\color{red}{\lceil m/2 \rceil}$ä¸ªåˆ†å‰ï¼Œå³è‡³å°‘å«æœ‰ $\color{red}{\lceil m/2 \rceil-1}$ ä¸ªå…³é”®å­—
&emsp;exampleï¼š
&emsp;å¯¹äº5å‰æ’åºæ ‘ï¼Œé™¤äº†æ ¹ç»“ç‚¹å¤–ï¼Œä»»ä½•ç»“ç‚¹éƒ½è‡³å°‘æœ‰3ä¸ªåˆ†æ”¯ï¼Œ2ä¸ªå…³é”®å­—

ç­–ç•¥2ï¼šmå‰æŸ¥æ‰¾æ ‘ä¸­ï¼Œè§„å®šå¯¹äºä»»ä½•ä¸€ä¸ªç»“ç‚¹ï¼Œå…¶æ‰€æœ‰å­æ ‘çš„é«˜åº¦éƒ½è¦ç›¸åŒ

æ‰€æœ‰éå¶èŠ‚ç‚¹çš„ç»“æ„å¦‚ä¸‹ï¼š

$$
K_i ä»£è¡¨ç»“ç‚¹çš„å…³é”®å­—    \\[5px]
P_i ä»£è¡¨æŒ‡å‘å­æ ‘æ ¹ç»“ç‚¹çš„æŒ‡é’ˆ    \\[5px]
\begin{array}{|c|c|c|c|c|c|c|c|c|}
 n & P_0 & K_1 & P_1 & K_2 & P_2 & \dots & K_n & P_n 
\end{array}
$$

## 7.5 æ•£åˆ—è¡¨ï¼ˆå“ˆå¸Œè¡¨ï¼‰
æ„é€ æ–¹æ³•ï¼š
1. é™¤ç•™ä½™æ•°æ³• $\quad H(key)=key\mod{p}$
2. ç›´æ¥å®šå€æ³• $\quad H(key)=key \quad æˆ–è€… \quad H(key)=a*key+b \quad$ è®¡ç®—ç®€å•ï¼Œä¸ä¼šäº§ç”Ÿå†²çªï¼Œé€‚ç”¨äºå…³é”®å­—åˆ†å¸ƒåŸºæœ¬è¿ç»­çš„æƒ…å†µ
3. æ•°å­—åˆ†ææ³•  &emsp; é€‰å–æ•°ç åˆ†å¸ƒè¾ƒä¸ºå‡åŒ€çš„è‹¥å¹²ä½ä½œä¸ºæ•£åˆ—åœ°å€
4. å¹³æ–¹å–ä¸­æ³•  &emsp; å–å…³é”®å­—çš„å¹³æ–¹å€¼çš„ä¸­é—´å‡ ä½ä½œä¸ºæ•£åˆ—åœ°å€

è§£å†³å†²çªçš„æ–¹æ³•ï¼š
1. å¼€æ”¾å®šå€æ³•
   1. çº¿æ€§æ¢æµ‹æ³•
   2. å¹³æ–¹æ¢æµ‹æ³•
   3. ä¼ªéšæœºåºåˆ—æ³•
   4. å†æ•£åˆ—æ³•
2. æ‹‰é“¾æ³•


# ç¬¬å…«ç« â€”â€”æ’åº
## 8.1 æ’å…¥æ’åº
1. ç›´æ¥æ’å…¥æ’åºï¼ˆå“¨å…µä¸å¦ï¼‰
2. æŠ˜åŠæ’å…¥æ’åº
3. å†™å…¥æ’åº
```c++
//ç›´æ¥æ’å…¥æ’åº
void InsertSort(int A[],int n){
    int i,j,temp;
    for(i=0;i<n;i++){       //å°†å„å…ƒç´ æ’å…¥å·²æ’å¥½åºçš„åºåˆ—ä¸­
        temp=A[i];          //è‹¥A[i]å…³é”®å­—å°äºå‰é©±
        for(j=i-1;j>=0 && A[j]>temp;--j){   //æ£€æŸ¥æ‰€æœ‰å‰é¢å·²æ’å¥½åºçš„å…ƒç´ 
            A[j+1]=A[j];    //æ‰€æœ‰å¤§äºtempä¹Ÿå°±æ˜¯A[i]çš„å…ƒç´ éƒ½å¾€åæŒªä½
        }
        A[j+1]=temp;        //å¤åˆ¶åˆ°æ’å…¥ä½ç½®
    }
}

//ç›´æ¥æ’å…¥æ’åºï¼ˆå¸¦å“¨å…µï¼‰æ•°ç»„å­˜å‚¨ä»ä¸‹æ ‡1å¼€å§‹
void InsertSort(int A[],int n){
    int i,j;
    for(i=2;i<n;i++){
        if(A[i]<A[i-1]){
            A[0]=A[i];
            for(j=i-1;A[0]<A[j];--j){
                A[j+1]=A[j];
            }
            A[j+1]=A[0];
        }
    }
}

//æŠ˜åŠæ’å…¥æ’åº
void InsertSort(int A[],int n){
    int i,j,low,high,mid;
    for(i=2;i<=n;i++){          //ä¾æ¬¡å°†A[2]~A[n]æ’å…¥å‰é¢çš„å·²æ’åºåºåˆ—
        A[0]=A[i];              //å°†A[i]æš‚å­˜åˆ°A[0]
        low=1;
        high=i-1;               //è®¾ç½®æŠ˜åŠæŸ¥æ‰¾çš„èŒƒå›´
        while(low<=high){       //æŠ˜åŠæŸ¥æ‰¾ï¼ˆé€’å¢æœ‰åºåºåˆ—ï¼‰
            mid=(low+high)/2;
            if(A[mid]>A[0])
                high = mid-1;
            else
                low = mid+1;
        }
        for(j=i-1;j>=high+1;--j){
            A[j+1]=A[j];        //ç»Ÿä¸€åç§»å…ƒç´ ï¼Œç©ºå‡ºæ’å…¥ä½ç½®
        }
        A[high+1]=A[0];         //æ’å…¥æ“ä½œ
    }
}

//å¸Œå°”æ’åº
void ShellSort(int A[],int n){
    int d,i,j;              //A[0]åªæ˜¯æš‚å­˜å•å…ƒï¼Œä¸æ˜¯å“¨å…µï¼Œå½“j<=0æ—¶ï¼Œæ’å…¥ä½ç½®å·²åˆ°
    for(d=n/2;d>=1;d=d/2){  //æ­¥é•¿å˜åŒ–
        for(i=d+1;i<=n;i++){
            if(A[i]<A[i-d]){//éœ€å°†A[i]æ’å…¥æœ‰åºå¢é‡å­è¡¨
                A[0]=A[i];  //æš‚å­˜A[0]
                for(j=i-d;j>0&&A[0]<A[j];j-=d){
                    A[j+d]=A[j];    //è®°å½•åç§»ï¼Œå¯»æ‰¾æ’å…¥ä½ç½®
                }
                A[j+d]=A[0];//æ’å…¥
            }
        }
    }
}
```

## 8.2 äº¤æ¢æ’åº
1. å†’æ³¡æ’åº
2. å¿«é€Ÿæ’åº

```c++
//å†’æ³¡æ’åº
void swap(int& a,int &b){
    int temp = a;
    a = b;
    b = temp;
}

void BubbleSort(int A[],int n){
    for(int i=0;i<n-1;i++){
        bool flag=false;            //è¡¨ç¤ºæœ¬è¶Ÿå†’æ³¡æ˜¯å¦å‘ç”Ÿäº¤æ¢çš„æ ‡å¿—
        for(int j=n-1;j>i;j--){     //ä¸€è¶Ÿå†’æ³¡è¿‡ç¨‹
            if(A[j-1]>A[j]){        //è‹¥ä¸ºé€†åº
                swap(A[j-1],A[j])
                flag=true;
            }
            if(flag==false)         //æœ¬è¶Ÿéå†åæ²¡æœ‰å‘ç”Ÿäº¤æ¢ï¼Œè¯´æ˜è¡¨å·²ç»æœ‰åº
                return;
        }
    }
}

//å¿«é€Ÿæ’åº
void QuickSort(int A[],int low,int high){
    if(low<high){                           //é€’å½’è·³å‡ºçš„æ¡ä»¶
        int pivotpos=Partition(A,low,high); //åˆ’åˆ†
        QuickSort(A,low,pivotpos-1);        //åˆ’åˆ†å·¦å­è¡¨
        QuickSort(A,pivotpos+1,high);       //åˆ’åˆ†å³å­è¡¨
    }
}

int Partition(int A[],int low,int high){
    int pivot=A[low];                           //ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºæ¢è½´
    while(low<high){                            //ç”¨lowã€highæœç´¢æ¢è½´çš„æœ€ç»ˆä½ç½®
        while(low<high&&A[high]>=pivot) --high;
        A[low]=A[high];                         //æ¯”æ¢è½´å°çš„å…ƒç´ ç§»åŠ¨åˆ°å·¦ç«¯
        while(low<high&&A[low]<=pivot) ++low;
        A[high]=A[low];                         //æ¯”æ¢è½´å¤§çš„å…ƒç´ ç§»åŠ¨åˆ°å³ä¾§
    }
    A[low]=pivot;                               //æ¢è½´å…ƒç´ å­˜æ”¾åˆ°æœ€ç»ˆä½ç½®
    return low;                                 //è¿”å›å­˜æ”¾æ¢è½´çš„æœ€ç»ˆä½ç½®
}
```

## 8.3 é€‰æ‹©æ’åº
1. ç®€å•é€‰æ‹©æ’åº
2. æ¨æ’åº

```c++
//ç®€å•é€‰æ‹©æ’åº
void SelectSort(int A[],int n){
    for(int i=0;i<n-1;i++){         //ä¸€å…±è¿›è¡Œn-1è¶Ÿ
        int min=i;                  //è®°å½•æœ€å°å…ƒç´ ä½ç½®
        for(int j=i+1;j<n;j++){     //åœ¨A[i...n-1]ä¸­é€‰æ‹©æœ€å°çš„å…ƒç´ 
            if(A[j]<A[min]) min=j;  //æ›´æ–°æœ€å°å…ƒç´ ä½ç½®
        }
        if(min!=i)
            swap(A[i],A[min]);      //å°è£…äº¤æ¢å…ƒç´ 
    }
}

//å †æ’åº

//å»ºç«‹å¤§æ ¹å †
void BuildMaxHeap(int A[],int len){
    for(int i=len/2;i>0;i--)        //ä»åå¾€å‰è°ƒæ•´æ‰€æœ‰éç»ˆç«¯ç»“ç‚¹
        HeadAdject(A,i,len);
}

//å°†ä»¥kä¸ºæ ¹çš„å­æ ‘è°ƒæ•´ä¸ºå¤§æ ¹å †
void HeadAdjust(int A[],int k,int len){
    A[0]=A[k];                      //A[0]æš‚å­˜å­æ ‘çš„æ ¹ç»“ç‚¹
    for(int i=2*k;i<=len;i*=2){     //æ²¿ç€keyè¾ƒå¤§çš„ç»“ç‚¹å¾€ä¸‹ç­›é€‰
        if(i<len && A[i]<A[i+1])
            i++;                    //å–keyè¾ƒå¤§çš„ç»“ç‚¹å­ç»“ç‚¹çš„ä¸‹æ ‡
        if(A[0]>A[i])               //ç­›é€‰ç»“æŸ
            break;
        else{
            A[k]=A[i];              //å°†A[i]è°ƒæ•´åˆ°åŒäº²ç»“ç‚¹ä¸Š
            k=i;                    //ä¿®æ”¹kå€¼ï¼Œä»¥ä¾¿ç»§ç»­å‘ä¸‹ç­›é€‰
        }
    }
    A[k]=A[0];                      //è¢«ç­›é€‰çš„å€¼æ”¾å…¥æœ€ç»ˆä½ç½®
}

void HeapSort(int A[],int len){
    BuildMaxHeap(A,len);        //åˆå§‹å»ºå †
    for(int i=len;i>1;i--){     //n-1è¶Ÿçš„äº¤æ¢å’Œå»ºå †è¿‡ç¨‹
        swap(A[i],A[1]);        //å †é¡¶å…ƒç´ å’Œå †åº•å…ƒç´ äº¤æ¢
        HeadAdjust(A,1,i-1);    //å‰©ä½™å¾…æ’åºå…ƒç´ æ•´ç†æˆå †
    }
}
```

## 8.4 å½’å¹¶æ’åº
```c++
#include <iostream>
using namespace std;

int *B=(int *)malloc(n*sizeof(int));    //è¾…åŠ©æ•°ç»„B

//A[low...mid] A[mid+1...high]å„è‡ªæœ‰åºï¼Œå°†ä¸¤éƒ¨åˆ†å½’å¹¶
void Merge(int A[],int low,int mid,int high){
    int i,j,k;
    for(k=low;k<=high;k++)
        B[k]=A[k];                      //å°†Aä¸­æ‰€æœ‰å…ƒç´ å¤åˆ¶åˆ°Bä¸­
    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
        if(B[i]<=B[j])
            A[k]=B[i++];                //å°†è¾ƒå°å€¼å¤åˆ¶åˆ°Aä¸­
        else
            A[k]=B[j++];
    }
    while(i<=mid) A[k++]=B[i++];
    while(j<=high) A[k++]=B[j++];
}

void MergeSort(int A[],int low,int high){
    if(low<high){
        int mid=(low+high)/2;       //ä»ä¸­é—´åˆ’åˆ†
        MergeSort(A,low,mid);       //å¯¹å·¦åŠéƒ¨åˆ†å½’å¹¶æ’åº
        MergeSort(A,mid+1,high);    //å¯¹å³åŠéƒ¨åˆ†å½’å¹¶æ’åº
        Merge(A,low,mid,high);      //å½’å¹¶
    }
}
```

## 8.5 åŸºæ•°æ’åº
æ“…é•¿è§£å†³çš„é—®é¢˜ï¼š
1. æ•°æ®å…ƒç´ çš„å…³é”®å­—å¯ä»¥æ–¹ä¾¿åœ°æ‹†åˆ†ä¸ºdç»„ï¼Œä¸”dè¾ƒå°
2. æ¯ç»„å…³é”®å­—çš„å–å€¼èŒƒå›´ä¸å¤§ï¼Œå³rè¾ƒå°
3. æ•°æ®å…ƒç´ ä¸ªæ•°nè¾ƒå¤§

KMPä¼˜åŒ–ç®—æ³•æ²¡çœ‹  è§†é¢‘P37
çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±åé©±è¿˜æ²¡çœ‹å®Œ è§†é¢‘P48