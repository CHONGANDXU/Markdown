- [ç¬¬äºŒç« â€”â€”çº¿æ€§è¡¨](#ç¬¬äºŒç« çº¿æ€§è¡¨)
  - [2.3 çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º](#23-çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º)
    - [å•é“¾è¡¨](#å•é“¾è¡¨)
    - [åŒé“¾è¡¨](#åŒé“¾è¡¨)
- [ç¬¬ä¸‰ç« â€”â€”æ ˆã€é˜Ÿåˆ—å’Œæ•°ç»„](#ç¬¬ä¸‰ç« æ ˆé˜Ÿåˆ—å’Œæ•°ç»„)
  - [3.1 æ ˆ](#31-æ ˆ)
    - [æ ˆçš„é¡ºåºå­˜å‚¨ï¼ˆé¡ºåºæ ˆï¼‰](#æ ˆçš„é¡ºåºå­˜å‚¨é¡ºåºæ ˆ)
      - [å…±äº«æ ˆ](#å…±äº«æ ˆ)
    - [æ ˆçš„é“¾å¼å­˜å‚¨ï¼ˆé“¾å¼æ ˆï¼‰](#æ ˆçš„é“¾å¼å­˜å‚¨é“¾å¼æ ˆ)
    - [åº”ç”¨â€”â€”æ‹¬å·åŒ¹é…é—®é¢˜](#åº”ç”¨æ‹¬å·åŒ¹é…é—®é¢˜)
    - [åº”ç”¨â€”â€”åç¼€è¡¨è¾¾å¼](#åº”ç”¨åç¼€è¡¨è¾¾å¼)
    - [åº”ç”¨â€”â€”é€’å½’](#åº”ç”¨é€’å½’)
  - [3.2 é˜Ÿåˆ—](#32-é˜Ÿåˆ—)
    - [é¡ºåºå®ç°](#é¡ºåºå®ç°)
    - [é“¾å¼å®ç°](#é“¾å¼å®ç°)
    - [åŒç«¯é˜Ÿåˆ—](#åŒç«¯é˜Ÿåˆ—)
    - [åº”ç”¨â€”â€”æ ‘çš„å±‚æ¬¡éå†](#åº”ç”¨æ ‘çš„å±‚æ¬¡éå†)
    - [åº”ç”¨â€”â€”å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†](#åº”ç”¨å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†)
    - [åº”ç”¨â€”â€”æ“ä½œç³»ç»Ÿ FCFS(å…ˆæ¥å…ˆæœåŠ¡)](#åº”ç”¨æ“ä½œç³»ç»Ÿ-fcfså…ˆæ¥å…ˆæœåŠ¡)
- [ç¬¬å››ç« â€”â€”ä¸²](#ç¬¬å››ç« ä¸²)
  - [4.1 ä¸²çš„å®šä¹‰å’Œå®ç°](#41-ä¸²çš„å®šä¹‰å’Œå®ç°)
    - [ä¸²çš„é¡ºåºå­˜å‚¨](#ä¸²çš„é¡ºåºå­˜å‚¨)
    - [ä¸²çš„é“¾å¼å­˜å‚¨](#ä¸²çš„é“¾å¼å­˜å‚¨)
  - [4.2 ä¸²çš„æ¨¡å¼åŒ¹é…](#42-ä¸²çš„æ¨¡å¼åŒ¹é…)
    - [æœ´ç´ æ¨¡å¼åŒ¹é…ï¼ˆå®šä½æ“ä½œï¼‰](#æœ´ç´ æ¨¡å¼åŒ¹é…å®šä½æ“ä½œ)
    - [KMP](#kmp)
    - [KMPç®—æ³•ä¼˜åŒ–â€”â€”nextvalæ•°ç»„](#kmpç®—æ³•ä¼˜åŒ–nextvalæ•°ç»„)
- [ç¬¬äº”ç« â€”â€”æ ‘å’ŒäºŒå‰æ ‘](#ç¬¬äº”ç« æ ‘å’ŒäºŒå‰æ ‘)
  - [äºŒå‰æ ‘çš„é¡ºåºå­˜å‚¨](#äºŒå‰æ ‘çš„é¡ºåºå­˜å‚¨)
  - [äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨](#äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨)
  - [äºŒå‰æ ‘çš„çº¿ç´¢åŒ–](#äºŒå‰æ ‘çš„çº¿ç´¢åŒ–)
  - [çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±ï¼ˆåç»§ï¼‰](#çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±åç»§)
  - [æ ‘çš„å­˜å‚¨æ–¹å¼](#æ ‘çš„å­˜å‚¨æ–¹å¼)
  - [äºŒå‰æ’åºæ ‘](#äºŒå‰æ’åºæ ‘)
- [ç¬¬å…­ç« â€”â€”å›¾](#ç¬¬å…­ç« å›¾)
  - [å›¾çš„æ¦‚å¿µ](#å›¾çš„æ¦‚å¿µ)

# ç¬¬äºŒç« â€”â€”çº¿æ€§è¡¨
## 2.3 çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º
### å•é“¾è¡¨
```c++
#include <iostream>
using namespace std;

typedef struct LNode{   //å®šä¹‰å•é“¾è¡¨ç»“ç‚¹ç±»å‹
    ElemType data;      //æ•°æ®åŸŸ
    struct LNode *next; //æŒ‡é’ˆåŸŸ
}LNode,*LinkList;

LinkList createList_Head(LinkList &L){  //ä½¿ç”¨å¤´æ’æ³•å»ºç«‹å•é“¾è¡¨
    LNode *s;
    int x;
    L=(LinkList)malloc(sizeof(LNode));  //åˆ›å»ºå¤´ç»“ç‚¹
    L->next=NULL;                       //åˆå§‹ä¸ºç©ºé“¾è¡¨
    cin>>x;
    while (x!=9999)
    {
        s=(LNode*)malloc(sizeof(LNode));
        s->data=x;
        s->next=L->next;
        L->next=s;
        cin>>x;
    }
    return L;
}

LNode *GetElem(LinkList L,int i){   //ä½¿ç”¨ ä¸‹æ ‡ è¿”å› è¯¥å•é“¾è¡¨ç»“ç‚¹
    int j=1;
    LNode *p=L->next;
    if(i==0)
        return L;
    if(i<1)
        return NULL;
    while(p&&j<i){
        p=p->next;
        j++;
    }
    return p;
}

LNode *LocateElem(LinkList L,int e){//ä½¿ç”¨ å€¼data è¿”å› è¯¥ç‚¹é“¾è¡¨ç»“ç‚¹
    LNode *p=L->next;
    while(p!=NULL&&p->data!=e)
    {
        p=p->next;
    }
    return p;
}

LinkList InsertElem(LinkList &L,LNode *s,int n){
    LNode *p=GetElem(L,n-1);
    s->next=p->next;
    p->next=s;
    return L;
}

int main(){
    LinkList L;
    createList_Head(L);
    cout<<L;
    return 0;
}
```

### åŒé“¾è¡¨
```c++
#include <iostream>
using namespace std;

typedef struct DNode{           //å®šä¹‰åŒé“¾è¡¨ç»“ç‚¹ç±»å‹
    ElemType data;              //æ•°æ®åŸŸ
    struct DNode *prior,*next;  //å‰é©±å’Œåé©±æŒ‡é’ˆ
}DNode,*DLinkList;

bool initDLinkList(DLinkList &L){
    L = (DNode*)malloc(sizeof(DNode));//åˆ†é…ä¸€ä¸ªå¤´ç»“ç‚¹
    if(L==NULL)
        return false;
    L->piror=NULL;                    //å¤´ç»“ç‚¹çš„piroræ°¸è¿œæŒ‡å‘NULL
    L->next=NUll;                     //å¤´ç»“ç‚¹ä¹‹åæš‚æ—¶æ²¡æœ‰ç»“ç‚¹
    return true;
}

bool insertNextDNode(DNode *p,DNode *s){ //åœ¨PèŠ‚ç‚¹åæ’å…¥Sç»“ç‚¹
    if(p==NULL || s==NULL)
        return false;
    s->next=p->next;
    if(p->next != NULL)                  //å¦‚æœpæœ‰åç»§ç»“ç‚¹
        p->next->prior=s;
    s->prior=p;    
    p->next=s;
    return true;
}

bool deleteNextDNode(DNode *p){ //åˆ é™¤pç»“ç‚¹çš„åç»§ç»“ç‚¹ 
    if(p==NULL) return false;
    DNode *q=p->next;           //æ‰¾åˆ°pç»“ç‚¹çš„åç»§ç»“ç‚¹q
    if(q==NULL) return false;   //pæ²¡æœ‰åç»§ç»“ç‚¹ï¼Œqä¸ºç©º
    p->next=q->next;            
    if(q->next!=NULL)           //qä¸æ˜¯æœ€åä¸€ä¸ªç»“ç‚¹
        q->next->prior=p;       
    free(q);                    //é‡Šæ”¾ç»“ç‚¹ç©ºé—´
    return true;
}

void DestroyDLinkList(DLinkList &L){    //å¾ªç¯é‡Šæ”¾å„ä¸ªæ•°æ®ç»“ç‚¹
    while(L->next!=NULL)
        deleteNextDNode(L);
    free(L);
    L=NULL;
}

void checkAllDNode(){
    while(p!=NULL){         //åå‘éå†
        p=p->next;
    }
    while(p!=NULL){         //å‰å‘éå†
        p=p->prior;
    }
    while(p->prior!=NULL){  //å‰å‘éå†ï¼ˆè·³è¿‡å¤´ç»“ç‚¹ï¼‰
        p=p->prior;
    }
}

void testDLinkList(){
    DLinkList L;
    initDLinkList(L);
    ......
}
```

# ç¬¬ä¸‰ç« â€”â€”æ ˆã€é˜Ÿåˆ—å’Œæ•°ç»„
## 3.1 æ ˆ
### æ ˆçš„é¡ºåºå­˜å‚¨ï¼ˆé¡ºåºæ ˆï¼‰
```c++
#include <iostream>
using namespace std;

#define MaxSize 10      //å®šä¹‰æ ˆä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct{
    int data[MaxSize];  //é™æ€æ•°æ®å­˜æ”¾æ ˆä¸­å…ƒç´ 
    int top;            //æ ˆé¡¶æŒ‡é’ˆ
}SqStack;

void InitStack(SqStack &S){
    S.top = -1;             //åˆå§‹åŒ–æ ˆé¡¶æŒ‡é’ˆ
}

bool StackEmpty(SqStack S){ //åˆ¤æ–­æ ˆç©º
    if(S.top == -1)
        return true;        //æ ˆç©º
    else
        return false;       //ä¸ç©º
}

bool Push(SqStack &S,int x){//è¿›æ ˆ
    if(S.top == MaxSize-1)  //æ ˆæ»¡
        return false;
    S.top = S.top + 1 ;     //æŒ‡é’ˆ+1
    S.data[S.top] = x;      //æ–°å…ƒç´ è¿›æ ˆ
    return true;
}

bool Pop(SqStack &S,int x){ //å‡ºæ ˆ
    if(S.top == -1)
        return false;       //æ ˆç©ºï¼ŒæŠ¥é”™
    x = S.data[S.top];      //æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
    S.top = S.top - 1;      //æŒ‡é’ˆ-1
    return true;
}

//è¯»æ ˆé¡¶æŒ‡é’ˆ
bool GetTop(SqStack S,int &x){
    if(S.top == -1)
        return false;
    x = S.data[S.top];      //x è®°å½•æ ˆé¡¶å…ƒç´ 
    return true;
}
```

#### å…±äº«æ ˆ
```c++
#include <iostream>
using namespace std;

#define MaxSize 100     //å®šä¹‰æ ˆä¸­å…ƒç´ çš„æœ€å¤§ä¸ªæ•°
typedef struct{
    int data[MaxSize];  //é™æ€æ•°æ®å­˜æ”¾æ ˆä¸­å…ƒç´ 
    int top1;           //æ ˆé¡¶æŒ‡é’ˆ1
    int top2;           //æ ˆé¡¶æŒ‡é’ˆ2
}SqDouStack;

void InitStack(SqDouStack &S){
    S.top1 = -1;             //åˆå§‹åŒ–æ ˆé¡¶æŒ‡é’ˆ
    S.top2 = MaxSize;
}

bool StackEmpty(SqDouStack S){ //åˆ¤æ–­æ ˆç©º
    if(S.top1 == -1 && S.top2 == MaxSize)
        return true;        //æ ˆç©º
    else
        return false;       //ä¸ç©º
}

bool Push(SqDouStack &S,int x,int StackNum){//è¿›æ ˆ
    if(S.top1 + 1 == S.top2)  //æ ˆæ»¡
        return false;
    if(StackNum == 1){
        S.top1 = S.top1 + 1;     //1æŒ‡é’ˆ+1
        S.data[S.top1] = x;      //æ–°å…ƒç´ è¿›æ ˆ1
    }
    else{
        S.top2 = S.top2 - 1;     //2æŒ‡é’ˆ-1
        S.data[S.top1] = x;      //æ–°å…ƒç´ è¿›æ ˆ2      
    }
    return true;
}

bool Pop(SqDouStack &S,int x,int StackNum){ //å‡ºæ ˆ
    if(StackNum == 1){
        if(S.top1 == -1)
            return false;       //æ ˆç©ºï¼ŒæŠ¥é”™
        x = S.data[S.top1];      //æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
        S.top1 = S.top1 - 1;      //æŒ‡é’ˆ-1
        return true;
    }
    else{
        if(S.top2 == MaxSize)
            return false;       //æ ˆç©ºï¼ŒæŠ¥é”™
        x = S.data[S.top2];      //æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
        S.top2 = S.top2 + 1;      //æŒ‡é’ˆ-1
        return true;
    }
}

//è¯»æ ˆé¡¶æŒ‡é’ˆ
bool GetTop(SqDouStack S,int &x,int StackNum){
    if(StackNum == 1){
        if(S.top1 == -1)
            return false;
        x = S.data[S.top1];      //x è®°å½•æ ˆé¡¶å…ƒç´ 
        return true;
    }
    else{
        if(S.top2 == MaxSize)
            return false;
        x = S.data[S.top2];      //x è®°å½•æ ˆé¡¶å…ƒç´ 
        return true;
    }

}
```

### æ ˆçš„é“¾å¼å­˜å‚¨ï¼ˆé“¾å¼æ ˆï¼‰
```c++
#include <iostream>
using namespace std;

typedef struct Linknode{
    ElemType data;
    struct Linknode *next;
}*LiStack;

typedef struct LinkStack{
    LiStack top;
    int count;
}LinkStack;

bool Push(LinkStack *s, int x){
    LiStack p = (LiStack)malloc(sizeof(SNode));
    p -> data = x;
    p -> next = s -> top;
    s -> top = p;
    S -> count ++;
    return true; 
}

bool Pop(LinkStack *s, int& x){
    if(s -> top == NULL)
        return false;
    x = s->top->data;
    SLink p = s->top;
    s -> top = s->top->next;
    free(p);
    s->count--;
    return true;
}
```

### åº”ç”¨â€”â€”æ‹¬å·åŒ¹é…é—®é¢˜
```c++
#include <iostream>
using namespace std;

#define MaxSize 10
typedef struct{
    char data[MaxSize];
    int top;
}SqStack;

// åˆå§‹åŒ–æ ˆ
void InitStack(SqStack &S)

// åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©º
bool StackEmpty(SqStack S)

// æ–°å…ƒç´ å…¥æ ˆ
bool Push(SqStack &S,char x)

// æ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œç”¨xè¿”å›
bool Pop(SqStack &S,char &x)

bool bracketCheck(char str[],int length){
    SqStack S;
    InitStack(S);                   // åˆå§‹åŒ–ä¸€ä¸ªæ ˆ
    for(int i=0;i<length;i++){
        if(str[i]=='(' || str[i]=='{' ||str[i]=='['){
            Push(S,str[i])          // æ‰«æåˆ°å·¦æ‹¬å·ï¼Œå…¥æ ˆæ“ä½œ
        }else{
            if(StackEmpty(S)){      // æ‰«æåˆ°å³æ‹¬å·ï¼Œç„¶è€Œæ ˆç©ºï¼ŒåŒ¹é…é”™è¯¯
                return false;
            }

            char topElem;
            Pop(S,topElem);         // æ ˆé¡¶å…ƒç´ å‡ºæ ˆ
            if(str[i]==')' && topElem!='(')
                return false;
            if(str[i]==']' && topElem!='[')
                return false;
            if(str[i]=='}' && topElem!='{')
                return false;
        }
    }
    return StackEmpty(S);           // æ£€ç´¢å®Œå…¨éƒ¨æ‹¬å·åï¼Œæ ˆç©ºè¯´æ˜åŒ¹é…æˆåŠŸ
}
```

### åº”ç”¨â€”â€”åç¼€è¡¨è¾¾å¼
```c++

```

### åº”ç”¨â€”â€”é€’å½’
```c++
#include<iostream>
using namespace std;

int Fib(int n){
    if(n==0)
        return 0;
    else if(n==1)
        return 1;
    else
        return Fib(n-1)+Fib(n-2);
}

int main(){
    int x=Fib(4);
    cout<<x<<"  å¥¥é‡Œç»™ï¼ï¼ï¼"<<endl;
    return 0;
}
```

## 3.2 é˜Ÿåˆ—
### é¡ºåºå®ç°
```c++
#include <iostream>
using namespace std;
#define MaxSize 10
typedef struct SqQuene{
    int data[MaxSize];
    int front,rear;
};

//åˆå§‹åŒ–é˜Ÿåˆ—
void InitQueue(SqQuene& Q){
    Q.front = Q.rear = 0;
}

//åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
bool QueueEmpty(SqQuene Q){
    if(Q.front == Q.rear)
        return true;
    else
        return false;
}

//å…¥é˜Ÿ
bool EnQueue(SqQuene &Q,int x){
    if((Q.rear+1)%MaxSize == Q.front) //åˆ¤æ–­é˜Ÿæ»¡
        return false;
    Q.data[Q.rear] = x;               //æ–°å…ƒç´ æ’å…¥é˜Ÿå°¾
    Q.rear = (Q.rear + 1)%MaxSize;    //é˜Ÿå°¾æŒ‡é’ˆåŠ 1å–æ¨¡
    return true;
}

//å‡ºé˜Ÿ
bool DeQueue(SqQuene &Q,int &x){
    if(Q.front==Q.rear)         //é˜Ÿç©ºåˆ™æŠ¥é”™
        return false;
    x = Q.data[Q.front];
    Q.front=(Q.front + 1)%MaxSize;
    return true;
}

//è·å¾—é˜Ÿå¤´å…ƒç´ çš„å€¼,ç”¨xè¿”å›
bool GetHead(SqQuene Q,int& x){
    if(Q.front == Q.rear)
        return false;       //é˜Ÿç©ºåˆ™æŠ¥é”™
    x = Q.data[Q.front];
    return true;
}
```

### é“¾å¼å®ç°
```c++
#include <iostream>
using namespace std;

typedef struct LinkNode{    //é˜Ÿåˆ—ç»“ç‚¹
    int data;
    struct LinkNode *next;
}LinkNode;

typedef struct{             //é“¾å¼é˜Ÿåˆ—
    LinkNode *front,*rear;  //é˜Ÿå¤´å’Œé˜Ÿå°¾æŒ‡é’ˆ
}LinkQueue;

// åˆå§‹åŒ–é˜Ÿåˆ—(å¸¦å¤´ç»“ç‚¹)
void InitQueue(LinkQueue &Q){
    // åˆå§‹åŒ–,front rear éƒ½æŒ‡å‘å¤´ç»“ç‚¹
    Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode));
    Q.front->next = NULL;
}

// åˆå§‹åŒ–é˜Ÿåˆ—ï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
void InitQueue(LinkQueue &Q){
    // åˆå§‹åŒ–,front rear éƒ½æŒ‡å‘NULL
    Q.front = Q.rear = NULL;
}

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º(å¸¦å¤´ç»“ç‚¹)
bool IsEmpty(LinkQueue Q){
    if(Q.front == Q.rear)
        return true;
    else
        return false;
}

// åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
bool IsEmpty(LinkQueue Q){
    if(Q.front == NULL)
        return true;
    else
        return false;
}

// æ–°å…ƒç´ å…¥é˜Ÿï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
void EnQueue(LinkQueue &Q,int x){
    LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
    s->data = x;
    s->next = NULL;
    Q.rear->next = s;   //æ–°ç»“ç‚¹æ’å…¥åˆ°rearä¹‹å
    Q.rear = s;         //ä¿®æ”¹é˜Ÿå°¾æŒ‡é’ˆ
}

// æ–°å…ƒç´ å…¥é˜Ÿï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
void EnQueue(LinkQueue &Q,int x){
    LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode));
    s->data = x;
    s->next = NULL;
    if(Q.front==NULL){      //åœ¨ç©ºé˜Ÿåˆ—ä¸­æ’å…¥ç¬¬ä¸€ä¸ªå…ƒç´ 
        Q.front = s;
        Q.rear = s;
    }else{
        Q.rear->next = s;   //æ–°ç»“ç‚¹æ’å…¥åˆ°rearç»“ç‚¹ä¹‹å
        Q.rear = s;         //ä¿®æ”¹rearé˜Ÿå°¾æŒ‡é’ˆ
    }
}

// é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿï¼ˆå¸¦å¤´ç»“ç‚¹ï¼‰
bool DeQueue(LinkQueue& Q,int& x){
    if(Q.front == Q.rear)       // é˜Ÿç©º
        return false;
    LinkNode *p = Q.front->next;// pæŒ‡å‘æ­¤æ¬¡å‡ºé˜Ÿçš„é˜Ÿå¤´ç»“ç‚¹
    x = p->data;                // ç”¨ x è¿”å›é˜Ÿå¤´çš„æ•°æ®
    Q.front->next = p->next;    // ä¿®æ”¹å¤´ç»“ç‚¹çš„nextæŒ‡é’ˆ

    if(Q.rear == p)             // å¦‚æœæ˜¯æœ€åä¸€ä¸ªç»“ç‚¹å‡ºé˜Ÿ
        Q.rear = Q.front;       // ä¿®æ”¹ rear æŒ‡é’ˆ 
    free(p);                    // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
    return true;
}

// é˜Ÿå¤´å…ƒç´ å‡ºé˜Ÿï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰
bool DeQueue(LinkQueue& Q,int& x){
    if(Q.front == NULL)
        return false;       // é˜Ÿç©º
    LinkNode *p = Q.front;  // pæŒ‡å‘æ­¤æ¬¡å‡ºé˜Ÿçš„é˜Ÿå¤´ç»“ç‚¹
    x = p->data;            // ç”¨å˜é‡ x è¿”å›é˜Ÿå¤´çš„æ•°æ®
    Q.front = p->next;      // ä¿®æ”¹ front æŒ‡é’ˆ
    if(Q.rear == p){        // å€˜è‹¥æ˜¯é˜Ÿä¸­æœ€åä¸€ä¸ªç»“ç‚¹å‡ºé˜Ÿ
        Q.front = NULL;     // front æŒ‡å‘ NULL
        Q.rear = NULL;      // rear æŒ‡å‘ NULL
    }
    free(p);                // é‡Šæ”¾ç»“ç‚¹ç©ºé—´
    return true;
}

```


### åŒç«¯é˜Ÿåˆ—
```c++

```

### åº”ç”¨â€”â€”æ ‘çš„å±‚æ¬¡éå†
```c++

```

### åº”ç”¨â€”â€”å›¾çš„å¹¿åº¦ä¼˜å…ˆéå†
```c++

```

### åº”ç”¨â€”â€”æ“ä½œç³»ç»Ÿ FCFS(å…ˆæ¥å…ˆæœåŠ¡)
```c++

```

# ç¬¬å››ç« â€”â€”ä¸²
## 4.1 ä¸²çš„å®šä¹‰å’Œå®ç°
### ä¸²çš„é¡ºåºå­˜å‚¨
```c++
#include<iostream>
using namespace std;

#define MAXLEN 255
typedef struct SString{
    char ch[MAXLEN];
    int length;
};

typedef struct HString{
    char *ch;
    int length;
};

void initHString(HString &s){
    S.ch=(char *)malloc(MAXLEN*sizeof(char));
    S.length=0;
}

//èµ‹å€¼æ“ä½œï¼Œå°†ä¸²Tèµ‹å€¼ä¸ºchars
bool StrAssign(SString &T,chars){

}

//å¤åˆ¶æ“ä½œï¼Œå°†ä¸²Så¤åˆ¶å¾—åˆ°ä¸²T
bool StrCopy(){

}

//åˆ¤ç©ºæ“ä½œï¼ŒSç©ºä¸²è¿”å›TRUEï¼Œå¦åˆ™False
bool StrEmpty(){
    
}

//æ±‚ä¸²é•¿ï¼Œè¿”å›ä¸²çš„å…ƒç´ ä¸ªæ•°
bool StrLength(){
    
}

//æ±‚å­ä¸²ï¼Œç”¨Subè¿”å›ä¸²Sçš„ç¬¬posä¸ªå­—ç¬¦èµ·é•¿åº¦ä¸ºlençš„å­ä¸²
bool SubString(SString &Sub,SString S,int pos,int len){
    if(pos+len-1 > S.length)        //å­ä¸²
        return false;
    for(int i = pos;i<pos+len;i++)
        Sub.ch[i-pos+1] = S.ch[i];
    Sub.length = len;
    return true;
}

//æ¯”è¾ƒæ“ä½œ,è‹¥S>T,åˆ™è¿”å›å€¼>0;è‹¥S=T,åˆ™è¿”å›å€¼=0;è‹¥S<T,åˆ™è¿”å›å€¼<0
int StrCompare(SString S,SString T){
    for(int i=1; i<S.length && i<T.length; i++){
        if(S.ch[i]!=T.ch[i])
            return S.ch[i]-T.ch[i];
    }
    cout<<"å­—ç¬¦ä¸²é•¿åº¦ä¸ç›¸ç­‰,å…¶å·®å€¼ä¸º"<<S.length-T.length;
    return S.length-T.length;
}

//å®šä½æ“ä½œã€‚è‹¥ä¸»ä¸²Sä¸­å­˜åœ¨ä¸ä¸²Tå€¼ç›¸åŒçš„å­ä¸²ï¼Œåˆ™è¿”å›å®ƒåœ¨ä¸»ä¸²Sä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œå¦åˆ™å‡½æ•°å€¼ä¸º0
int Index(SString S,SString T){
    int i=1;
    SString sub;
    while(i<=S.length-T.length+1){
        SubString(sub,S,i,T.length);
        if(StrCompare(sub,T)!=0)
            ++i;
        else
            return i;
    }
    return 0;
}

//æ¸…ç©ºæ“ä½œï¼Œå°†Sæ¸…ç©ºä¸ºç©ºä¸²
bool ClearString(){
    
}

//é”€æ¯æ“ä½œï¼Œå›æ”¶å­˜å‚¨ç©ºé—´
bool DestoryString(){

}

//ä¸²è¿æ¥ï¼Œç”¨Tè¿”å›ç”±S1å’ŒS2è”ç»“è€Œæˆçš„æ–°ä¸²
bool Concat(){

}
```

### ä¸²çš„é“¾å¼å­˜å‚¨
```c++
#include<iostream>
using namespace std;

#define MAXLEN 255
typedef struct StringNode{
    char ch;        //æ¯ä¸ªç»“ç‚¹å­˜å‚¨1ä¸ªå­—ç¬¦ï¼Œå­˜å‚¨å¯†åº¦ä½ï¼Œæ¯ä¸ªå­—ç¬¦1Bï¼Œæ¯ä¸ªæŒ‡é’ˆ4B
    char ch[4];     //å­˜å‚¨å¯†åº¦æé«˜
    struct StringNode *next;
}StringNode,*String;

```

## 4.2 ä¸²çš„æ¨¡å¼åŒ¹é…

### æœ´ç´ æ¨¡å¼åŒ¹é…ï¼ˆå®šä½æ“ä½œï¼‰

ä¸»ä¸²çš„æ‰«ææŒ‡é’ˆ i ç»å¸¸å›æº¯ï¼Œå¯¼è‡´æ—¶é—´å¼€é”€å¢åŠ ï¼Œ<font color='red'>æœ€åæ—¶é—´å¤æ‚åº¦ O ( n m ) </font>

```c++
int Index(SString S,SString T){
    int k=1;
    int i=k,j=1;
    while(i<=S.length&&j<=T.length){
        if(S.ch[i]==T.ch[j]){
            ++i;
            ++j;        //ç»§ç»­æ¯”è¾ƒåç»§å­—ç¬¦
        }else{
            k++;        //æ£€æŸ¥åä¸€ä¸ªå­—ç¬¦ä¸²
            i=k;
            j=1;
        }
        if(j>T.length)
            return k;
        else
            return 0;
    }
}
```

### KMP

æ”¹è¿›æ€è·¯ï¼šå½“å­ä¸²å’Œæ¨¡å¼ä¸²ä¸åŒ¹é…æ—¶ï¼Œä¸»ä¸²æŒ‡é’ˆä¸å›æº¯ï¼Œåªæœ‰æ¨¡å¼ä¸²æŒ‡é’ˆå›æº¯ j = next [ j ]

<font color='red'>ç®—æ³•å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼šO ( n + m )</font>

```c++
int Index_KMP(SString S,SString T,int next[]){
    int i=1,j=1;
    while(i<=S.length&&j<=T.length){
        if(j==0 || S.ch[i]==T.ch[i]){
            ++i;
            ++j;
        }else{
            j=next[j];
        }
        if(j>T.length)
            return i-T.length;
        else
            return 0; 
    }
}
```
ğŸ’¡ nextæ•°ç»„ï¼šå½“æ¨¡å¼ä¸²çš„ç¬¬ j ä¸ªå­—ç¬¦åŒ¹é…å¤±è´¥æ—¶ï¼Œä»¤æ¨¡å¼ä¸²è·³åˆ° next [ j ] å†ç»§ç»­åŒ¹é…   
æ¨¡å¼ä¸²å‘å³ç§»åŠ¨çœ‹åŒ¹é…ç¨‹åº¦

> ä¸²çš„å‰ç¼€ï¼šåŒ…å«ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œä¸”ä¸åŒ…å«æœ€åä¸€ä¸ªå­—ç¬¦çš„å­ä¸²
ä¸²çš„åç¼€ï¼šåŒ…å«æœ€åä¸€ä¸ªå­—ç¬¦ï¼Œä¸”ä¸åŒ…å«ç¬¬ä¸€ä¸ªå­—ç¬¦çš„å­ä¸²
> 

ğŸ’¡ å½“ç¬¬ j ä¸ªå­—ç¬¦åŒ¹é…å¤±è´¥ï¼Œç”±å‰ 1 ï½ j - 1 ä¸ªå­—ç¬¦ç»„æˆçš„ä¸²è®°ä¸º S ,åˆ™ï¼š  
next [ j ] = S çš„æœ€é•¿ç›¸ç­‰å‰åç¼€é•¿åº¦ + 1  
>ç‰¹åˆ«çš„ï¼Œnext [ 1 ] = 0 ä¸” next [ 2 ] = 1


### KMPç®—æ³•ä¼˜åŒ–â€”â€”nextvalæ•°ç»„

# ç¬¬äº”ç« â€”â€”æ ‘å’ŒäºŒå‰æ ‘

## äºŒå‰æ ‘çš„é¡ºåºå­˜å‚¨
```c++
#define MaxSize 100
struct TreeNode{
    ElemType value; //ç»“ç‚¹ä¸­çš„æ•°æ®å…ƒç´ 
    bool isEmpty;   //ç»“ç‚¹æ˜¯å¦ä¸ºç©º
};

TreeNode t[MaxSize];

void initTree{      //åˆå§‹åŒ–
    for(int i=0;i<MaxSize;i++){
        t[i].isEmpty=true;
    }
}
```

## äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨
```c++
struct ElemType{
    int value;
};

typedef struct BiTNode{
    ElemType data;                  //æ•°æ®åŸŸ
    struct BiTNode *lchild,*rchild; //å·¦å³å­©å­æŒ‡é’ˆ
    struct BiTNode *parent;         //çˆ¶ç»“ç‚¹æŒ‡é’ˆ
}BiTNode,*BiTree;

BiTree root = NULL;

root = (BiTree)malloc(sizeof(BiTNode));
root -> data ={1};
root -> lchild = NULL;
root -> rchild = NULL;

// å…ˆåºéå†
void PreOrder(BiTree T){
    if(T != NULL){
        visit(T);           //è®¿é—®æ ¹ç»“ç‚¹
        PreOrder(T->lchild);//é€’å½’éå†å·¦å­æ ‘
        PreOrder(T->rchild);//é€’å½’éå†å³å­æ ‘
    }
}

//ä¸­åºéå†
void InOrder(BiTree T){
    if(T != NULL){
        InOrder(T->lchild);//é€’å½’éå†å·¦å­æ ‘
        visit(T);           //è®¿é—®æ ¹ç»“ç‚¹
        InOrder(T->rchild);//é€’å½’éå†å³å­æ ‘
    }
}

//ååºéå†
void PostOrder(BiTree T){
    if(T != NULL){
        PostOrder(T->lchild);//é€’å½’éå†å·¦å­æ ‘
        PostOrder(T->rchild);//é€’å½’éå†å³å­æ ‘
        visit(T);           //è®¿é—®æ ¹ç»“ç‚¹       
    }
}

typedef struct BiTNode{
    char data;                  //æ•°æ®åŸŸ
    struct BiTNode *lchild,*rchild; //å·¦å³å­©å­æŒ‡é’ˆ
}BiTNode,*BiTree;

//é“¾å¼é˜Ÿåˆ—ç»“ç‚¹
typedef struct LinkNode{
    BiTNode *data;
    struct LinkNode *next;
}LinkNode;

typedef struct{
    LinkNode *front,*rear; //é˜Ÿå¤´é˜Ÿå°¾
}LinkQueue;

// å±‚åºéå†
void LevelOrder(BiTree T){
    LinkQueue Q;
    InitQueue(Q);               //åˆå§‹åŒ–è¾…åŠ©é˜Ÿåˆ—
    BiTree p;
    EnQueue(Q,T);               //å°†æ ¹ç»“ç‚¹å…¥é˜Ÿ
    while(!IsEmpty(Q)){         //é˜Ÿåˆ—ä¸ç©ºåˆ™å¾ªç¯
        DeQueue(Q,p);           //é˜Ÿå¤´ç»“ç‚¹å‡ºé˜Ÿ
        visit(p);               //è®¿é—®å‡ºé˜Ÿç»“ç‚¹
        if(p->lchild!=NULL)
            EnQueue(Q,p->lchild);//å·¦å­©å­å…¥é˜Ÿ
        if(p->rchild!=NULL)
            EnQueue(Q,p->rchild);//å³å­©å­å…¥é˜Ÿ
    }
}
```

## äºŒå‰æ ‘çš„çº¿ç´¢åŒ–

- ç”¨åœŸåŠæ³•æ‰¾åˆ°ä¸­åºå‰é©±
```c++
#include <iostream>
using namespace std;

//ä¸­åºéå†
void InOrder(BiTree T){
    if(T!=NULL){
        InOrder(T->lchild); //é€’å½’éå†å·¦å­æ ‘
        visit(T);           //è®¿é—®æ ¹ç»“ç‚¹
        InOrder(T->rchild); //é€’å½’éå†å³å­æ ‘
    }
}

void visit(BiTNode *q){
    if(q==p)            //å½“å‰è®¿é—®ç»“ç‚¹åˆšå¥½æ˜¯ç»“ç‚¹p
        final = pre;    //æ‰¾åˆ°pçš„å‰é©±
    else
        pre = q;        //preæŒ‡å‘å½“å‰è®¿é—®çš„ç»“ç‚¹
}

//è¾…åŠ©çš„å…¨å±€å˜é‡ï¼Œç”¨äºæŸ¥æ‰¾ç»“ç‚¹pçš„å‰é©±
BiTNode *p;         //pæŒ‡å‘ç›®æ ‡ç»“ç‚¹
BiTNode *pre=NULL;  //æŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
BiTNode *final=NULL;//ç”¨äºè®°å½•æœ€ç»ˆç»“æœ

```

- ä¸­åºçº¿ç´¢åŒ–
```c++
#include <iostream>
using namespace std;

typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;      //å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
}ThreadNode,*ThreadTree;

void InThread(ThreadTree T){
    if(T!=NULL){
        InThread(T->lchild);
        visit(T);
        InThread(T->rchild);
    }
}

void visit(ThreadNode *q){
    if(q->lchild == NULL){  //å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL && pre->rchild == NULL){
        pre->rchild = q;    //å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
        pre->rtag = 1;
    }
    pre = q;
}

//å…¨å±€å˜é‡ pre ï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;

```

- å…ˆåºçº¿ç´¢åŒ–
> å…ˆåºçº¿ç´¢åŒ– **æœ‰ä¸ªå‘**ï¼Œåœ¨å¤„ç†æ ¹ç»“ç‚¹ä¹‹åï¼Œå¤„ç†å·¦å­©å­ä¹‹å‰ï¼Œéœ€è¦åˆ¤æ–­æ”¹å½“å‰éå†ç»“ç‚¹çš„ **ltag** æ ‡å¿—æ˜¯å¦ä¸º0ï¼Œå¦‚æœä¸º0ï¼Œåˆ™lchildä¸æ˜¯å‰é©±çº¿ç´¢
>> ã€ç»¼ä¸Šæ˜¯ä¸ºäº†é¿å…é™·å…¥éå†çš„ **æ­»å¾ªç¯**ã€‘
```c++
#include <iostream>
using namespace std;

typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;      //å·¦ã€å³çº¿ç´¢æ ‡å¿—ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œå‡è®¾éƒ½æœ‰å·¦å³å­©å­
}ThreadNode,*ThreadTree;

//å…ˆåºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void PreThread(ThreadTree T){
    if(T!=NULL){
        visit(T);               //å…ˆå¤„ç†æ ¹ç»“ç‚¹
        if(T->ltag == 0){
            PreThread(T->lchild);//å¦‚æœlchildä¸æ˜¯å‰é©±çº¿ç´¢
        }
        PreThread(T->rchild);
    }
}

void visit(ThreadNode *q){
    if(q->lchild == NULL){      //å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
        q->lchild = pre;
        q->ltag = 1;
    }
    if(pre != NULL && pre->rchild == NULL){
        pre->rchild = q;        //å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
        pre->rtag = 1;
    }
    pre = q;
}

//å…¨å±€å˜é‡ pre ï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre = NULL;
```

- ååºçº¿ç´¢åŒ–
```c++
#include <iostream>
using namespace std;

//å…¨å±€å˜é‡preï¼ŒæŒ‡å‘å½“å‰è®¿é—®ç»“ç‚¹çš„å‰é©±
ThreadNode *pre=NULL;

//ååºçº¿ç´¢åŒ–äºŒå‰æ ‘T
void CreatePostThread(ThreadTree T){
    pre=NULL;                   //preåˆå§‹åŒ–ä¸ºNULL
    if(T!=NULL){                //éç©ºäºŒå‰æ ‘æ‰èƒ½çº¿ç´¢åŒ–
        PostThread(T);          //åç»­çº¿ç´¢åŒ–äºŒå‰æ ‘
        if(pre->lchild==NULL){
            pre->rtag=1;        //å¤„ç†éå†çš„æœ€åä¸€ä¸ªç»“ç‚¹
        }
    }
}

//ååºéå†äºŒå‰æ ‘ï¼Œä¸€è¾¹éå†ä¸€è¾¹çº¿ç´¢åŒ–
void PostThread(ThreadTree T){
    if(T!=NULL){
        PostThread(T->lchild);  //ååºéå†å·¦å­æ ‘
        PostThread(T->rchild);  //ååºéå†å³å­æ ‘
        visit(T);               //è®¿é—®æ ¹ç»“ç‚¹
    }
}

void visit(ThreadNode *q){
    if(q->lchild==NULL){        //å·¦å­æ ‘ä¸ºç©ºï¼Œå»ºç«‹å‰é©±çº¿ç´¢
        q->lchild = pre;
        q->ltag=1;
    }
    if(pre!=NULL && p->rchild==NULL){
        pre->rchild = q;        //å»ºç«‹å‰é©±ç»“ç‚¹çš„åç»§çº¿ç´¢
        pre -> rtag = 1;
    } 
    pre = q;
}
```

## çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±ï¼ˆåç»§ï¼‰

- ä¸­åºçº¿ç´¢äºŒå‰æ ‘æ‰¾ä¸­åºåç»§
```c++
//æ‰¾åˆ°ä»¥Pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œç¬¬ä¸€ä¸ªè¢«ä¸­åºéå†çš„ç»“ç‚¹
ThreadNode *FirstNode(ThreadNode *p){
    while(p->ltag==0)       //å¾ªç¯å¯»æ‰¾æœ€å·¦ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
        p=p->lchild;
    return p;
}

//åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„åç»§ç»“ç‚¹
ThreadNode *NextNode(ThreadNode *p){
    id(p->rtag==0)          //å³å­æ ‘çš„æœ€å·¦ğŸ‘ˆä¸‹ç»“ç‚¹
        return FirstNode(p->rchild);
    else                    //rtag==1ï¼Œç›´æ¥è¿”å›åç»§çº¿ç´¢
        return p->rchild;
}

//å¯¹ä¸­åºçº¿ç´¢äºŒå‰æ ‘è¿›è¡Œä¸­åºéå†ï¼ˆåˆ©ç”¨çº¿ç´¢å®ç°çš„éé€’å½’ç®—æ³•ï¼‰
void InOrder(ThreadNode *T){
    for(ThreadNode *p=FirstNode(T);p!=NULL;p=NextNode(p))
        visit(p);
}
```

- ä¸­åºçº¿ç´¢äºŒå‰æ ‘æ‰¾ä¸­åºå‰é©±
```c++
//æ‰¾åˆ°ä»¥pä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œæœ€åä¸€ä¸ªè¢«ä¸­åºéå†çš„ç»“ç‚¹
ThreadNode *LastNode(ThreadNode *p){
    while(p->rtag==0)       //å¾ªç¯å¯»æ‰¾æœ€å³ğŸ‘‰ä¸‹ç»“ç‚¹ï¼ˆä¸ä¸€å®šæ˜¯å¶èŠ‚ç‚¹ï¼‰
        p=p->rchild;
    return p;
}

//åœ¨ä¸­åºçº¿ç´¢äºŒå‰æ ‘ä¸­æ‰¾åˆ°ç»“ç‚¹pçš„å‰é©±ç»“ç‚¹
ThreadNode *PreNode(ThreadNode *p){
    id(p->ltag==0)          //å·¦å­æ ‘çš„æœ€å³ä¸‹ç»“ç‚¹
        return FirstNode(p->lchild);
    else                    //rtag==1ï¼Œç›´æ¥è¿”å›å‰é©±çº¿ç´¢
        return p->lchild;
}

//å¯¹ä¸­åºçº¿ç´¢äºŒå‰æ ‘è¿›è¡Œé€†å‘ä¸­åºéå†ï¼ˆåˆ©ç”¨çº¿ç´¢å®ç°çš„éé€’å½’ç®—æ³•ï¼‰
void RevInOrder(ThreadNode *T){
    for(ThreadNode *p=LastNode(T);p!=NULL;p=PreNode(p))
        visit(p);
}
```

## æ ‘çš„å­˜å‚¨æ–¹å¼
- åŒäº²è¡¨ç¤ºæ³•ï¼ˆé¡ºåºå­˜å‚¨ï¼‰
```c++
#define MAX_TREE_SIZE 100           //æ ‘ä¸­æœ€å¤šç»“ç‚¹æ ‘

typedef struct{                     //æ ‘çš„ç»“ç‚¹å®šä¹‰
    ElemType data;                  //æ•°æ®å…ƒç´ 
    int parent;                     //åŒäº²ä½ç½®åŸŸ
}PTNode;

typedef struct{                     //æ ‘çš„ç»“æ„ç±»å‹
    PTNode nodes[MAX_TREE_SIZE];    //åŒäº²è¡¨ç¤º
    int n;                          //ç»“ç‚¹æ•°
}PTree;
```

- å­©å­è¡¨ç¤ºæ³•ï¼ˆé¡ºåº+é“¾å¼å­˜å‚¨ï¼‰
```c++
struct CTNode{
    int child;                  //å­©å­ç»“ç‚¹åœ¨æ•°ç»„ä¸­çš„ä½ç½®
    struct CTNode *next;        //ä¸‹ä¸€ä¸ªå­©å­
};

typedef struct{
    ElemType data;
    struct CTNode *firstChild;  //ç¬¬ä¸€ä¸ªå­©å­
}CTBox;

typedef struct{
    CTBox nodes[MAX_TREE_SIZE];
    int n,r;
}CTree;
```

- å­©å­å…„å¼Ÿè¡¨ç¤ºæ³•ï¼ˆé“¾å¼å­˜å‚¨ï¼‰
```c++
typedef struct CSNode{
    ElemType data;                          //æ•°æ®åŸŸ
    struct CSNode *firstChild,*nextSibling; //ç¬¬ä¸€ä¸ªå­©å­å’Œå³å…„å¼ŸæŒ‡é’ˆ
}CSNode,*CSTree;
```

## äºŒå‰æ’åºæ ‘
```c++
//äºŒå‰æ’åºæ ‘ç»“ç‚¹
typedef struct BSTNode{
    int key;
    struct BSTNode *lchild,*rchild;
}BSTNode,*BSTree;

//åœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾å€¼ä¸º key çš„ç»“ç‚¹
BSTNode *BST_Search(BSTree T,int key){
    while(T!=NULL && key != T->key){    //è‹¥æ ‘ç©ºæˆ–ç­‰äºæ ¹ç»“ç‚¹å€¼ï¼Œåˆ™ç»“æŸå¾ªç¯
        if(key < (T->key))
            T=T->lchild;                //å°äºï¼Œåˆ™åœ¨å·¦å­æ ‘ä¸ŠæŸ¥æ‰¾
        else
            T=T->rchild;                //å¤§äºï¼Œåˆ™åœ¨å³å­æ ‘ä¸ŠæŸ¥æ‰¾
    }
    return T;
}

//åœ¨äºŒå‰æ’åºæ ‘ä¸­æŸ¥æ‰¾å€¼ä¸º key çš„ç»“ç‚¹ï¼ˆé€’å½’å®ç°ï¼‰
BSTNode *BSTSearch(BSTree T,int key){
    if(T==NULL)
        return NULL;    //æŸ¥æ‰¾å¤±è´¥
    if(key==T->key)
        return T;          //æŸ¥æ‰¾æˆåŠŸ
    else if(key < T->key)
        return BSTSearch(T->lchild,key);    //åœ¨å·¦å­æ ‘ä¸­æŸ¥æ‰¾
    else
        return BSTSearch(T->rchild,key);    //åœ¨å³å­æ ‘ä¸­æŸ¥æ‰¾
}

//åœ¨äºŒå‰æ’åºæ ‘æ’å…¥å…³é”®å­—ä¸º k çš„æ–°ç»“ç‚¹ï¼ˆé€’å½’å®ç°ï¼‰
int BST_Insert(BSTree &T,int k){
    if(T==NULL){                            //åŸæ ‘ä¸ºç©ºï¼Œæ–°æ’å…¥çš„ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹
        T=(BSTree)malloc(sizeof(BSTNode));
        T->key = k;
        T->lchild=T->rchild=NULL;
        return 1;                               //è¿”å› 1 ï¼Œæ’å…¥æˆåŠŸ
    }
    else if(k==T->key)                    //æ ‘ä¸­å­˜åœ¨ç›¸åŒå…³é”®å­—çš„ç»“ç‚¹ï¼Œæ’å…¥å¤±è´¥ï¼Œè¿”å› 0
        return 0;
    else if( k < T->key)                   //æ’å…¥åˆ° T çš„å·¦å­æ ‘ 
        return BST_Insert(T->lchild,k);
    else                                        //æ’å…¥åˆ° T çš„å³å­æ ‘
        return BST_Insert(T->rchild,k);
```

# ç¬¬å…­ç« â€”â€”å›¾


KMPä¼˜åŒ–ç®—æ³•æ²¡çœ‹  è§†é¢‘P37
çº¿ç´¢äºŒå‰æ ‘æ‰¾å‰é©±åé©±è¿˜æ²¡çœ‹å®Œ è§†é¢‘P48